<!DOCTYPE html><html><head><meta charset="utf-8"><style>body {
  width: 45em;
  border: 1px solid #ddd;
  outline: 1300px solid #fff;
  margin: 16px auto;
}

body .markdown-body
{
  padding: 30px;
}

@font-face {
  font-family: fontawesome-mini;
  src: url(data:font/woff;charset=utf-8;base64,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) format('woff');
}

@font-face {
  font-family: octicons-anchor;
  src: url(data:font/woff;charset=utf-8;base64,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) format('woff');
}

.markdown-body {
  font-family: sans-serif;
  -ms-text-size-adjust: 100%;
  -webkit-text-size-adjust: 100%;
  color: #333333;
  overflow: hidden;
  font-family: "Helvetica Neue", Helvetica, "Segoe UI", Arial, freesans, sans-serif;
  font-size: 16px;
  line-height: 1.6;
  word-wrap: break-word;
}

.markdown-body a {
  background: transparent;
}

.markdown-body a:active,
.markdown-body a:hover {
  outline: 0;
}

.markdown-body b,
.markdown-body strong {
  font-weight: bold;
}

.markdown-body mark {
  background: #ff0;
  color: #000;
  font-style: italic;
  font-weight: bold;
}

.markdown-body sub,
.markdown-body sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}
.markdown-body sup {
  top: -0.5em;
}
.markdown-body sub {
  bottom: -0.25em;
}

.markdown-body h1 {
  font-size: 2em;
  margin: 0.67em 0;
}

.markdown-body img {
  border: 0;
}

.markdown-body hr {
  -moz-box-sizing: content-box;
  box-sizing: content-box;
  height: 0;
}

.markdown-body pre {
  overflow: auto;
}

.markdown-body code,
.markdown-body kbd,
.markdown-body pre,
.markdown-body samp {
  font-family: monospace, monospace;
  font-size: 1em;
}

.markdown-body input {
  color: inherit;
  font: inherit;
  margin: 0;
}

.markdown-body html input[disabled] {
  cursor: default;
}

.markdown-body input {
  line-height: normal;
}

.markdown-body input[type="checkbox"] {
  box-sizing: border-box;
  padding: 0;
}

.markdown-body table {
  border-collapse: collapse;
  border-spacing: 0;
}

.markdown-body td,
.markdown-body th {
  padding: 0;
}

.markdown-body .codehilitetable {
  border: 0;
  border-spacing: 0;
}

.markdown-body .codehilitetable tr {
  border: 0;
}

.markdown-body .codehilitetable pre,
.markdown-body .codehilitetable div.codehilite {
  margin: 0;
}

.markdown-body .linenos,
.markdown-body .code,
.markdown-body .codehilitetable td {
  border: 0;
  padding: 0;
}

.markdown-body td:not(.linenos) .linenodiv {
  padding: 0 !important;
}

.markdown-body .code {
  width: 100%;
}

.markdown-body .linenos div pre,
.markdown-body .linenodiv pre,
.markdown-body .linenodiv {
  border: 0;
  -webkit-border-radius: 0;
  -moz-border-radius: 0;
  border-radius: 0;
  -webkit-border-top-left-radius: 3px;
  -webkit-border-bottom-left-radius: 3px;
  -moz-border-radius-topleft: 3px;
  -moz-border-radius-bottomleft: 3px;
  border-top-left-radius: 3px;
  border-bottom-left-radius: 3px;
}

.markdown-body .code div pre,
.markdown-body .code div {
  border: 0;
  -webkit-border-radius: 0;
  -moz-border-radius: 0;
  border-radius: 0;
  -webkit-border-top-right-radius: 3px;
  -webkit-border-bottom-right-radius: 3px;
  -moz-border-radius-topright: 3px;
  -moz-border-radius-bottomright: 3px;
  border-top-right-radius: 3px;
  border-bottom-right-radius: 3px;
}

.markdown-body * {
  -moz-box-sizing: border-box;
  box-sizing: border-box;
}

.markdown-body input {
  font: 13px Helvetica, arial, freesans, clean, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol";
  line-height: 1.4;
}

.markdown-body a {
  color: #4183c4;
  text-decoration: none;
}

.markdown-body a:hover,
.markdown-body a:focus,
.markdown-body a:active {
  text-decoration: underline;
}

.markdown-body hr {
  height: 0;
  margin: 15px 0;
  overflow: hidden;
  background: transparent;
  border: 0;
  border-bottom: 1px solid #ddd;
}

.markdown-body hr:before,
.markdown-body hr:after {
  display: table;
  content: " ";
}

.markdown-body hr:after {
  clear: both;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  margin-top: 15px;
  margin-bottom: 15px;
  line-height: 1.1;
}

.markdown-body h1 {
  font-size: 30px;
}

.markdown-body h2 {
  font-size: 21px;
}

.markdown-body h3 {
  font-size: 16px;
}

.markdown-body h4 {
  font-size: 14px;
}

.markdown-body h5 {
  font-size: 12px;
}

.markdown-body h6 {
  font-size: 11px;
}

.markdown-body blockquote {
  margin: 0;
}

.markdown-body ul,
.markdown-body ol {
  padding: 0;
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body ol ol,
.markdown-body ul ol {
  list-style-type: lower-roman;
}

.markdown-body ul ul ol,
.markdown-body ul ol ol,
.markdown-body ol ul ol,
.markdown-body ol ol ol {
  list-style-type: lower-alpha;
}

.markdown-body dd {
  margin-left: 0;
}

.markdown-body code,
.markdown-body pre,
.markdown-body samp {
  font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;
  font-size: 12px;
}

.markdown-body pre {
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body kbd {
  background-color: #e7e7e7;
  background-image: -moz-linear-gradient(#fefefe, #e7e7e7);
  background-image: -webkit-linear-gradient(#fefefe, #e7e7e7);
  background-image: linear-gradient(#fefefe, #e7e7e7);
  background-repeat: repeat-x;
  border-radius: 2px;
  border: 1px solid #cfcfcf;
  color: #000;
  padding: 3px 5px;
  line-height: 10px;
  font: 11px Consolas, "Liberation Mono", Menlo, Courier, monospace;
  display: inline-block;
}

.markdown-body>*:first-child {
  margin-top: 0 !important;
}

.markdown-body>*:last-child {
  margin-bottom: 0 !important;
}

.markdown-body .headeranchor-link {
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  display: block;
  padding-right: 6px;
  padding-left: 30px;
  margin-left: -30px;
}

.markdown-body .headeranchor-link:focus {
  outline: none;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  position: relative;
  margin-top: 1em;
  margin-bottom: 16px;
  font-weight: bold;
  line-height: 1.4;
}

.markdown-body h1 .headeranchor,
.markdown-body h2 .headeranchor,
.markdown-body h3 .headeranchor,
.markdown-body h4 .headeranchor,
.markdown-body h5 .headeranchor,
.markdown-body h6 .headeranchor {
  display: none;
  color: #000;
  vertical-align: middle;
}

.markdown-body h1:hover .headeranchor-link,
.markdown-body h2:hover .headeranchor-link,
.markdown-body h3:hover .headeranchor-link,
.markdown-body h4:hover .headeranchor-link,
.markdown-body h5:hover .headeranchor-link,
.markdown-body h6:hover .headeranchor-link {
  height: 1em;
  padding-left: 8px;
  margin-left: -30px;
  line-height: 1;
  text-decoration: none;
}

.markdown-body h1:hover .headeranchor-link .headeranchor,
.markdown-body h2:hover .headeranchor-link .headeranchor,
.markdown-body h3:hover .headeranchor-link .headeranchor,
.markdown-body h4:hover .headeranchor-link .headeranchor,
.markdown-body h5:hover .headeranchor-link .headeranchor,
.markdown-body h6:hover .headeranchor-link .headeranchor {
  display: inline-block;
}

.markdown-body h1 {
  padding-bottom: 0.3em;
  font-size: 2.25em;
  line-height: 1.2;
  border-bottom: 1px solid #eee;
}

.markdown-body h2 {
  padding-bottom: 0.3em;
  font-size: 1.75em;
  line-height: 1.225;
  border-bottom: 1px solid #eee;
}

.markdown-body h3 {
  font-size: 1.5em;
  line-height: 1.43;
}

.markdown-body h4 {
  font-size: 1.25em;
}

.markdown-body h5 {
  font-size: 1em;
}

.markdown-body h6 {
  font-size: 1em;
  color: #777;
}

.markdown-body p,
.markdown-body blockquote,
.markdown-body ul,
.markdown-body ol,
.markdown-body dl,
.markdown-body table,
.markdown-body pre,
.markdown-body .admonition {
  margin-top: 0;
  margin-bottom: 16px;
}

.markdown-body hr {
  height: 4px;
  padding: 0;
  margin: 16px 0;
  background-color: #e7e7e7;
  border: 0 none;
}

.markdown-body ul,
.markdown-body ol {
  padding-left: 2em;
}

.markdown-body ul ul,
.markdown-body ul ol,
.markdown-body ol ol,
.markdown-body ol ul {
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body li>p {
  margin-top: 16px;
}

.markdown-body dl {
  padding: 0;
}

.markdown-body dl dt {
  padding: 0;
  margin-top: 16px;
  font-size: 1em;
  font-style: italic;
  font-weight: bold;
}

.markdown-body dl dd {
  padding: 0 16px;
  margin-bottom: 16px;
}

.markdown-body blockquote {
  padding: 0 15px;
  color: #777;
  border-left: 4px solid #ddd;
}

.markdown-body blockquote>:first-child {
  margin-top: 0;
}

.markdown-body blockquote>:last-child {
  margin-bottom: 0;
}

.markdown-body table {
  display: block;
  width: 100%;
  overflow: auto;
  word-break: normal;
  word-break: keep-all;
}

.markdown-body table th {
  font-weight: bold;
}

.markdown-body table th,
.markdown-body table td {
  padding: 6px 13px;
  border: 1px solid #ddd;
}

.markdown-body table tr {
  background-color: #fff;
  border-top: 1px solid #ccc;
}

.markdown-body table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

.markdown-body img {
  max-width: 100%;
  -moz-box-sizing: border-box;
  box-sizing: border-box;
}

.markdown-body code,
.markdown-body samp {
  padding: 0;
  padding-top: 0.2em;
  padding-bottom: 0.2em;
  margin: 0;
  font-size: 85%;
  background-color: rgba(0,0,0,0.04);
  border-radius: 3px;
}

.markdown-body code:before,
.markdown-body code:after {
  letter-spacing: -0.2em;
  content: "\00a0";
}

.markdown-body pre>code {
  padding: 0;
  margin: 0;
  font-size: 100%;
  word-break: normal;
  white-space: pre;
  background: transparent;
  border: 0;
}

.markdown-body .codehilite {
  margin-bottom: 16px;
}

.markdown-body .codehilite pre,
.markdown-body pre {
  padding: 16px;
  overflow: auto;
  font-size: 85%;
  line-height: 1.45;
  background-color: #f7f7f7;
  border-radius: 3px;
}

.markdown-body .codehilite pre {
  margin-bottom: 0;
  word-break: normal;
}

.markdown-body pre {
  word-wrap: normal;
}

.markdown-body pre code {
  display: inline;
  max-width: initial;
  padding: 0;
  margin: 0;
  overflow: initial;
  line-height: inherit;
  word-wrap: normal;
  background-color: transparent;
  border: 0;
}

.markdown-body pre code:before,
.markdown-body pre code:after {
  content: normal;
}

/* Admonition */
.markdown-body .admonition {
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  position: relative;
  border-radius: 3px;
  border: 1px solid #e0e0e0;
  border-left: 6px solid #333;
  padding: 10px 10px 10px 30px;
}

.markdown-body .admonition table {
  color: #333;
}

.markdown-body .admonition p {
  padding: 0;
}

.markdown-body .admonition-title {
  font-weight: bold;
  margin: 0;
}

.markdown-body .admonition>.admonition-title {
  color: #333;
}

.markdown-body .attention>.admonition-title {
  color: #a6d796;
}

.markdown-body .caution>.admonition-title {
  color: #d7a796;
}

.markdown-body .hint>.admonition-title {
  color: #96c6d7;
}

.markdown-body .danger>.admonition-title {
  color: #c25f77;
}

.markdown-body .question>.admonition-title {
  color: #96a6d7;
}

.markdown-body .note>.admonition-title {
  color: #d7c896;
}

.markdown-body .admonition:before,
.markdown-body .attention:before,
.markdown-body .caution:before,
.markdown-body .hint:before,
.markdown-body .danger:before,
.markdown-body .question:before,
.markdown-body .note:before {
  font: normal normal 16px fontawesome-mini;
  -moz-osx-font-smoothing: grayscale;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  line-height: 1.5;
  color: #333;
  position: absolute;
  left: 0;
  top: 0;
  padding-top: 10px;
  padding-left: 10px;
}

.markdown-body .admonition:before {
  content: "\f056\00a0";
  color: 333;
}

.markdown-body .attention:before {
  content: "\f058\00a0";
  color: #a6d796;
}

.markdown-body .caution:before {
  content: "\f06a\00a0";
  color: #d7a796;
}

.markdown-body .hint:before {
  content: "\f05a\00a0";
  color: #96c6d7;
}

.markdown-body .danger:before {
  content: "\f057\00a0";
  color: #c25f77;
}

.markdown-body .question:before {
  content: "\f059\00a0";
  color: #96a6d7;
}

.markdown-body .note:before {
  content: "\f040\00a0";
  color: #d7c896;
}

.markdown-body .admonition::after {
  content: normal;
}

.markdown-body .attention {
  border-left: 6px solid #a6d796;
}

.markdown-body .caution {
  border-left: 6px solid #d7a796;
}

.markdown-body .hint {
  border-left: 6px solid #96c6d7;
}

.markdown-body .danger {
  border-left: 6px solid #c25f77;
}

.markdown-body .question {
  border-left: 6px solid #96a6d7;
}

.markdown-body .note {
  border-left: 6px solid #d7c896;
}

.markdown-body .admonition>*:first-child {
  margin-top: 0 !important;
}

.markdown-body .admonition>*:last-child {
  margin-bottom: 0 !important;
}

/* progress bar*/
.markdown-body .progress {
  display: block;
  width: 300px;
  margin: 10px 0;
  height: 24px;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  border-radius: 3px;
  background-color: #ededed;
  position: relative;
  box-shadow: inset -1px 1px 3px rgba(0, 0, 0, .1);
}

.markdown-body .progress-label {
  position: absolute;
  text-align: center;
  font-weight: bold;
  width: 100%; margin: 0;
  line-height: 24px;
  color: #333;
  text-shadow: 1px 1px 0 #fefefe, -1px -1px 0 #fefefe, -1px 1px 0 #fefefe, 1px -1px 0 #fefefe, 0 1px 0 #fefefe, 0 -1px 0 #fefefe, 1px 0 0 #fefefe, -1px 0 0 #fefefe, 1px 1px 2px #000;
  -webkit-font-smoothing: antialiased !important;
  white-space: nowrap;
  overflow: hidden;
}

.markdown-body .progress-bar {
  height: 24px;
  float: left;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  border-radius: 3px;
  background-color: #96c6d7;
  box-shadow: inset 0 1px 0 rgba(255, 255, 255, .5), inset 0 -1px 0 rgba(0, 0, 0, .1);
  background-size: 30px 30px;
  background-image: -webkit-linear-gradient(
    135deg, rgba(255, 255, 255, .4) 27%,
    transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%,
    transparent 77%, transparent
  );
  background-image: -moz-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: -ms-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: -o-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
}

.markdown-body .progress-100plus .progress-bar {
  background-color: #a6d796;
}

.markdown-body .progress-80plus .progress-bar {
  background-color: #c6d796;
}

.markdown-body .progress-60plus .progress-bar {
  background-color: #d7c896;
}

.markdown-body .progress-40plus .progress-bar {
  background-color: #d7a796;
}

.markdown-body .progress-20plus .progress-bar {
  background-color: #d796a6;
}

.markdown-body .progress-0plus .progress-bar {
  background-color: #c25f77;
}

.markdown-body .candystripe-animate .progress-bar{
  -webkit-animation: animate-stripes 3s linear infinite;
  -moz-animation: animate-stripes 3s linear infinite;
  animation: animate-stripes 3s linear infinite;
}

@-webkit-keyframes animate-stripes {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 60px 0;
  }
}

@-moz-keyframes animate-stripes {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 60px 0;
  }
}

@keyframes animate-stripes {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 60px 0;
  }
}

.markdown-body .gloss .progress-bar {
  box-shadow:
    inset 0 4px 12px rgba(255, 255, 255, .7),
    inset 0 -12px 0 rgba(0, 0, 0, .05);
}

/* Multimarkdown Critic Blocks */
.markdown-body .critic_mark {
  background: #ff0;
}

.markdown-body .critic_delete {
  color: #c82829;
  text-decoration: line-through;
}

.markdown-body .critic_insert {
  color: #718c00 ;
  text-decoration: underline;
}

.markdown-body .critic_comment {
  color: #8e908c;
  font-style: italic;
}

.markdown-body .headeranchor {
  font: normal normal 16px octicons-anchor;
  line-height: 1;
  display: inline-block;
  text-decoration: none;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.headeranchor:before {
  content: '\f05c';
}

.markdown-body .task-list-item {
  list-style-type: none;
}

.markdown-body .task-list-item+.task-list-item {
  margin-top: 3px;
}

.markdown-body .task-list-item input {
  margin: 0 4px 0.25em -20px;
  vertical-align: middle;
}

/* Media */
@media only screen and (min-width: 480px) {
  .markdown-body {
    font-size:14px;
  }
}

@media only screen and (min-width: 768px) {
  .markdown-body {
    font-size:16px;
  }
}

@media print {
  .markdown-body * {
    background: transparent !important;
    color: black !important;
    filter:none !important;
    -ms-filter: none !important;
  }

  .markdown-body {
    font-size:12pt;
    max-width:100%;
    outline:none;
    border: 0;
  }

  .markdown-body a,
  .markdown-body a:visited {
    text-decoration: underline;
  }

  .markdown-body .headeranchor-link {
    display: none;
  }

  .markdown-body a[href]:after {
    content: " (" attr(href) ")";
  }

  .markdown-body abbr[title]:after {
    content: " (" attr(title) ")";
  }

  .markdown-body .ir a:after,
  .markdown-body a[href^="javascript:"]:after,
  .markdown-body a[href^="#"]:after {
    content: "";
  }

  .markdown-body pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
  }

  .markdown-body pre,
  .markdown-body blockquote {
    border: 1px solid #999;
    padding-right: 1em;
    page-break-inside: avoid;
  }

  .markdown-body .progress,
  .markdown-body .progress-bar {
    -moz-box-shadow: none;
    -webkit-box-shadow: none;
    box-shadow: none;
  }

  .markdown-body .progress {
    border: 1px solid #ddd;
  }

  .markdown-body .progress-bar {
    height: 22px;
    border-right: 1px solid #ddd;
  }

  .markdown-body tr,
  .markdown-body img {
    page-break-inside: avoid;
  }

  .markdown-body img {
    max-width: 100% !important;
  }

  .markdown-body p,
  .markdown-body h2,
  .markdown-body h3 {
    orphans: 3;
    widows: 3;
  }

  .markdown-body h2,
  .markdown-body h3 {
    page-break-after: avoid;
  }
}
</style><title>Elastos 开发指南</title></head><body><article class="markdown-body"><h1 id="elastos"><a name="user-content-elastos" href="#elastos" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Elastos 开发指南</h1>
<p><span id="catalog"></span></p>
<h2 id="_1"><a name="user-content-_1" href="#_1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>目录</h2>
<ul>
<li><a href="#preface">前言</a></li>
<li><a href="#codingguide">编码规范</a><ul>
<li><a href="#traslaterules">转译规则</a></li>
</ul>
</li>
<li><a href="#car">Car</a><ul>
<li><a href="#carfunction">Car 函数命名约束</a></li>
<li><a href="#carparam">Car 函数参数命名约束</a></li>
<li><a href="#carconstvar">Car 常量命名约束</a></li>
<li><a href="#carenum">Car 枚举命名约束</a></li>
<li><a href="#carconstructor">构造函数</a></li>
</ul>
</li>
<li><a href="#datatype">数据类型</a><ul>
<li><a href="#arrayof">ArrayOf</a></li>
<li><a href="#etl">ETL</a></li>
<li><a href="#typecast">类型转换</a></li>
</ul>
</li>
<li><a href="#smartptr">智能指针</a><ul>
<li><a href="#autoptr">AutoPtr</a></li>
<li><a href="#weakreference">弱引用</a></li>
</ul>
</li>
<li><a href="#thread">多线程</a></li>
<li><a href="#compile">编译</a></li>
<li><a href="#debug">调试</a><ul>
<li><a href="#crashlocation">定位 crash</a></li>
<li><a href="#memleaklocation">定位内存泄漏</a></li>
</ul>
</li>
<li><a href="#exception">异常</a></li>
<li><a href="#others">其他</a></li>
<li><a href="#qa">Q/A</a></li>
</ul>
<p><span id="preface"></span></p>
<h2 id="_2"><a name="user-content-_2" href="#_2" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>前言</h2>
<p>本文档记载有关 CAR 及常用类的使用与约束，以及开发过程中碰到的疑难杂症等等问题。Elastos 实现思路是用 C++/Car 改写 Android Java Framework 层，为了减少不必要的 Bug，在改写的过程中应当尽量保持与 Android 代码的一致。但由于资源或其他方面的考虑，改写过程中总有一些与 Android 代码不一致的地方，也在此一并做一些记录说明。</p>
<p>本文档使用 <a href="http://wowubuntu.com/markdown/">Markdown</a> 编写而成。</p>
<p><span id="codingguide"></span></p>
<h2 id="_3"><a name="user-content-_3" href="#_3" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>编码规范</h2>
<p><span id="traslaterules"></span></p>
<h3 id="_4"><a name="user-content-_4" href="#_4" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>转译规则</h3>
<ol>
<li>
<p>Java 函数返回 this 的情况<br />
    若 Java 函数 return this，则对应的 Car 函数不需用通过 out 参数返回 this 指针。由于 Car 对象不能实现函数连调(如:a-&gt;Foo()-&gt;Bar())，因此这个 out 参数可以省略，以简化调用方代码的编写。例如以下 Java 方法:</p>
<pre><code class="java">public ViewPropertyAnimator alphaBy(float value) {
    animatePropertyBy(ALPHA, value);
    return this;
}
</code></pre>

<p>对应的 CAR 函数为:</p>
<pre><code class="cpp">AlphaBy(
    [in] Float value);
</code></pre>

</li>
</ol>
<p><span id="car"></span></p>
<h2 id="car"><a name="user-content-car" href="#car" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Car</h2>
<p><span id="carfunction"></span></p>
<h3 id="car_1"><a name="user-content-car_1" href="#car_1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Car 函数命名约束</h3>
<ol>
<li>
<p>Car 函数不支持重载，因此如果一个 Car 接口的既有函数（包括从父接口继承而来的函数）已有某个特定名称的函数，而又需要继续添加参数个数或类型不同的重载函数，那么：<br />
第二个重载函数要加后缀 Ex；<br />
第三个重载函数要加后缀 Ex2；<br />
第四个重载函数要加后缀 Ex3；<br />
&hellip; 依次类推。</p>
<p>示例：</p>
<p><pre><code class="cpp">// Elastos/FrameworkDroid/Base/Core/car/graphics/Canvas.car
interface ICanvas {
    ClipRect(
        [in] IRectF* rect,
        [in] RegionOp op,
        [out] Boolean* isNonEmpty);

    ClipRectEx(
        [in] IRect* rect,
        [in] RegionOp op,
        [out] Boolean* isNonEmpty);

    ClipRectEx3(
        [in] IRect* rect,
        [out] Boolean* isNonEmpty);

    ClipRectEx4(
        [in] Float left,
        [in] Float top,
        [in] Float right,
        [in] Float bottom,
        [in] RegionOp op,
        [out] Boolean* isNonEmpty);
}
</code></pre><br />
2. 由于所有的 Car 类（形式为：CXXX）都继承自 IObject 接口，而该接口中定义了如下通用方法：</p>
<p><pre><code class="cpp">// Elastos/Runtime/Library/inc/car/elaobj.h
IObject : public IInterface
{
    virtual CARAPI Equals(
        /* [in] */ IInterface *object,
        /* [out] */ _ELASTOS Boolean *equals) = 0;

    virtual CARAPI GetHashCode(
        /* [out] */ _ELASTOS Int32 *hashCode) = 0;

    virtual CARAPI ToString(
        /* [out] */ _ELASTOS String *info) = 0;
};
</code></pre><br />
并提供了基于地址比较，返回地址作为 HashCode 以及 ToString 返回十六进制显示的地址的默认实现。因此如果你需要自己的 Car 接口中提供这些函数的不同实现，请在自己的 Car 接口中同时提供这三个函数，而且这三个函数都不需要添加后缀。如果需要提供不是比较 IInterface 的便利比较函数，这些便利函数的命名遵循前一条款中的命名约束。</p>
<p>示例：<br />
/Elastos/FrameworkDroid/Base/Core/car/graphics/Point.car</p>
<pre><code class="cpp">interface IPoint {
    EqualsEx2(
        [in] Int32 x,
        [in] Int32 y,
        [out] Boolean* result);

    EqualsEx(
        [in] IPoint* p,
        [out] Boolean* result);

    Equals(
        [in] IInterface* obj,
        [out] Boolean* isEqual);

    GetHashCode(
        [out] Int32* hash);

    ToString(
        [out] String* info);
}
</code></pre>

</li>
</ol>
<p><span id="carparam"></span></p>
<h3 id="car_2"><a name="user-content-car_2" href="#car_2" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Car 函数参数命名约束</h3>
<ol>
<li>
<p>Car 关键字不能用作参数名。比如：<strong>in，out，callback，callee</strong> 等等。</p>
</li>
<li>
<p>Car 接口中不能出现两个同名，参数个数，参数名称，参数顺序都一样，仅参数类型不一样的 Car 函数。这是为了在<a href="http://en.wikipedia.org/wiki/Name_mangling">命名重整（name mangling）</a> 时能兼容没有类型概念的动态语言，如：Javascript。这一点尤其体现在 Car 构造函数 <strong>constructor</strong> 上，因为 Car 构造函数必定是同名的，只可能是 <strong>constructor</strong>，此时，只能通过采用不同的参数名字来区分。</p>
<p>示例：</p>
<pre><code class="cpp">// Elastos/LibCore/src/Elastos/Security/Elastos.Security.car
class CPKIXBuilderParameters {
    constructor();

    constructor(
        [in] ISet* trustAnchors,
        [in] ICertSelector* targetConstraints);

    constructor(
        [in] IKeyStore* keyStore,
        [in] ICertSelector* targetConstraints);

    interface IPKIXBuilderParameters;
}
</code></pre>

</li>
<li>
<p>Widget 类的 Car 构造函数 <strong>constructor</strong> 的参数命名有特殊的规则，为了支持从 xml 中解析出来 Widget 类名称创建对应的 Widget（即支持 Reflection），所有实现 IView/IActionProvider 接口的 Car 类的构造函数 <strong>constructor</strong> 的第一个参数若为 IContext* 类型则参数名称为 ctx；第二个参数若为 IAttributeSet* 类型则参数名称为 attrs。</p>
<p>示例：</p>
<pre><code class="cpp">// Elastos/FrameworkDroid/Base/Core/car/widget.car
class CView {
    constructor(
        [in] IContext* ctx);

    constructor(
        [in] IContext* ctx,
        [in] IAttributeSet* attrs);

    constructor(
        [in] IContext* ctx,
        [in] IAttributeSet* attrs,
        [in] Int32 defStyle);

    interface IView;
    interface IDrawableCallback;
    interface IKeyEventCallback;
    interface IAccessibilityEventSource;
}
</code></pre>

</li>
</ol>
<p><span id="carconstvar"></span></p>
<h3 id="car_3"><a name="user-content-car_3" href="#car_3" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Car 常量命名约束</h3>
<ol>
<li>
<p>Car 中可以定义 const Int32 和 const String 常量，这些常量名字请大写，若名字中包含多个单词，请用下划线连接起来。</p>
</li>
<li>
<p>为了减少与 C++ 宏名字或全局变量名称的冲突，请不要使用那些简单过于抽象的名字，如：MAX，ID，IP 等。</p>
</li>
</ol>
<p><span id="carenum"></span></p>
<h3 id="car_4"><a name="user-content-car_4" href="#car_4" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Car 枚举命名约束</h3>
<ol>
<li>
<p>枚举成员的名字均为大写，并以该枚举的名字大写为前缀，若名字中包含多个单词，请用下划线连接起来。</p>
</li>
<li>
<p>为了减少与 C++ 宏名字或全局变量名称的冲突，请不要使用那些简单过于抽象的名字，如：MAX，ID，IP 等。</p>
</li>
</ol>
<p><span id="carconstructor"></span></p>
<h3 id="_5"><a name="user-content-_5" href="#_5" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>构造函数</h3>
<ol>
<li>
<p>对于一个 Car 类 CXXX 来说，它有两种构造函数：C++ 构造函数 CXXX() 和 Car 构造函数 constrctor()。这两种构造函数有些类似：</p>
<ul>
<li>如果没有提供自定义的实现则都会提供一个默认的无参的实现；</li>
<li>都支持构造函数重载；</li>
</ul>
<p>但又有很大的不同：</p>
<ul>
<li>C++ 构造函数支持初始化列表，而 Car 构造函数不支持；</li>
<li>在 C++ 构造函数执行时，该对象还未就绪，而 Car 构造函数执行时，对象已经就绪；</li>
</ul>
<p>利用以上事实，我们可以利用 C++ 构造函数的初始化列表初始化成员变量。</p>
</li>
<li>
<p>对于实现了 IParcelble 接口的 Car 类来说，它必须有一个可调用的无参的 Car 构造函数 constrctor（无论是默认提供的，还是显式提供的）。这是为了支持 unmarshall，即 unmarshall 时，先调用这个无参的 Car 构造函数创建对象，然后再转型为 IParcelble，调用 IParcelble::ReadFromParcel() 来设置对象的成员。因此统一规定，凡是实现了 IParcelable 的 Car 类都必须显式提供一个无参的 Car 构造函数。</p>
<p>示例：</p>
<pre><code class="cpp">// Elastos/FrameworkDroid/Base/Core/car/accounts.car
class CAccount {
    constructor();

    constructor(
        [in] String name,
        [in] String type);

    interface IAccount;
    interface IParcelable;
}

</code></pre>

</li>
</ol>
<p><span id="datatype"></span></p>
<h2 id="_6"><a name="user-content-_6" href="#_6" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>数据类型</h2>
<p><span id="arrayof"></span></p>
<h3 id="arrayof"><a name="user-content-arrayof" href="#arrayof" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>ArrayOf</h3>
<ol>
<li>
<p>简介<br />
    <code>ArrayOf</code>实现了类似数组的功能，即在一块连续的内存中分配若干个元素。同时 <code>ArrayOf</code>能对 Car 对象指针，继承自<code>ElRefBase/ElLightRefBase</code>类的对象指针以及 String 进行自动应用计数管理（前提是通过<code>Set(Int32 index, T const other)</code>设置元素。</p>
<p><code>ArrayOf</code>自身实现了引用计数，因此通常情况下，它都是与<code>AutoPtr</code>结合在一起使用的。</p>
<p><code>ArrayOf</code>源码定义在<code>Elastos/Runtime/Library/inc/eltypes/elquintet.h</code>中。</p>
</li>
<li>
<p>引用计数说明<br />
    引起<code>ArrayOf</code>引用计数变化的成员方法可以分为三组:</p>
<ul>
<li>
<p>创建操作(<code><strong>Alloc/Clone</strong></code>)：<br />
创建或克隆一个新对象，并且引用计数为 0（即还没有引入引用计数机制），返回的新对象需要加入<code>AutoPtr</code>自动释放或手动调用<code>Free/Release</code>释放；</p>
</li>
<li>
<p>减少引用计数操作(<code><strong>Release/Free</strong></code>)：<br />
<code>Release/Free</code>这两个接口完全等价，出于一致性考虑请使用<code>Release()</code>，或加入<code>AutoPtr</code>由<code>AutoPtr</code>在内部调用<code>Release()</code>自动减少引用计数，并在恰当的时候释放分配的内存；</p>
</li>
<li>
<p>增加引用计数(<code><strong>AddRef</strong></code>)：<br />
将一个<code>ArrayOf</code>指针赋值给一个<code>AutoPtr</code>变量就是调用<code>AddRef</code>来增加引用计数的。如果需要手动增加引用计数，通常使用宏<code>INTERFACE_ADDREF(array)</code>来实现。</p>
</li>
</ul>
</li>
<li>
<p>注意事项</p>
<ul>
<li>
<p>对于能放入其中的元素，请考虑是否需要对元素进行引用计数管理，若需要请让该元素能够支持引用计数，然后调用<code>Set(Int32 index, T const other)</code>设置元素。简单地通过下标索引器<code>[]</code>赋值并不会自动进行引用计数管理。</p>
</li>
<li>
<p><code>ArrayOf</code>会调用<code>memset</code>将分配到的内存清零，因此<code>ArrayOf</code>只能存放基本数据类型，<a href="http://zh.wikipedia.org/wiki/POD_(%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1)">POD 对象</a>以及指针，而无法存放带有虚函数或用自定义构造函数进行初始化的对象，因为它不会调用构造函数初始化其元素，而是简单地将内存清零。</p>
</li>
<li>
<p><code>ArrayOf</code>支持分配 0 个元素，即支持<code>ArrayOf<T>::Alloc(0);</code>这种用法，这对减少<code>NULL</code>判断，简化代码大有好处。</p>
</li>
<li>
<p>对于能够适用于<code>AutoPtr&lt; T &gt;</code>的类型 T，该类型的指针就能直接作为 <code>ArrayOf</code>的元素类型，即能够使用<code>ArrayOf&lt; T *&gt;</code>的形式，而不需要使用<code>ArrayOf&lt; AutoPtr&lt; T &gt; &gt;</code>的形式。因此，不应该出现<code>ArrayOf&lt; AutoPtr&lt; T &gt; &gt;</code>形式的代码。</p>
</li>
</ul>
</li>
<li>
<p>典型使用场景</p>
<ul>
<li>
<p>一般场景</p>
<pre><code class="cpp">// ThreadGroup.cpp
AutoPtr&lt;ArrayOf&lt;IThread *&gt; &gt; newThreads;
newThreads = ArrayOf&lt;IThread *&gt;::Alloc(mNumThreads * 2);
newThreads-&gt;Copy(mChildrenThreads, 0, mNumThreads);
newThreads-&gt;Set(mNumThreads++, thread);
mChildrenThreads = newThreads;
</code></pre>

</li>
<li>
<p>作为 Car 函数的<code>out, callee</code>参数  </p>
<pre><code class="cpp">// IPackageInfo.car
interface IPackageInfo {
    GetActivities(
        [out, callee] ArrayOf&lt;IActivityInfo*&gt;* activities);
}

// CPackageInfo.h
CarClass(CPackageInfo) {
    CARAPI GetActivities(
        /* [out, callee] */ ArrayOf&lt;IActivityInfo*&gt;** activities);
}

// CPackageInfo.cpp
ECode CPackageInfo::GetActivities(
    /* [out, callee] */ ArrayOf&lt;IActivityInfo*&gt;** activities) {
    VALIDATE_NOT_NULL(activities);
    *activities = mActivities;
    INTERFACE_ADDREF(*activities);
    return NOERROR;
}

// 调用方
AutoPtr&lt;IPackageInfo&gt; info;
...
AutoPtr&lt; ArrayOf&lt;IActivityInfo*&gt; &gt; activities;
info-&gt;GetActivities((ArrayOf&lt;IActivityInfo*&gt; **)&amp;activities);
</code></pre>

</li>
<li>
<p>作为函数返回值</p>
<pre><code class="cpp">// CHardwareCamera.h
AutoPtr&lt;ArrayOf&lt;IInteger32*&gt; &gt; SplitInt(
    /* [in] */ const String&amp; str);
</code></pre>

</li>
</ul>
</li>
<li>
<p>双重数组<br />
对于双重数组，请使用<code>AutoPtr\<ArrayOf\<AutoPtr\<ArrayOf\<T\> \> \> \></code>形式。为了简化代码的编写，有两种办法，这两种办法都实现在<code>elquintent.h</code>文件中：</p>
<ul>
<li>
<p>使用模板类。优点:通用性好。缺点:可读性不好。</p>
<pre><code class="cpp">// 定义：elquintent.h
template &lt;typename T&gt; class ArrayOf2 {
public:
    typedef AutoPtr&lt;ArrayOf&lt;T&gt; &gt; ElementType;
    typedef ArrayOf&lt;ElementType&gt; Type;
}
</code></pre>

</li>
<li>
<p>使用预定义的<code>typedef</code>。优点:可读性好。缺点:不能通用。</p>
<pre><code class="cpp">// 定义：elquintent.h
typedef AutoPtr&lt;ArrayOf&lt;Byte&gt; &gt;     ByteArray;
typedef AutoPtr&lt;ArrayOf&lt;Char32&gt; &gt;   Char32Array;
typedef AutoPtr&lt;ArrayOf&lt;String&gt; &gt;   StringArray;
typedef AutoPtr&lt;ArrayOf&lt;Int32&gt; &gt;    Int32Array;
typedef AutoPtr&lt;ArrayOf&lt;Int64&gt; &gt;    Int64Array;
typedef AutoPtr&lt;ArrayOf&lt;Float&gt; &gt;    FloatArray;
typedef AutoPtr&lt;ArrayOf&lt;Double&gt; &gt;   DoubleArray;

// 使用：View.h
static const AutoPtr&lt;ArrayOf&lt;Int32Array&gt; &gt; VIEW_STATE_SETS;
</code></pre>

</li>
</ul>
</li>
</ol>
<p><span id="etl"></span></p>
<h3 id="etl"><a name="user-content-etl" href="#etl" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>ETL</h3>
<ol>
<li>
<p>简介<br />
    ETL 是基于 SGI 实现的一套 C++ 模版库，它的使用方法与 STL 相似。</p>
<p>在使用 ETL 之前需要预设一些宏，这些宏在<code>#include <cmdef.h>(Libcore 下)</code> 和<code>#include \<ext/frameworkdef.h> (Framework 下)</code>中有定义，所以在<code>include</code>任何 ETL 容器头文件之前，务必先<code>include</code>这两个头文件之一。</p>
</li>
<li>
<p>引用计数说明<br />
    ETL 中的容器自身都添加了引用计数功能，因此可以使用 AutoPtr 包装它们，如：AutoPtr&lt; List<Int32> &gt;。但 ETL 容器并不会修改放置在它里面的元素的引用计数，这一点与 STL 的行为是一致的。</p>
</li>
<li>
<p>遍历过程中如何修改迭代器<br />
    要特别留意在使用<code>Iterator/ReverseIterator</code>遍历的过程中修改迭代器的情况，常见的情形就是遍历过程中调用<code>Erase</code>修改迭代器使得当前迭代器失效（请参考<a href="http://book.douban.com/subject/1243751/">Effective STL</a>）。下面将介绍各种容器分别在正向和反向遍历过程中<code>Erase</code>元素的正确使用方法。</p>
<ul>
<li>
<p>对于正向迭代器 Iterator 来说，List 和 HashMap 各有不同。</p>
<p>List 的 Erase 返回下一个迭代器，所以使用<code>it = Erase(it)</code>即可；而 HashMap 的<code>Erase</code>返回<code>void</code>，所以需要生成当前迭代器的副本，然后递增当前迭代器，再<code>Erase</code>副本，这个顺序一定不能错。又因为 HashMap 重载的后缀++操作符是先创建副本，然后递增迭代器，然后返回副本，所以可以使用<code>map.Erase(mit++)</code>简化代码。  </p>
<p>List 使用示例:</p>
<pre><code class="cpp">List&lt;Int32&gt;::Iterator it;
for (it = list.Begin(); it != list.End();) {
    if (0 == (*it)%2) {
        it = list.Erase(it);
    }
    else {
        ++it;
    }
}
</code></pre>

<p>HashMap 使用示例:  </p>
<pre><code class="cpp">HashMap&lt;Int32, Int32&gt;::Iterator mit;
for (mit = map.Begin(); mit != map.End();) {
    if (0 == mit-&gt;mFirst % 2) {
        map.Erase(mit++);
    }
    else {
        ++mit;
    }
}
</code></pre>

</li>
<li>
<p>对于反向迭代器，HashMap 没有反向迭代器，就只有 List 一种情形。由于反向迭代器是由后往前和正向迭代器相差一个元素，而<code>Erase</code>只接收正向迭代器，因此需要将反向迭代器转换为正向迭代器，情况更加复杂。首先要获得合适的正向迭代器，所以需要<code>&ndash;(rit.GetBase())</code>获得需要删除元素的正向迭代器，然后调用 Erase 删除该元素。然后将<code>Erase</code>返回的正向迭代器。</p>
<p>List 使用示例:  </p>
<pre><code class="cpp">List&lt;Int32&gt;::ReverseIterator rit;
for (rit = list.RBegin(); rit != list.REnd();) {
    if(0 == (*rit) % 2) {
        rit = List&lt;Int32&gt;::ReverseIterator(list.Erase(--(rit.GetBase())));
    }
    else {
        ++rit;
    }
}
</code></pre>

</li>
<li>
<p>对 Erase 的用法 HashSet 与 HashMap 相同，Vector 用 Iterator 进行<code>Erase</code>与 List 相同，但 ReverseIterator 与 List 略有不同，因为 Vector 删除一个元素之后会进行内存拷贝，所以所删元素之后的迭代器均会失效，但 Vector 与 List 用 ReverseIterator 进行<code>Erase</code>可以统一到一个形式中去，所以统一下用法如下:</p>
<ul>
<li>
<p>使用 List/Vector 的正向迭代器 Iterator 遍历删除。  </p>
<pre><code class="cpp">List&lt;Int32&gt;::Iterator lit;
...
lit = list.Erase(lit);

Vector&lt;Int32&gt;::Iterator vit;
...
vit = vector.Erase(vit);
</code></pre>

</li>
<li>
<p>使用 List/Vector 的反向迭代器 ReverseIterator 遍历删除。  </p>
<pre><code class="cpp">List&lt;Int32&gt;::ReverseIterator lrit;
...
lrit = List&lt;Int32&gt;::ReverseIterator(list.Erase(--(lrit.GetBase())));

Vector&lt;Int32&gt;::ReverseIterator vrit;
...
vrit = Vector&lt;Int32&gt;::ReverseIterator(vector.Erase(--(vrit.GetBase())));
</code></pre>

</li>
</ul>
</li>
<li>
<p>使用 HashMap/HashSet 的正向迭代器 Iterator 遍历删除。  </p>
<pre><code>``` cpp
HashMap&lt;Int32, Int32&gt;::Iterator mit;
...
map.Erase(mit++);

HashSet&lt;Int32&gt;::Iterator sit;
...
set.Erase(sit++);
```
</code></pre>
</li>
</ul>
</li>
<li>
<p>Car 对象作为 HashMap/HashSet 的 key<br />
    用 Car 对象作为 HashMap/HashSet 的 key 需要考虑是使用对象地址还是使用对象的 GetHashCode 返回的 hash 值作为 key 值。这需要特化<code>Hash/EqualTo</code>这两个类模版已满足 ETL 用作 key 的约束。在<code>frameworkhash.h</code>中针对 Car 接口提供了一些便利的宏，并且通常也在其中定义这些特化模版。</p>
</li>
<li>
<p>错误用法<br />
    下面是用正向迭代器进行反向遍历的错误代码，请留意:</p>
<pre><code class="cpp">List&lt;Int32&gt;::Iterator it = list-&gt;End() - 1;
for (; it != list-&gt;Begin(); it--) {
    if (...) {
        list-&gt;Erase(it);
    }
}
</code></pre>

<p>这是一种错误的用法，请使用反向迭代器 ReverseIterator 进行遍历。</p>
</li>
<li>
<p>其他容器  </p>
<ul>
<li>
<p>由于 ETL 不能作为参数用在 Car 函数中，所以需要有 Car 接口容器类，当前代码中使用到<code>IArray，IObjectContainer，IObjectInt32Map，IObjectStringMap</code>等几个主要的 Car 接口容器类。</p>
<p>IObjectContainer 用法示例：</p>
<pre><code class="cpp">AutoPtr&lt;IProviderInfo&gt; provider;
...

AutoPtr&lt;IObjectContainer&gt; providers;
CObjectContainer::New((IObjectContainer**)&amp;providers);
providers-&gt;Add(provider);
...

Boolean hasNext = FALSE;
AutoPtr&lt;IObjectEnumerator&gt; enumerator;
providers-&gt;GetObjectEnumerator((IObjectEnumerator**)&amp;enumerator);
while(enumerator-&gt;MoveNext(&amp;hasNext), hasNext) {
    AutoPtr&lt;IInterface&gt; obj;
    enumerator-&gt;Current((IInterface**)&amp; obj);
    IProviderInfo * info = IProviderInfo::Probe(obj);
    ...
}
</code></pre>

<p><strong>注意：</strong><br />
在上面的<code>while</code>循环中，<code>AutoPtr<IInterface> obj;</code>是声明在<code>while</code>循环体内的，而不是放在<code>while</code>循环体外。要小心 Car 指针变量作为 out 参数在循环中的多次使用，这很容易导致内存泄漏，在循环使用之前需要显式地调用<code>obj = NULL;</code>以清除上一次存储的内容。</p>
</li>
<li>
<p><code>IList，IMap，ICollection，ISet</code>等 Car 容器类是与 Android 中的容器类一一对应的，将来会用这些容器类替代上面提到的<code>IObjectContainer，IObjectInt32Map，IObjectStringMap</code>等容器类。</p>
</li>
</ul>
</li>
</ol>
<p><span id="typecast"></span></p>
<h3 id="_7"><a name="user-content-_7" href="#_7" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>类型转换</h3>
<p><span id="smartptr"></span></p>
<h2 id="_8"><a name="user-content-_8" href="#_8" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>智能指针</h2>
<ol>
<li>
<p><strong>AutoPtr</strong>  <span id="autoptr"></span><br />
    Elastos 中的<code>AutoPtr</code>类似于 STL 中的 shared_ptr 或 Android 中的 sp。</p>
<ul>
<li>
<p>使用<code>AutoPtr</code>作为返回值</p>
<p>通常不推荐返回 C++ 裸指针，因为这需要额外多考察去判断由谁来释放这个 C++ 指针。一般都使用<code>AutoPtr</code>来包装要返回的指针。</p>
<p>示例：</p>
<pre><code>// CSoftKeyboardView.h
AutoPtr&lt;ISoftKeyboard&gt; GetSoftKeyboard();
</code></pre>

<p>在调用返回<code>AutoPtr</code>的函数时，为避免返回指针所指的对象可能被提前释放。统一规定使用<code>AutoPtr</code>来接收返回值。</p>
<p>推荐用法：</p>
<pre><code>// CSoftKeyboardView.cpp
ECode CSoftKeyboardView::GetSoftKeyboard(
    /* [out] */ ISoftKeyboard** keyboard)
{
    VALIDATE_NOT_NULL(keyboard);
    AutoPtr&lt;ISoftKeyboard&gt; temp = SoftKeyboardView::GetSoftKeyboard();
    *keyboard = temp;
    INTERFACE_ADDREF(*keyboard);
    return NOERROR;
}
</code></pre>

<p>不推荐：</p>
<pre><code>ECode CSoftKeyboardView::GetSoftKeyboard(
    /* [out] */ ISoftKeyboard** keyboard)
{
    VALIDATE_NOT_NULL(keyboard);
    *keyboard = SoftKeyboardView::GetSoftKeyboard();
    // return ptr may be released already!
    INTERFACE_ADDREF(*keyboard);
    return NOERROR;
}
</code></pre>

</li>
<li>
<p>在循环中使用<code>AutoPtr</code>作为 out 参数<br />
要小心 Car 指针变量作为 out 参数在循环中的多次使用，这很容易导致内存泄漏，在循环使用之前需要显式地调用<code>obj = NULL;</code> 以清除上一次存储的内容。或将变量的生命周期限定在循环体内。</p>
<p>正确用法：</p>
<pre><code>while (...) {
    AutoPtr&lt;IInterface&gt; obj;
    GetObject((IInterface**)&amp;obj);
...
    }

// or
AutoPtr&lt;IInterface&gt; obj;
while (...) {
    obj = NULL;
    GetObject((IInterface**)&amp;obj);
    ...
}
</code></pre>

<p>错误用法：</p>
<pre><code>// or
AutoPtr&lt;IInterface&gt; obj;
while (...) {
    GetObject((IInterface**)&amp;obj); // memory leak!
    ...
}
</code></pre>

</li>
</ul>
</li>
<li>
<p><strong>弱引用</strong>  <span id="weakreference"></span><br />
    为了避免强引用导致的循环引用，Car 中引入了弱引用（IWeakReference/IWeakReferenceSource）的概念。Car 中的弱引用是基于 ElRefBase 实现的，详细代码情参考<code>elrefbase.h/elrefbase.cpp</code>。</p>
<ul>
<li>
<p>Car 类实现弱引用<br />
    若 Car 类需要实现该功能，请在 sources 编译脚本中添加如下 flag 以开启 Car 编译器自动生成弱引用代码功能。</p>
<pre><code>CAR_FLAGS += -u
LUBE_FLAGS += -n -u
</code></pre>

<p><code>Elastos.Droid.Core/Elastos.Droid.Server</code>已经开启了该功能。</p>
</li>
<li>
<p>C++ 类实现弱引用<br />
    若某个 C++ 类需要提供弱引用功能，那么它需要继承 IWeakReferenceSource 接口，并实现其中的方法：</p>
<pre><code>CARAPI GetWeakReference(
    /* [out] */ IWeakReference** weakReference);
</code></pre>

<p>示例：</p>
<pre><code>// app/LoadedPkg.h
class LoadedPkg
    : public ElRefBase
    , public IWeakReferenceSource
{
public:
    CARAPI GetWeakReference(
    /* [out] */ IWeakReference** weakReference);
};

// app/LoadedPkg.cpp
ECode LoadedPkg::GetWeakReference(
    /* [out] */ IWeakReference** weakReference)
{
    VALIDATE_NOT_NULL(weakReference)
    *weakReference = new WeakReferenceImpl(this, CreateWeak(this));
    INTERFACE_ADDREF(*weakReference)
    return NOERROR;
}

// 使用
AutoPtr&lt;IWeakReference&gt; mWeakRef;
...
// initialize mWeakRef
loadedPkg-&gt;GetWeakReference((IWeakReference**)&amp;mWeakRef);
...

// use mWeakRef
AutoPtr&lt;IInterface&gt; strongObj;
mWeakRef-&gt;Resolve(EIID_IInterface, (IInterface**)&amp;strongObj);
if (strongObj != NULL) {
    // strongObj is still alive!
    LoadedPkg* loadedPkg = (LoadedPkg*)strongObj.Get();
    ...
}
</code></pre>

</li>
</ul>
</li>
</ol>
<p><span id="thread"></span></p>
<h2 id="_9"><a name="user-content-_9" href="#_9" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>多线程</h2>
<ol>
<li>
<p>继承 IThread，IRunnable，IHandler<br />
    IThread，IRunnable，IHandler 都有标准的父类，应该优先通过继承这些父类来实现子类的功能。</p>
<ul>
<li>IThread 的父类为 <code>Elastos::Core::Threading::ThreadBase</code></li>
<li>IRunnable 的父类为 <code>Elastos::Droid::Os::Runnable</code></li>
<li>IHandler  的父类为 <code>Elastos::Droid::Os::HandlerBase</code></li>
<li>此外 <code>Elastos::Droid::Os::HandlerRunableBase</code> 同时实现了 IHandler 与 IRunnable 接口。</li>
</ul>
</li>
<li>
<p>锁<br />
    有两种方式来使用锁：<code>Elastos::Core::Threading::Metux</code>与<code>Elastos::Core::Threading::Object</code>，两者均提供了 Autolock 的便利设施。Object 还具备 Wait/Notify 功能。</p>
</li>
<li>
<p>设置 IMessage 的 obj 参数<br />
    如果需要将自定义数据类型设置为 IMessage 的 obj 参数，那么该参数必须继承自 IInterface，通常我们会通过如下模式的代码来使用：</p>
<pre><code class="cpp">// 参数类型
class SomeArgs
    : public ElRefBase
    , public IInterface
{
public:
    CAR_INTERFACE_DECL()
    ...
};

// 发送消息
AutoPtr&lt;SomeArgs&gt; args = SomeArgs::Obtain();

AutoPtr&lt;IMessage&gt; msg;
mHandler-&gt;ObtainMessageEx(MSG_RESIZED_REPORT, args, (IMessage**)&amp;msg);
Boolean result;
mHandler-&gt;SendMessage(msg, &amp;result);

// 处理消息
AutoPtr&lt;IInterface&gt; obj;
msg-&gt;GetObj((IInterface**)&amp;obj);
...
case ViewRootImpl::MSG_RESIZED_REPORT: {
    AutoPtr&lt;SomeArgs&gt; args = (SomeArgs*)obj.Get();
    ...
    args-&gt;Recycle();
}
</code></pre>

<p><code>Elastos::Droid::Os::SomeArgs</code>是能够存储多个 IInterface/Int32 类型的参数 wrapper 类，并提供了参数池机制，该类已经导出，可以在代码中自由使用。</p>
<p>一些 Wigdet 接口提供了<code>SetTag/GetTag</code>函数，这个 tag 参数的设置也请参照上面 IMessage 的 obj 参数设置示例。</p>
</li>
<li>
<p>syn(this) 的翻译</p>
</li>
</ol>
<p><span id="compile"></span></p>
<h2 id="_10"><a name="user-content-_10" href="#_10" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>编译</h2>
<p><span id="debug"></span></p>
<h2 id="_11"><a name="user-content-_11" href="#_11" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>调试</h2>
<p><span id="crashlocation"></span></p>
<h3 id="crash"><a name="user-content-crash" href="#crash" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>定位 crash</h3>
<p>Elastos 的 eco 支持根据 logcat 中程序 crash 的地址定位到源码中具体的位置。</p>
<p>主要步骤如下:</p>
<ol>
<li>
<p>在需要定位的 eco 的编译目录中的 sources 文件里加入<code>EXPORT_ALL_SYMBOLS = 1</code> (位置最好放到<code>TARGET_TYPE = eco</code>声明后面)。</p>
</li>
<li>
<p>随便修改目录下的某个.cpp文件，或者 touch 一下某个.cpp文件(目的是使得接下来 emake 操作时能重新链接)，然后调用 emake。</p>
</li>
<li>
<p>执行<code>pd @</code>，然后执行<code>elcopy xxx.eco /system/lib/</code>将 eco 拷贝到相应目录下(大多是<code>/system/lib</code>)，然后执行程序。</p>
</li>
<li>
<p>当程序 crash 时，logcat 会 dump 出 crash 进程的信息。其中<code>backtrace:</code>栏目下会打出 crash 时的调用栈如下：</p>
<p><pre><code class="html">backtrace:
I/DEBUG   ( 1218):     #01  pc 013624a4  /system/lib/Elastos.Droid.Core.eco
I/DEBUG   ( 1218):     #02  pc 0134e328  /system/lib/Elastos.Droid.Core.eco
I/DEBUG   ( 1218):     #03  pc 0134e49c  /system/lib/Elastos.Droid.Core.eco
...
</code></pre><br />
其中，013624a4 是出错地址，0134e328 和 0134e49c 是调用者的函数栈展开。</p>
</li>
<li>
<p>取得 crash 地址后，再<code>pd @</code>后的 target 目录下,然后<code>cd debug_info</code>到下面的<code>dbg_info</code>子目录下，然后执行：</p>
<p><pre><code>arm-linux-androideabi-addr2line –e XXX.eco crash-address
</code></pre><br />
就可以定位到源码中出错的具体位置。</p>
<p>比如，针对例子中的地址，执行：</p>
<p><pre><code>arm-linux-androideabi-addr2line -e Elastos.Droid.Core.eco 013624a4
</code></pre><br />
会得到以下结果:</p>
<pre><code>/home/kesalin/ElastosRDK4_2_2/Targets/obj/rdk/arm.gnu.android.dbg/inc/elautoptr.h:112
</code></pre>

</li>
</ol>
<p>方便调试的便利脚本：（感谢饶雪提供）</p>
<ul>
<li>
<p>为了方便将多个地址信息批量转换为源码中的位置信息，饶雪写了一个便利脚本，内容如下：</p>
<pre><code class="shell">#!/bin/bash
cut $1 -d ' ' -f 13-15 &gt; tempx8x9

while read line
do
    echo $line

done &lt; tempx8x9

while read line
do
    #echo $line
    NUM=`echo $line | cut -d ' ' -f 1`
    #echo $NUM
    F=`echo $line | cut -d ' ' -f 2 | cut -d '/' -f 4`
    #echo $F
    arm-linux-androideabi-addr2line -e ~/ElastosRDK4_2_2/Targets/rdk/arm.gnu.android.dbg/bin/dbg_info/$F $NUM

done &lt; tempx8x9
rm tempx8x9
</code></pre>

<p>注意：这个脚本只针对 dbg 版本，如果需要定位 rls 版本则需要修改脚本中的路径。</p>
</li>
<li>
<p>该脚本已经放入<code>ElastosRDK4_2_2/DevDoc/DbgTools/addr2line_dbg.sh</code>中。使用时，进入到 <code>ElastosRDK4_2_2/DevDoc/DbgTools</code>目录下，如果将 crash 信息拷贝到 crashinfo 文档内，其格式如下：</p>
<pre><code>I/DEBUG   ( 1218):     #01  pc 013624a4  /system/lib/Elastos.Droid.Core.eco
I/DEBUG   ( 1218):     #02  pc 0134e328  /system/lib/Elastos.Droid.Core.eco
I/DEBUG   ( 1218):     #03  pc 0134e49c  /system/lib/Elastos.Droid.Core.eco
</code></pre>

<p>然后执行如下命令<code>addr2line_dbg.sh crashinfo</code>，就能得到</p>
<pre><code>~/ElastosRDK4_2_2/DevDoc/DbgTools$./addr2line_dbg.sh crashinfo
013624a4 /system/lib/Elastos.Droid.Core.eco
0134e328 /system/lib/Elastos.Droid.Core.eco
0134e49c /system/lib/Elastos.Droid.Core.eco

/home/kesalin/ElastosRDK4_2_2/Targets/obj/rdk/arm.gnu.android.dbg/inc/elautoptr.h:112
/home/kesalin/ElastosRDK4_2_2/Sources/Elastos/Frameworks/Droid/Base/Core/src/view/CInputDevice.cpp:365
/home/kesalin/ElastosRDK4_2_2/Sources/Elastos/Frameworks/Droid/Base/Core/src/view/CInputDevice.cpp:386
</code></pre>

</li>
</ul>
<p><span id="memleaklocation"></span></p>
<h3 id="_12"><a name="user-content-_12" href="#_12" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>定位内存泄漏</h3>
<ol>
<li>
<p>将如下代码放到需要重复运行以便排查内存泄漏的地方：</p>
<pre><code class="cpp">#include &quot;os/CDebug.h&quot;

using Elastos::Droid::Os::IDebug;
using Elastos::Droid::Os::CDebug;
using Elastos::IO::IFile;
using Elastos::IO::CFile;
using Elastos::IO::IFileDescriptor;
using Elastos::IO::CFileDescriptor;
using Libcore::IO::IOsConstants;
using Libcore::IO::COsConstants;
using Libcore::IO::ILibcore;
using Libcore::IO::CLibcore;
using Libcore::IO::IOs;
using Libcore::IO::IIoBridge;
using Libcore::IO::CIoBridge;

static void MyDumpMemery()
{
    AutoPtr&lt;IOsConstants&gt; osConstans;
    COsConstants::AcquireSingleton((IOsConstants**)&amp;osConstans);
    Int32 m1, m2, m3;
    osConstans-&gt;GetOsConstant(String(&quot;O_RDWR&quot;), &amp;m1);
    osConstans-&gt;GetOsConstant(String(&quot;O_CREAT&quot;), &amp;m2);
    osConstans-&gt;GetOsConstant(String(&quot;O_TRUNC&quot;), &amp;m3);

    AutoPtr&lt;IFile&gt; file;
    CFile::New(String(&quot;/data/debug&quot;), (IFile**)&amp;file);
    Boolean bval;
    file-&gt;Exists(&amp;bval);
    if (!bval) {
        file-&gt;Mkdirs(&amp;bval);
    }

    AutoPtr&lt;IFileDescriptor&gt; ifd;
    CFileDescriptor::New((IFileDescriptor**)&amp;ifd);
    AutoPtr&lt;IIoBridge&gt; ioBridge;
    CIoBridge::AcquireSingleton((IIoBridge**)&amp;ioBridge);
    Int32 fd;
    ioBridge-&gt;Open(String(&quot;/data/debug/1.txt&quot;), m1 | m2 | m3, &amp;fd);
    ifd-&gt;SetDescriptor(fd);

    AutoPtr&lt;IDebug&gt; dbg;
    CDebug::AcquireSingleton((IDebug**)&amp;dbg);
    dbg-&gt;DumpHeap(ifd);
}
</code></pre>

</li>
<li>
<p>进入 shell 环境，赋予 /data/debug 写的权限： chmod 777 /data/debug，然后启用内存调试开关：</p>
<pre><code class="shell">adb shell setprop libc.debug.malloc 1
adb shell stop
adb shell start
</code></pre>

</li>
<li>
<p>杀死要调试的进程，让其自动重启。</p>
</li>
<li>
<p>运行几次目标程序，将当前的内存信息保存下来，</p>
<pre><code class="shell">adb pull /data/debug/1.txt 1.txt
</code></pre>

</li>
<li>
<p>再次运行几次目标程序，将当前的内存信息保存下来</p>
<pre><code class="shell">adb pull /data/debug/1.txt 1.txt
</code></pre>

</li>
<li>
<p>使用文本比较工具，生成内存信息变动情况 diff.txt，将 diff.txt push 到 /data/debug 下。</p>
</li>
<li>
<p>编译 DevSample 下面的 MemoryDummper，将 MemoryDummper push 到 /data /debug 下，运行 shell 命令<code>clear</code>清屏，然后运行<code>./MemoryDummper 要调试的进程 id</code>。</p>
</li>
<li>
<p>将 shell 输出结果拷贝到 result.txt，运行 MemDumpFormatter.exe：<code> MemDumpFormatter result.txt addr2line.txt</code>，分析生成的 addr2line.txt 中的定位。</p>
</li>
</ol>
<p><strong>为了调试方便，针对以上步骤制作了一个脚本: <a href="">loc_memleak</a>, 有以下注意事项</strong></p>
<ol>
<li>脚本可以通过<code>./loc_memleak.sh -h</code> 查看帮助。</li>
<li>使用<code>./loc_memleak.sh -p</code> 开启内存调试开关</li>
<li>一般情况下，使用<code>./loc_memleak.sh -all</code>进行整体运行。在运行过程中，会出现用户交互。<br />
    3.1. <code>Please run the target program, and then start the task(yes or no):</code> 表示执行脚本后，需要运行一个目标程序，然后输入<code>yes</code><br />
    3.2. <code>Please input the target program's NAME(such as: SystemUI PinyinIME):</code> 表示需要输入一个调试进程的名称，目的是获取该进程的id<br />
    3.3. <code>Please run multiple times the target program, and then start the task(yes or no):</code> 再次运行几次目标程序，输入<code>yes</code><br />
    3.4. 脚本会将最后的结果输出到屏幕中，并且保存到一个文件中。</li>
<li>脚本生成的文件：<br />
    4.1. <code>first.txt</code> 为首次运行目标程序生成的内存信息<br />
    4.2. <code>second.txt</code> 为再次运行多次目标程序生成的内存信息<br />
    4.3. <code>diff.txt</code> 为内存信息变动情况的文件<br />
    4.4. <code>logcat.txt</code> 为开发板运行“MemoryDummper”生成的文件, 同时也是“MemDumpFormatter.exe”的输入文件<br />
    4.5. <code>addr2line.txt</code> 为定位文件<br />
    4.6. <code>result.txt</code> 为最终有可能内存泄露的源码位置信息</li>
</ol>
<p><span id="exception"></span></p>
<h2 id="_13"><a name="user-content-_13" href="#_13" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>异常</h2>
<ol>
<li>
<p>关于 exceptions 的定义<br />
    翻译 framework 过程中，若碰到一些还没有在系统中定义的 Java exception，请统一在 ElastosRDK4_2_2/Sources/Elastos/Frameworks/Droid/Base/Core/car/Exceptions.car 中添加。</p>
<p>例如，Droid Content 和 Droid App 模块的分别为 Elastos Content exception codes (Family: 0x50 - 0xD0)和 Elastos App exception codes (Family: 0x51 - 0xD1)。如需添加新的模块编号必须在 ElastosRDK4_2_2/Sources/Elastos/LibCore/car/Exception&amp;ErrorCode.txt 中登记。</p>
</li>
</ol>
<p><span id="others"></span></p>
<h2 id="_14"><a name="user-content-_14" href="#_14" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>其他</h2>
<p><span id="qa"></span></p>
<h2 id="qa"><a name="user-content-qa" href="#qa" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Q/A</h2></article></body></html>