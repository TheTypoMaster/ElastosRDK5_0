
#include "JDBCStatement.h"
#include "CJDBCConnection.h"
#include "CJDBCResultSet.h"
#include <sys/wait.h>

namespace Elastos {
namespace Sql {
namespace SQLite {
namespace JDBC{

JDBCStatement::JDBCStatement()
{
    updcnt = 0;
    maxrows = 0;
    rs = NULL ;
}

JDBCStatement::JDBCStatement(AutoPtr<IJDBCConnection> iconn)
{
    Init(iconn);
}

ECode JDBCStatement::Init(AutoPtr<IJDBCConnection> iconn)
{
    conn = iconn;
    updcnt = 0;
    maxrows = 0;
    rs = NULL ;
    return NOERROR;
}

ECode JDBCStatement::AddBatch(
    /* [in] */ const String& sql)
{
    batch.PushBack(sql);
    return NOERROR;
}

ECode JDBCStatement::Cancel()
{
    if (conn == NULL || ((CJDBCConnection *)&conn)->mDb == NULL) {
        // throw new SQLException("stale connection");
        return  E_UNEXPECTED;
    }
    ((CJDBCConnection *)&conn)->mDb->Interrupt();
    return NOERROR;
}

ECode JDBCStatement::ClearBatch()
{
    if (!batch.IsEmpty()) {
        batch.Clear();
    }
    return NOERROR;
}

ECode JDBCStatement::ClearWarnings()
{
    return NOERROR;
}

ECode JDBCStatement::Close()
{
    ClearBatch();
    conn = NULL;
    return NOERROR;
}

Boolean JDBCStatement::Execute(
    /* [in] */ const String& sql)
{
    return ExecuteQuery(sql) != NULL;
}

Boolean JDBCStatement::Execute(
    /* [in] */ const String& sql,
    /* [in] */ Int32 autoGeneratedKeys)
{
    if (autoGeneratedKeys != Elastos::Sql::IStatement::NO_GENERATED_KEYS) {
        //throw new SQLFeatureNotSupportedException("autogenerated keys not supported");
    }
    return Execute(sql);
}

Boolean JDBCStatement::Execute(
    /* [in] */ const String& sql,
    /* [in] */ const ArrayOf<Int32>& columnIndexes)
{
    // throw new SQLFeatureNotSupportedException();
    return FALSE;
}

Boolean JDBCStatement::Execute(
    /* [in] */ const String& sql,
    /* [in] */ const ArrayOf<String>& columnNames)
{
    // throw new SQLFeatureNotSupportedException();
    return FALSE;
}

AutoPtr<ArrayOf<Int32> > JDBCStatement::ExecuteBatch()
{
    AutoPtr<ArrayOf<Int32> > ret;
    if (batch.IsEmpty()) {
        ret = ArrayOf<Int32>::Alloc(0);
        return ret;
    }
    ret = ArrayOf<Int32>::Alloc(batch.GetSize());
    for (Int32 i = 0; i < ret->GetLength(); i++) {
        (*ret)[i] = Elastos::Sql::IStatement::EXECUTE_FAILED;
    }
    Int32 errs = 0;
    for (Int32 i = 0; i < ret->GetLength(); i++) {
        // try {
        Boolean Exflag = FALSE;
        Exflag = Execute(batch[i]);
        (*ret)[i] = updcnt;
        // } catch (SQLException e) {
        if (!Exflag)
        {
            ++errs;
        }
        // }
    }
    if (errs > 0) {
        // throw new BatchUpdateException("batch failed", ret);
        ret = ArrayOf<Int32>::Alloc(0);
        return ret;
    }
    return ret;
}

AutoPtr<IResultSet> JDBCStatement::ExecuteQuery(
    /* [in] */ const String& sql)
{
    AutoPtr<ArrayOf<String> > args = NULL ;
    return ExecuteQuery(sql, *args, FALSE);
}

AutoPtr<IResultSet> JDBCStatement::ExecuteQuery(
    /* [in] */ const String& sql,
    /* [in] */ const ArrayOf<String>& args,
    /* [in] */ Boolean updonly)
{
   AutoPtr<SQLite::ITableResult> tr;
    if (rs != NULL) {
        ((CJDBCResultSet *)&rs)->Close();
        rs = NULL;
    }
    updcnt = -1;
    if (conn == NULL || ((CJDBCConnection *)&conn)->mDb == NULL) {
        //throw new SQLException("stale connection");
        return  NULL;
    }
    Int32 busy = 0;
    Boolean starttrans = !((CJDBCConnection *)&conn)->mAutocommit && !((CJDBCConnection *)&conn)->mIntrans;
    while (TRUE) {
        // try {
            ECode ecreturn = NOERROR;
            Boolean flagreturn = FALSE;
            if (starttrans) {
                ecreturn = ((CJDBCConnection *)&conn)->mDb->Exec(String("BEGIN TRANSACTION"), NULL);
                if (ecreturn != NOERROR)
                {
                    flagreturn = TRUE;
                }
                ((CJDBCConnection *)&conn)->mIntrans = TRUE;
            }
            if (args.GetLength()) {
                if (updonly) {
                    ecreturn = ((CJDBCConnection *)&conn)->mDb->Exec(sql, NULL);
                    if (ecreturn != NOERROR)
                    {
                        flagreturn = TRUE;
                    }
                } else {
                    ecreturn = ((CJDBCConnection *)&conn)->mDb->GetTable(sql, maxrows,(ITableResult **)&tr);
                    if (ecreturn != NOERROR)
                    {
                        flagreturn = TRUE;
                    }
                }
            }
            else {
                if (updonly) {
                    ecreturn = ((CJDBCConnection *)&conn)->mDb->Exec(sql, NULL, args);
                    if (ecreturn != NOERROR)
                    {
                        flagreturn = TRUE;
                    }
                } else {
                    ecreturn = ((CJDBCConnection *)&conn)->mDb->GetTable(sql, maxrows, args,(ITableResult **)&tr);
                    if (ecreturn != NOERROR)
                    {
                        flagreturn = TRUE;
                    }
                }
            }
            ((CJDBCConnection *)&conn)->mDb->Changes((Int64 *)&updcnt);
        // }
        // catch (SQLite.Exception e) {
            if(flagreturn){
            Int32 lasterr = 0;
            ((CJDBCConnection *)&conn)->mDb->LastError(&lasterr);
            Boolean is3flag = FALSE;
            ((CJDBCConnection *)&conn)->mDb->Is3(&is3flag);
            if (is3flag && lasterr == SQLite::IConstants::SQLITE_BUSY &&
                ((CJDBCConnection *)&conn)->Busy3(((CJDBCConnection *)&conn)->mDb, ++busy)) {
                    // try {
                    if (starttrans && ((CJDBCConnection *)&conn)->mIntrans) {
                        ((CJDBCConnection *)&conn)->mDb->Exec(String("ROLLBACK"), NULL);
                        ((CJDBCConnection *)&conn)->mIntrans = FALSE;
                    }
                    // } catch (SQLite.Exception ee) {
                    // }
                // try {
                Int32 ms = 20 + busy * 10;
                if (ms > 1000) {
                    ms = 1000;
                }
                Mutex::Autolock lock(mSyncLock);
                wait(&ms);
                // }
                // catch (java.lang.Exception eee) {
                // }
                continue;
            }
            // throw new SQLException(e.toString());
        // }
        }
        break;
    }
    if (!updonly && tr == NULL) {
        //throw new SQLException("no result set produced");
        return NULL;
    }
    if (!updonly && tr != NULL) {
        CJDBCResultSet::New(tr, (IJDBCStatement *)this->Probe(),(IJDBCResultSet **)&rs);
    }
    return (IResultSet *)rs.Get();
}

Int32 JDBCStatement::ExecuteUpdate(
    /* [in] */ const String& sql)
{
    AutoPtr<ArrayOf<String> > args = NULL ;
    ExecuteQuery(sql, *args, TRUE);
    return updcnt;
}

Int32 JDBCStatement::ExecuteUpdate(
    /* [in] */ const String& sql,
    /* [in] */ Int32 autoGeneratedKeys)
{
    if (autoGeneratedKeys != Elastos::Sql::IStatement::NO_GENERATED_KEYS) {
        // throw new SQLFeatureNotSupportedException("generated keys not supported");
    }
    return ExecuteUpdate(sql);
}

Int32 JDBCStatement::ExecuteUpdate(
    /* [in] */ const String& sql,
    /* [in] */ const ArrayOf<Int32>& columnIndexes)
{
    // throw new SQLFeatureNotSupportedException();
    return 0;
}

Int32 JDBCStatement::ExecuteUpdate(
    /* [in] */ const String& sql,
    /* [in] */ const ArrayOf<String>& columnNames)
{
    // throw new SQLFeatureNotSupportedException();
    return 0;
}

AutoPtr<IConnection> JDBCStatement::GetConnection()
{
    return (IConnection *)conn.Get();
}

Int32 JDBCStatement::GetFetchDirection()
{
    return IResultSet::FETCH_UNKNOWN;
}

Int32 JDBCStatement::GetFetchSize()
{
    return 1;
}

AutoPtr<IResultSet> JDBCStatement::GetGeneratedKeys()
{
    // throw new SQLFeatureNotSupportedException();
    return NULL;
}

Int32 JDBCStatement::GetMaxFieldSize()
{
    return 0;
}

Int32 JDBCStatement::GetMaxRows()
{
    return maxrows;
}

Boolean JDBCStatement::GetMoreResults()
{
    // throw new SQLFeatureNotSupportedException();
    return FALSE;
}

Boolean JDBCStatement::GetMoreResults(
    /* [in] */ Int32 current)
{
    if (rs != NULL) {
        ((CJDBCResultSet *)&rs)->Close();
        rs = NULL;
    }
    return FALSE;
}

Int32 JDBCStatement::GetQueryTimeout()
{
    return ((CJDBCConnection *)&conn)->timeout/1000; // android-changed: should return seconds
}

AutoPtr<IResultSet> JDBCStatement::GetResultSet()
{
    return (IResultSet *)rs.Get();
}

Int32 JDBCStatement::GetResultSetConcurrency()
{
    return IResultSet::CONCUR_READ_ONLY;
}

Int32 JDBCStatement::GetResultSetHoldability()
{
    return Elastos::Sql::IResultSet::HOLD_CURSORS_OVER_COMMIT;
}

Int32 JDBCStatement::GetResultSetType()
{
    return IResultSet::TYPE_SCROLL_INSENSITIVE;
}

Int32 JDBCStatement::GetUpdateCount()
{
    return updcnt;
}

AutoPtr<ISQLWarning> JDBCStatement::GetWarnings()
{
    return NULL;
}

ECode JDBCStatement::SetCursorName(
    /* [in] */ const String& name)
{
    //throw new SQLFeatureNotSupportedException();
    return NOERROR;
}

ECode JDBCStatement::SetEscapeProcessing(
    /* [in] */ Boolean isable)
{
    // throw new SQLException("not supported");
    return NOERROR;
}

ECode JDBCStatement::SetFetchDirection(
    /* [in] */ Int32 direction)
{
    // throw new SQLException("not supported");
    return NOERROR;
}

ECode JDBCStatement::SetFetchSize(
    /* [in] */ Int32 fetchSize)
{
    if (fetchSize != 1) {
        //throw new SQLException("fetch size not 1");
    }
    return NOERROR;
}

ECode JDBCStatement::SetMaxFieldSize(
    /* [in] */ Int32 max)
{
    // throw new SQLException("not supported");
    return NOERROR;
}

ECode JDBCStatement::SetMaxRows(
    /* [in] */ Int32 max)
{
    if (max < 0) {
        //throw new SQLException("max must be >= 0 (was " + max + ")");
        return  E_UNEXPECTED;
    }
    maxrows = max;
    return NOERROR;
}

ECode JDBCStatement::SetQueryTimeout(
    /* [in] */ Int32 seconds)
{
    // BEGIN android-changed: more closely follow specification:
    // "[throws SQLException if] this method is called on a closed Statement or the condition
    // seconds >= 0 is not satisfied"
    // (http://java.sun.com/javase/6/docs/api/java/sql/Statement.html#setQueryTimeout(int))
    if (IsClosed()) {
        //throw new SQLException("can't set a query timeout on a closed statement");'
        return  E_UNEXPECTED;
    } else if (seconds < 0) {
        //throw new SQLException("can't set a query timeout of less than 0 seconds");
        return  E_UNEXPECTED;
    } else if (seconds == 0) {
        // An argument of 0 seconds should set an unlimited timeout. However, since this was not
        // done previously, I assume it isn't implemented and use the same implementation.
        ((CJDBCConnection *)&conn)->timeout = 5000;
    } else {
        ((CJDBCConnection *)&conn)->timeout = seconds * 1000;
    }
    // END android-changed
    return NOERROR;
}

Boolean JDBCStatement::IsClosed()
{
    return conn == NULL; // android-changed: pretty sure this is correct, since it matches what's done in close()
}

ECode JDBCStatement::SetPoolable(
    /* [in] */ Boolean poolable)
{
    if (poolable) {
        // throw new SQLException("poolable statements not supported");
    }
    return NOERROR;
}

Boolean JDBCStatement::IsPoolable()
{
    return FALSE;
}

Boolean JDBCStatement::IsWrapperFor(AutoPtr<IInterface> iface)
{
    return FALSE;
}

PInterface JDBCStatement::Probe()
{
    return NULL;
}

PInterface JDBCStatement::Unwrap(
    /* [in] */ PInterface iface)
{
    return NULL;
}

} // namespace JDBC
} // namespace SQLite
} // namespace Sql
} // namespace Elastos
