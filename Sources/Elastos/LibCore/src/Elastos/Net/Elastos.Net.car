
module
{
    merge("../../../car/Elastos/Net/Exceptions.car");
    merge("../../../car/Elastos/Net/IAuthenticator.car");
    merge("../../../car/Elastos/Net/ICacheRequest.car");
    merge("../../../car/Elastos/Net/ICacheResponse.car");
    merge("../../../car/Elastos/Net/IContentHandler.car");
    merge("../../../car/Elastos/Net/IContentHandlerFactory.car");
    merge("../../../car/Elastos/Net/ICookieHandler.car");
    merge("../../../car/Elastos/Net/IURLStreamHandler.car");
    merge("../../../car/Elastos/Net/IURLStreamHandlerFactory.car");
    merge("../../../car/Elastos/Net/IURI.car");
    merge("../../../car/Elastos/Net/IURL.car");
    merge("../../../car/Elastos/Net/ICookieManager.car");
    merge("../../../car/Elastos/Net/ICookiePolicy.car");
    merge("../../../car/Elastos/Net/ICookieStore.car");
    merge("../../../car/Elastos/Net/IDatagramPacket.car");
    merge("../../../car/Elastos/Net/IDatagramSocket.car");
    merge("../../../car/Elastos/Net/ISocketOptions.car");
    merge("../../../car/Elastos/Net/IDatagramSocketImpl.car");
    merge("../../../car/Elastos/Net/IDatagramSocketImplFactory.car");
    merge("../../../car/Elastos/Net/IResponseCache.car");
    merge("../../../car/Elastos/Net/IURLConnection.car");
    merge("../../../car/Elastos/Net/IHttpURLConnection.car");
    merge("../../../car/Elastos/Net/IExtendedResponseCache.car");
    merge("../../../car/Elastos/Net/IFileNameMap.car");
    merge("../../../car/Elastos/Net/IMimeUtils.car");
    merge("../../../car/Elastos/Net/IHttpCookie.car");
    merge("../../../car/Elastos/Net/IIDN.car");
    merge("../../../car/Elastos/Net/IInetAddress.car");
    merge("../../../car/Elastos/Net/IInet4Address.car");
    merge("../../../car/Elastos/Net/IInet6Address.car");
    merge("../../../car/Elastos/Net/ISocketAddress.car");
    merge("../../../car/Elastos/Net/IInetSocketAddress.car");
    merge("../../../car/Elastos/Net/IInterfaceAddress.car");
    merge("../../../car/Elastos/Net/IMulticastSocket.car");
    merge("../../../car/Elastos/Net/INetworkInterface.car");
    merge("../../../car/Elastos/Net/IPasswordAuthentication.car");
    merge("../../../car/Elastos/Net/IPlainDatagramSocketImpl.car");
    merge("../../../car/Elastos/Net/ISocketImpl.car");
    merge("../../../car/Elastos/Net/IPlainSocketImpl.car");
    merge("../../../car/Elastos/Net/IPlainServerSocketImpl.car");
    merge("../../../car/Elastos/Net/IProxy.car");
    merge("../../../car/Elastos/Net/IProxySelector.car");
    merge("../../../car/Elastos/Net/ISecureCacheResponse.car");
    merge("../../../car/Elastos/Net/IServerSocket.car");
    merge("../../../car/Elastos/Net/ISocket.car");
    merge("../../../car/Elastos/Net/ISocketImplFactory.car");
    merge("../../../car/Elastos/Net/ISocketInputStream.car");
    merge("../../../car/Elastos/Net/ISocketOutputStream.car");
    merge("../../../car/Elastos/Net/ISocks4Message.car");
    merge("../../../car/Elastos/Net/IURLEncoder.car");
    merge("../../../car/Elastos/Net/IURLDecoder.car");
    merge("../../../car/Elastos/Net/IUriCodecHelper.car");
    merge("../../../car/Elastos/Net/NotUsed.car");
    merge("../../../car/Elastos/Net/IRawSocket.car");
    merge("../../../car/Elastos/Net/IJarURLConnection.car");
    merge("../../../car/Elastos/Net/INetPermission.car");

    merge("../../../car/Elastos/Net/Http/IAbstractHttpInputStream.car");
    merge("../../../car/Elastos/Net/Http/IAbstractHttpOutputStream.car");
    merge("../../../car/Elastos/Net/Http/IChallenge.car");
    merge("../../../car/Elastos/Net/Http/IChunkedInputStream.car");
    merge("../../../car/Elastos/Net/Http/IChunkedOutputStream.car");
    merge("../../../car/Elastos/Net/Http/IFixedLengthInputStream.car");
    merge("../../../car/Elastos/Net/Http/IFixedLengthOutputStream.car");
    merge("../../../car/Elastos/Net/Http/IRawHeaders.car");
    merge("../../../car/Elastos/Net/Http/IHeaderParser.car");
    merge("../../../car/Elastos/Net/Http/IHttpConnection.car");
    merge("../../../car/Elastos/Net/Http/IHttpConnectionPool.car");
    merge("../../../car/Elastos/Net/Http/IHttpDate.car");
    merge("../../../car/Elastos/Net/Http/IResponseHeaders.car");
    merge("../../../car/Elastos/Net/Http/IRequestHeaders.car");
    merge("../../../car/Elastos/Net/Http/IHttpHandler.car");
    merge("../../../car/Elastos/Net/Http/IHttpResponseCache.car");
    merge("../../../car/Elastos/Net/Http/IHttpsHandler.car");
    merge("../../../car/Elastos/Net/Http/IHttpEngine.car");
    merge("../../../car/Elastos/Net/Http/IHttpURLConnectionImpl.car");
    merge("../../../car/Elastos/Net/Http/IRetryableOutputStream.car");
    merge("../../../car/Elastos/Net/Http/IUnknownLengthHttpInputStream.car");

    merge("../../../car/Elastos/Net/Url/IFileHandler.car");
    merge("../../../car/Elastos/Net/Url/IFileURLConnection.car");
    merge("../../../car/Elastos/Net/Url/IFtpHandler.car");
    merge("../../../car/Elastos/Net/Url/IFtpURLConnection.car");
    merge("../../../car/Elastos/Net/Url/IFtpURLInputStream.car");
    merge("../../../car/Elastos/Net/Url/IJarHandler.car");
    merge("../../../car/Elastos/Net/Url/IJarURLConnectionImpl.car");
    merge("../../../car/Elastos/Net/Url/IUrlUtils.car");

    merge("../../../car/Elastosx/Net/ISocketFactory.car");
    merge("../../../car/Elastosx/Net/IServerSocketFactory.car");

    merge("../../../car/Elastosx/Net/Ssl/IKeyManager.car");
    merge("../../../car/Elastosx/Net/Ssl/IManagerFactoryParameters.car");
    merge("../../../car/Elastosx/Net/Ssl/ITrustManager.car");
    merge("../../../car/Elastosx/Net/Ssl/ISSLSession.car");
    merge("../../../car/Elastosx/Net/Ssl/ISSLSessionContext.car");
    merge("../../../car/Elastosx/Net/Ssl/ISSLEngineResult.car");
    merge("../../../car/Elastosx/Net/Ssl/ISSLEngine.car");
    merge("../../../car/Elastosx/Net/Ssl/ISSLParameters.car");
    merge("../../../car/Elastosx/Net/Ssl/IHandshakeCompletedListener.car");
    merge("../../../car/Elastosx/Net/Ssl/IHandshakeCompletedEvent.car");
    merge("../../../car/Elastosx/Net/Ssl/ISSLSocket.car");
    merge("../../../car/Elastosx/Net/Ssl/IX509TrustManager.car");
    merge("../../../car/Elastosx/Net/Ssl/ISSLContextSpi.car");
    merge("../../../car/Elastosx/Net/Ssl/ISSLSocketFactory.car");
    merge("../../../car/Elastosx/Net/Ssl/ISSLServerSocketFactory.car");
    merge("../../../car/Elastosx/Net/Ssl/IX509KeyManager.car");
    merge("../../../car/Elastosx/Net/Ssl/IX509ExtendedKeyManager.car");
    merge("../../../car/Elastosx/Net/Ssl/IKeyManagerFactorySpi.car");
    merge("../../../car/Elastosx/Net/Ssl/ISSLServerSocket.car");
    merge("../../../car/Elastosx/Net/Ssl/ITrustManagerFactorySpi.car");

    // using interface Elastos.IO.IFileDescriptor;
    // using interface Elastos.IO.IInputStream;
    // using interface Elastos.IO.IOutputStream;
    // using interface Elastos.IO.IFile;
    // using interface Elastos.IO.IFlushable;
    // using interface Elastos.Net.ICacheRequest;
    // using interface Elastos.Net.IExtendedResponseCache;
    // using interface Elastos.Net.IURI;

    // namespace Elastos {
    // namespace Net {

    // class CCookieManager {
    //     /**
    //      * Constructs a new cookie manager.
    //      *
    //      * The invocation of this constructor is the same as the invocation of
    //      * CookieManager(null, null).
    //      *
    //      */
    //     constructor();

    //     /**
    //      * Constructs a new cookie manager using a specified cookie store and a
    //      * cookie policy.
    //      *
    //      * @param store
    //      *            a CookieStore to be used by cookie manager. The manager will
    //      *            use a default one if the arg is null.
    //      * @param cookiePolicy
    //      *            a CookiePolicy to be used by cookie manager
    //      *            ACCEPT_ORIGINAL_SERVER will be used if the arg is null.
    //      */
    //     constructor(
    //         [in] ICookieStore* store,
    //         [in] ICookiePolicy* cookiePolicy);

    //     interface ICookieManager;
    // }

    // singleton class CCookiePolicyHelper {
    //     interface ICookiePolicyHelper;
    // }

    // [deprecated]
    // class CDatagramPacket {
    //     /**
    //      * Constructs a new {@code DatagramPacket} object to receive data up to
    //      * {@code length} bytes.
    //      *
    //      * @param data
    //      *            a byte array to store the read characters.
    //      * @param length
    //      *            the length of the data buffer.
    //      */
    //     constructor(
    //         [in] ArrayOf<Byte>* data,
    //         [in] Int32 length);

    //     /**
    //      * Constructs a new {@code DatagramPacket} object to receive data up to
    //      * {@code length} bytes with a specified buffer offset.
    //      *
    //      * @param data
    //      *            a byte array to store the read characters.
    //      * @param offset
    //      *            the offset of the byte array where the bytes is written.
    //      * @param length
    //      *            the length of the data.
    //      */
    //     constructor(
    //         [in] ArrayOf<Byte>* data,
    //         [in] Int32 offset,
    //         [in] Int32 length);

    //     /**
    //      * Constructs a new {@code DatagramPacket} object to send data to the port
    //      * {@code aPort} of the address {@code host}. The {@code length} must be
    //      * lesser than or equal to the size of {@code data}. The first {@code
    //      * length} bytes from the byte array position {@code offset} are sent.
    //      *
    //      * @param data
    //      *            a byte array which stores the characters to be sent.
    //      * @param offset
    //      *            the offset of {@code data} where to read from.
    //      * @param length
    //      *            the length of data.
    //      * @param host
    //      *            the address of the target host.
    //      * @param aPort
    //      *            the port of the target host.
    //      */
    //     constructor(
    //         [in] ArrayOf<Byte>* data,
    //         [in] Int32 offset,
    //         [in] Int32 length,
    //         [in] IInetAddress* host,
    //         [in] Int32 aPort);

    //     /**
    //      * Constructs a new {@code DatagramPacket} object to send data to the port
    //      * {@code aPort} of the address {@code host}. The {@code length} must be
    //      * lesser than or equal to the size of {@code data}. The first {@code
    //      * length} bytes are sent.
    //      *
    //      * @param data
    //      *            a byte array which stores the characters to be sent.
    //      * @param length
    //      *            the length of data.
    //      * @param host
    //      *            the address of the target host.
    //      * @param port
    //      *            the port of the target host.
    //      */
    //     constructor(
    //         [in] ArrayOf<Byte>* data,
    //         [in] Int32 length,
    //         [in] IInetAddress* host,
    //         [in] Int32 port);

    //     /**
    //      * Constructs a new {@code DatagramPacket} object to send data to the
    //      * address {@code sockAddr}. The {@code length} must be lesser than or equal
    //      * to the size of {@code data}. The first {@code length} bytes of the data
    //      * are sent.
    //      *
    //      * @param data
    //      *            the byte array to store the data.
    //      * @param length
    //      *            the length of the data.
    //      * @param sockAddr
    //      *            the target host address and port.
    //      * @throws SocketException
    //      *             if an error in the underlying protocol occurs.
    //      */
    //     constructor(
    //         [in] ArrayOf<Byte>* data,
    //         [in] Int32 length,
    //         [in] ISocketAddress* sockAddr);

    //     /**
    //      * Constructs a new {@code DatagramPacket} object to send data to the
    //      * address {@code sockAddr}. The {@code length} must be lesser than or equal
    //      * to the size of {@code data}. The first {@code length} bytes of the data
    //      * are sent.
    //      *
    //      * @param data
    //      *            the byte array to store the data.
    //      * @param offset
    //      *            the offset of the data.
    //      * @param length
    //      *            the length of the data.
    //      * @param sockAddr
    //      *            the target host address and port.
    //      * @throws SocketException
    //      *             if an error in the underlying protocol occurs.
    //      */
    //     constructor(
    //         [in] ArrayOf<Byte>* data,
    //         [in] Int32 offset,
    //         [in] Int32 length,
    //         [in] ISocketAddress* sockAddr);

    //     interface IDatagramPacket;
    // }

    // class CDatagramSocket {
    //     /**
    //      * Constructs a UDP datagram socket which is bound to any available port on
    //      * the localhost.
    //      *
    //      * @throws SocketException
    //      *             if an error occurs while creating or binding the socket.
    //      */
    //     constructor();

    //     /**
    //      * Constructs a UDP datagram socket which is bound to the specific port
    //      * {@code aPort} on the localhost. Valid values for {@code aPort} are
    //      * between 0 and 65535 inclusive.
    //      *
    //      * @param aPort
    //      *            the port to bind on the localhost.
    //      * @throws SocketException
    //      *             if an error occurs while creating or binding the socket.
    //      */
    //     constructor(
    //         [in] Int32 aPort);

    //     /**
    //      * Constructs a UDP datagram socket which is bound to the specific local
    //      * address {@code addr} on port {@code aPort}. Valid values for {@code
    //      * aPort} are between 0 and 65535 inclusive.
    //      *
    //      * @param aPort
    //      *            the port to bind on the localhost.
    //      * @param addr
    //      *            the address to bind on the localhost.
    //      * @throws SocketException
    //      *             if an error occurs while creating or binding the socket.
    //      */
    //     constructor(
    //         [in] Int32 aport,
    //         [in] IInetAddress* addr);

    //     /**
    //      * Constructs a new {@code DatagramSocket} bound to the host/port specified
    //      * by the {@code SocketAddress} {@code localAddr} or an unbound {@code
    //      * DatagramSocket} if the {@code SocketAddress} is {@code null}.
    //      *
    //      * @param localAddr
    //      *            the local machine address and port to bind to.
    //      * @throws IllegalArgumentException
    //      *             if the SocketAddress is not supported
    //      * @throws SocketException
    //      *             if a problem occurs creating or binding the socket.
    //      */
    //     constructor(
    //         [in] ISocketAddress* localAddr);

    //     interface IDatagramSocket;
    // }

    // /**
    //  * This class implements a UDP socket for sending and receiving {@code
    //  * DatagramPacket}. A {@code DatagramSocket} object can be used for both
    //  * endpoints of a connection for a packet delivery service.
    //  *
    //  * @see DatagramPacket
    //  * @see DatagramSocketImplFactory
    //  */

    // /**
    //  * This class represents a datagram packet which contains data either to be sent
    //  * or received through a {@code DatagramSocket}. It holds additional information
    //  * such as its source or destination host.
    //  *
    //  * @see DatagramSocket
    //  */

    // /**
    //  * An opaque key-value value pair held by an HTTP client to permit a stateful
    //  * session with an HTTP server. This class parses cookie headers for all three
    //  * commonly used HTTP cookie specifications:
    //  *
    //  * <ul>
    //  *     <li>The Netscape cookie spec is officially obsolete but widely used in
    //  *         practice. Each cookie contains one key-value pair and the following
    //  *         attributes: {@code Domain}, {@code Expires}, {@code Path}, and
    //  *         {@code Secure}. The {@link #getVersion() version} of cookies in this
    //  *         format is {@code 0}.
    //  *         <p>There are no accessors for the {@code Expires} attribute. When
    //  *         parsed, expires attributes are assigned to the {@link #getMaxAge()
    //  *         Max-Age} attribute as an offset from {@link System#currentTimeMillis()
    //  *         now}.
    //  *     <li><a href="http://www.ietf.org/rfc/rfc2109.txt">RFC 2109</a> formalizes
    //  *         the Netscape cookie spec. It replaces the {@code Expires} timestamp
    //  *         with a {@code Max-Age} duration and adds {@code Comment} and {@code
    //  *         Version} attributes. The {@link #getVersion() version} of cookies in
    //  *         this format is {@code 1}.
    //  *     <li><a href="http://www.ietf.org/rfc/rfc2965.txt">RFC 2965</a> refines
    //  *         RFC 2109. It adds {@code Discard}, {@code Port}, and {@code
    //  *         CommentURL} attributes and renames the header from {@code Set-Cookie}
    //  *         to {@code Set-Cookie2}. The {@link #getVersion() version} of cookies
    //  *         in this format is {@code 1}.
    //  * </ul>
    //  *
    //  * <p>This implementation silently discards unrecognized attributes. In
    //  * particular, the {@code HttpOnly} attribute is widely served but isn't in any
    //  * of the above specs. It was introduced by Internet Explorer to prevent server
    //  * cookies from being exposed in the DOM to JavaScript, etc.
    //  *
    //  * @since 1.6
    //  */

    // class CHttpCookie {
    //     /**
    //      * Creates a new cookie.
    //      *
    //      * @param name a non-empty string that contains only printable ASCII, no
    //      *     commas or semicolons, and is not prefixed with  {@code $}. May not be
    //      *     an HTTP attribute name.
    //      * @param value an opaque value from the HTTP server.
    //      * @throws IllegalArgumentException if {@code name} is invalid.
    //      */
    //     constructor(
    //         [in] String name,
    //         [in] String value);

    //     interface IHttpCookie;
    // }

    // singleton class CInetAddressHelper {
    //     interface IInetAddressHelper;
    // }

    // [deprecated]
    // class CInet4Address {

    //     constructor(
    //         [in] ArrayOf<Byte>* address,
    //         [in] String name);

    //     interface IInet4Address;
    // }

    // singleton class CInet4AddressHelper {
    //     interface IInet4AddressHelper;
    // }

    // [deprecated]
    // class CInet6Address {

    //     /**
    //      * Constructs an {@code InetAddress} representing the {@code address} and
    //      * {@code name} and {@code scope_id}.
    //      *
    //      * @param address
    //      *            the network address.
    //      * @param name
    //      *            the name associated with the address.
    //      * @param scope_id
    //      *            the scope id for link- or site-local addresses.
    //      */
    //     constructor(
    //         [in] ArrayOf<Byte>* address,
    //         [in] String name,
    //         [in] Int32 scopeId);

    //     interface IInet6Address;
    // }

    // singleton class CInet6AddressHelper {
    //     interface IInet6AddressHelper;
    // }

    //  class CInetSocketAddress {
    //     /**
    //      * @hide internal use only
    //      */
    //     constructor();

    //     /**
    //      * Creates a socket endpoint with the given port number {@code port} and
    //      * no specified address. The range for valid port numbers is between 0 and
    //      * 65535 inclusive.
    //      *
    //      * @param port
    //      *            the specified port number to which this socket is bound.
    //      */
    //     constructor(
    //         [in] Int32 port);

    //     /**
    //      * Creates a socket endpoint with the given port number {@code port} and
    //      * {@code address}. The range for valid port numbers is between 0 and 65535
    //      * inclusive. If {@code address} is {@code null} this socket is bound to the
    //      * IPv4 wildcard address.
    //      *
    //      * @param port
    //      *            the specified port number to which this socket is bound.
    //      * @param address
    //      *            the specified address to which this socket is bound.
    //      */
    //     constructor(
    //         [in] IInetAddress* address,
    //         [in] Int32 port);

    //     /**
    //      * Creates a socket endpoint with the given port number {@code port} and the
    //      * hostname {@code host}. The hostname is tried to be resolved and cannot be
    //      * {@code null}. The range for valid port numbers is between 0 and 65535
    //      * inclusive.
    //      *
    //      * @param port
    //      *            the specified port number to which this socket is bound.
    //      * @param host
    //      *            the specified hostname to which this socket is bound.
    //      * @throws SecurityException
    //      *             if a {@link SecurityManager} is installed and its {@code
    //      *             checkConnect()} method does not allow the resolving of the
    //      *             host name.
    //      */
    //     constructor(
    //         [in] String host,
    //         [in] Int32 port);

    //     /*
    //      * Internal constructor for InetSocketAddress(String, int) and
    //      * createUnresolved(String, int);
    //      */
    //     constructor(
    //         [in] String hostname,
    //         [in] Int32 port,
    //         [in] Boolean needResolved);

    //     interface IInetSocketAddress;
    // }

    // singleton class CInetSocketAddressHelper
    // {
    //     interface IInetSocketAddressHelper;
    // }

    // class CPasswordAuthentication {
    //     /**
    //      * Creates an instance of a password authentication with a specified
    //      * username and password.
    //      *
    //      * @param userName
    //      *            the username to store.
    //      * @param password
    //      *            the associated password to store.
    //      */
    //     constructor(
    //         [in] String userName,
    //         [in] ArrayOf<Char32> password);

    //     interface IPasswordAuthentication;
    // }

    // class CProxy {
    //     /**
    //      * Creates a new {@code Proxy} instance. {@code SocketAddress} must NOT be
    //      * {@code null} when {@code type} is either {@code Proxy.Type.HTTP} or
    //      * {@code Proxy.Type.SOCKS}. To create a {@code Proxy} instance representing
    //      * the proxy type {@code Proxy.Type.DIRECT}, use {@code Proxy.NO_PROXY}
    //      * instead of this constructor.
    //      *
    //      * @param type
    //      *            the proxy type of this instance.
    //      * @param sa
    //      *            the proxy address of this instance.
    //      * @throws IllegalArgumentException
    //      *             if the parameter {@code type} is set to {@code
    //      *             Proxy.Type.DIRECT} or the value for {@code SocketAddress} is
    //      *             {@code null}.
    //      */
    //     constructor(
    //         [in] ProxyType type,
    //         [in] ISocketAddress* sa);

    //     /*
    //      * Constructs a Proxy instance, which is Proxy.DIRECT type with null
    //      * SocketAddress. This constructor is used for NO_PROXY.
    //      */
    //     constructor();

    //     interface IProxy;
    // }

    // class CURI {
    //     /* private */
    //     constructor();

    //     /**
    //      * Creates a new URI instance according to the given string {@code uri}.
    //      *
    //      * @param uri
    //      *            the textual URI representation to be parsed into a URI object.
    //      * @throws URISyntaxException
    //      *             if the given string {@code uri} doesn't fit to the
    //      *             specification RFC2396 or could not be parsed correctly.
    //      */
    //     constructor(
    //         [in] String uri);

    //     *
    //      * Creates a new URI instance using the given arguments. This constructor
    //      * first creates a temporary URI string from the given components. This
    //      * string will be parsed later on to create the URI instance.
    //      * <p>
    //      * {@code [scheme:]scheme-specific-part[#fragment]}
    //      *
    //      * @param scheme
    //      *            the scheme part of the URI.
    //      * @param ssp
    //      *            the scheme-specific-part of the URI.
    //      * @param frag
    //      *            the fragment part of the URI.
    //      * @throws URISyntaxException
    //      *             if the temporary created string doesn't fit to the
    //      *             specification RFC2396 or could not be parsed correctly.

    //     constructor(
    //         [in] String scheme,
    //         [in] String ssp,
    //         [in] String frag);

    //     /**
    //      * Creates a new URI instance using the given arguments. This constructor
    //      * first creates a temporary URI string from the given components. This
    //      * string will be parsed later on to create the URI instance.
    //      * <p>
    //      * {@code [scheme:][user-info@]host[:port][path][?query][#fragment]}
    //      *
    //      * @param scheme
    //      *            the scheme part of the URI.
    //      * @param userInfo
    //      *            the user information of the URI for authentication and
    //      *            authorization.
    //      * @param host
    //      *            the host name of the URI.
    //      * @param port
    //      *            the port number of the URI.
    //      * @param path
    //      *            the path to the resource on the host.
    //      * @param query
    //      *            the query part of the URI to specify parameters for the
    //      *            resource.
    //      * @param fragment
    //      *            the fragment part of the URI.
    //      * @throws URISyntaxException
    //      *             if the temporary created string doesn't fit to the
    //      *             specification RFC2396 or could not be parsed correctly.
    //      */
    //     constructor(
    //         [in] String scheme,
    //         [in] String userInfo,
    //         [in] String host,
    //         [in] Int32 port,
    //         [in] String path,
    //         [in] String query,
    //         [in] String fragment);

    //     /**
    //      * Creates a new URI instance using the given arguments. This constructor
    //      * first creates a temporary URI string from the given components. This
    //      * string will be parsed later on to create the URI instance.
    //      * <p>
    //      * {@code [scheme:]host[path][#fragment]}
    //      *
    //      * @param scheme
    //      *            the scheme part of the URI.
    //      * @param host
    //      *            the host name of the URI.
    //      * @param path
    //      *            the path to the resource on the host.
    //      * @param fragment
    //      *            the fragment part of the URI.
    //      * @throws URISyntaxException
    //      *             if the temporary created string doesn't fit to the
    //      *             specification RFC2396 or could not be parsed correctly.
    //      */
    //     constructor(
    //         [in] String scheme,
    //         [in] String host,
    //         [in] String path,
    //         [in] String fragment);

    //     /**
    //      * Creates a new URI instance using the given arguments. This constructor
    //      * first creates a temporary URI string from the given components. This
    //      * string will be parsed later on to create the URI instance.
    //      * <p>
    //      * {@code [scheme:][//authority][path][?query][#fragment]}
    //      *
    //      * @param scheme
    //      *            the scheme part of the URI.
    //      * @param authority
    //      *            the authority part of the URI.
    //      * @param path
    //      *            the path to the resource on the host.
    //      * @param query
    //      *            the query part of the URI to specify parameters for the
    //      *            resource.
    //      * @param fragment
    //      *            the fragment part of the URI.
    //      * @throws URISyntaxException
    //      *             if the temporary created string doesn't fit to the
    //      *             specification RFC2396 or could not be parsed correctly.
    //      */
    //     constructor(
    //         [in] String scheme,
    //         [in] String authority,
    //         [in] String path,
    //         [in] String query,
    //         [in] String fragment);

    //     interface IURI;
    // }

    // class CURL {
    //     /**
    //      * Creates a new URL instance by parsing the string {@code spec}.
    //      *
    //      * @param spec
    //      *            the URL string representation which has to be parsed.
    //      * @throws MalformedURLException
    //      *             if the given string {@code spec} could not be parsed as a
    //      *             URL.
    //      */
    //     constructor(
    //         [in] String spec);

    //     /**
    //      * Creates a new URL to the specified resource {@code spec}. This URL is
    //      * relative to the given {@code context}. If the protocol of the parsed URL
    //      * does not match with the protocol of the context URL, then the newly
    //      * created URL is absolute and bases only on the given URL represented by
    //      * {@code spec}. Otherwise the protocol is defined by the context URL.
    //      *
    //      * @param context
    //      *            the URL which is used as the context.
    //      * @param spec
    //      *            the URL string representation which has to be parsed.
    //      * @throws MalformedURLException
    //      *             if the given string {@code spec} could not be parsed as a URL
    //      *             or an invalid protocol has been found.
    //      */
    //     constructor(
    //         [in] IURL* context,
    //         [in] String spec);

    //     /**
    //      * Creates a new URL to the specified resource {@code spec}. This URL is
    //      * relative to the given {@code context}. The {@code handler} will be used
    //      * to parse the URL string representation. If this argument is {@code null}
    //      * the default {@code URLStreamHandler} will be used. If the protocol of the
    //      * parsed URL does not match with the protocol of the context URL, then the
    //      * newly created URL is absolute and bases only on the given URL represented
    //      * by {@code spec}. Otherwise the protocol is defined by the context URL.
    //      *
    //      * @param context
    //      *            the URL which is used as the context.
    //      * @param spec
    //      *            the URL string representation which has to be parsed.
    //      * @param handler
    //      *            the specific stream handler to be used by this URL.
    //      * @throws MalformedURLException
    //      *             if the given string {@code spec} could not be parsed as a URL
    //      *             or an invalid protocol has been found.
    //      */
    //     constructor(
    //         [in] IURL* context,
    //         [in] String spec,
    //         [in] IURLStreamHandler* handler);

    //     /**
    //      * Creates a new URL instance using the given arguments. The URL uses the
    //      * default port for the specified protocol.
    //      *
    //      * @param protocol
    //      *            the protocol of the new URL.
    //      * @param host
    //      *            the host name or IP address of the new URL.
    //      * @param file
    //      *            the name of the resource.
    //      * @throws MalformedURLException
    //      *             if the combination of all arguments do not represent a valid
    //      *             URL or the protocol is invalid.
    //      */
    //     constructor(
    //         [in] String protocol,
    //         [in] String host,
    //         [in] String file);

    //     /**
    //      * Creates a new URL instance using the given arguments. The URL uses the
    //      * specified port instead of the default port for the given protocol.
    //      *
    //      * @param protocol
    //      *            the protocol of the new URL.
    //      * @param host
    //      *            the host name or IP address of the new URL.
    //      * @param port
    //      *            the specific port number of the URL. {@code -1} represents the
    //      *            default port of the protocol.
    //      * @param file
    //      *            the name of the resource.
    //      * @throws MalformedURLException
    //      *             if the combination of all arguments do not represent a valid
    //      *             URL or the protocol is invalid.
    //      */
    //     constructor(
    //         [in] String protocol,
    //         [in] String host,
    //         [in] Int32 port,
    //         [in] String file);

    //     /**
    //      * Creates a new URL instance using the given arguments. The URL uses the
    //      * specified port instead of the default port for the given protocol.
    //      *
    //      * @param protocol
    //      *            the protocol of the new URL.
    //      * @param host
    //      *            the host name or IP address of the new URL.
    //      * @param port
    //      *            the specific port number of the URL. {@code -1} represents the
    //      *            default port of the protocol.
    //      * @param file
    //      *            the name of the resource.
    //      * @param handler
    //      *            the stream handler to be used by this URL.
    //      * @throws MalformedURLException
    //      *             if the combination of all arguments do not represent a valid
    //      *             URL or the protocol is invalid.
    //      * @throws SecurityException
    //      *             if {@code handler} is non-{@code null}, and a security
    //      *             manager is installed that disallows user-defined protocol
    //      *             handlers.
    //      */
    //     constructor(
    //         [in] String protocol,
    //         [in] String host,
    //         [in] Int32 port,
    //         [in] String file,
    //         [in] IURLStreamHandler* handler);

    //     interface IURL;
    // }

    // singleton class CURLEncoder
    // {
    //     interface IURLEncoder;
    // }

    // singleton class CURLDecoder
    // {
    //     interface IURLDecoder;
    // }

    // singleton class CNetworkInterfaceHelper
    // {
    //     interface INetworkInterfaceHelper;
    // }

    // singleton class CMimeUtils
    // {
    //     interface IMimeUtils;
    // }

    // singleton class CProxyHelper
    // {
    //     interface IProxyHelper;
    // }

    // singleton class CCookieHandlerHelper
    // {
    //     interface ICookieHandlerHelper;
    // }

    // singleton class CUriCodecHelper
    // {
    //     interface IUriCodecHelper;
    // }

    // singleton class CIDNHelper
    // {
    //     interface IIDNHelper;
    // }

    // class CSocket {
    //     constructor();

    //     constructor(
    //         [in] IProxy* proxy);

    //     constructor(
    //         [in] String dstName,
    //         [in] Int32 dstPort);

    //     constructor(
    //         [in] String dstName,
    //         [in] Int32 dstPort,
    //         [in] IInetAddress* localAddress,
    //         [in] Int32 localPort);

    //     constructor(
    //         [in] String hostName,
    //         [in] Int32 port,
    //         [in] Boolean streaming);

    //     constructor(
    //         [in] IInetAddress* dstAddress,
    //         [in] Int32 dstPort);

    //     constructor(
    //         [in] IInetAddress* dstAddress,
    //         [in] Int32 dstPort,
    //         [in] IInetAddress* localAddress,
    //         [in] Int32 localPort);

    //     constructor(
    //         [in] IInetAddress* addr,
    //         [in] Int32 port,
    //         [in] Boolean streaming);

    //     interface ISocket;
    // }

    // class CSocketHelper {
    //     interface ISocketHelper;
    // }

    // class CServerSocket {
    //     constructor();

    //     constructor(
    //         [in] Int32 port);

    //     constructor(
    //         [in] Int32 port,
    //         [in] Int32 backlog);

    //     constructor(
    //         [in] Int32 port,
    //         [in] Int32 backlog,
    //         [in] IInetAddress* localAddress);

    //     interface IServerSocket;
    // }

    // singleton class CServerSocketHelper {
    //     interface IServerSocketHelper;
    // }

    // class CPlainSocketImpl {
    //     constructor();

    //     constructor(
    //         [in] IFileDescriptor * pFd);

    //     constructor(
    //         [in] IProxy * pProxy);

    //     constructor(
    //         [in] IFileDescriptor * pFd,
    //         [in] Int32 localport,
    //         [in] IInetAddress * pAddr,
    //         [in] Int32 port);

    //     interface IPlainSocketImpl;
    // }

    // class CPlainServerSocketImpl {
    //     constructor();

    //     constructor(
    //         [in] IFileDescriptor * pFd);

    //     interface IPlainServerSocketImpl;
    // }

    // class CSocketInputStream {
    //     constructor(
    //         [in] ISocketImpl * pImpl);

    //     interface ISocketInputStream;
    // }

    // class CSocketOutputStream {
    //     constructor(
    //         [in] ISocketImpl * pImpl);

    //     interface ISocketOutputStream;
    //     interface IFlushable;
    // }

    // class CMulticastSocket {
    //     constructor();

    //     constructor(
    //         [in] Int32 aPort);

    //     constructor(
    //         [in] ISocketAddress* localAddr);

    //     interface IMulticastSocket;
    // }

    // class CRawSocket {
    //     constructor(
    //         [in] String interfaceName,
    //         [in] Int16 protocolType);

    //     interface IRawSocket;
    // }

    // class CPlainDatagramSocketImpl {
    //     constructor(
    //         [in] IFileDescriptor* fd,
    //         [in] Int32 localPort);

    //     constructor();

    //     interface IDatagramSocketImpl;
    // }

    // class CSocks4Message {
    //     constructor();

    //     interface ISocks4Message;
    // }

    // [deprecated]
    // class CInetAddress {
    //     constructor();

    //     /**
    //      * Constructs an {@code InetAddress}.
    //      *
    //      * Note: this constructor is for subclasses only.
    //      */
    //     constructor(
    //         [in] Int32 family,
    //         [in] ArrayOf<Byte>* ipaddress,
    //         [in] String hostName);

    //     interface IInetAddress;
    // }

    // } // namespace Net
    // } // namespace Elastos

    // namespace Elastos {
    // namespace Net {
    // namespace Http {

    // class CAbstractHttpInputStream {
    //     constructor(
    //         [in] IInputStream* inst,
    //         [in] IHttpEngine* httpEngine,
    //         [in] ICacheRequest* cacheRequest);

    //     interface IAbstractHttpInputStream;
    // }

    // class CChallenge {
    //     constructor(
    //         [in] String scheme,
    //         [in] String realm);

    //     interface IChallenge;
    // }

    // class CChunkedInputStream {
    //     constructor(
    //         [in] IInputStream* is,
    //         [in] ICacheRequest* cacheRequest,
    //         [in] IHttpEngine* httpEngine);

    //     interface IChunkedInputStream;
    // }

    // class CChunkedOutputStream {
    //     constructor(
    //         [in] IOutputStream* socketOut,
    //         [in] Int32 maxChunkLength);

    //     interface IChunkedOutputStream;
    //     interface IFlushable;
    // }

    // class CFixedLengthInputStream {
    //     constructor(
    //         [in] IInputStream* is,
    //         [in] ICacheRequest* cacheRequest,
    //         [in] IHttpEngine* httpEngine,
    //         [in] Int32 length);

    //     interface IFixedLengthInputStream;
    // }

    // class CFixedLengthOutputStream {
    //     constructor(
    //         [in] IOutputStream* socketOut,
    //         [in] Int32 bytesRemaining);

    //     interface IFixedLengthOutputStream;
    //     interface IFlushable;
    // }

    // singleton class CHeaderParserHelper{
    //     interface IHeaderParserHelper;
    // }

    // singleton class CHttpDate {
    //     interface IHttpDate;
    // }

    // class CHttpHandler {
    //     constructor();

    //     interface IHttpHandler;
    // }

    // class CHttpResponseCache {
    //     constructor(
    //         [in] IFile* directory,
    //         [in] Int64 maxSize);

    //     interface IHttpResponseCache;
    //     interface IExtendedResponseCache;
    // }

    // class CHttpsHandler {
    //     constructor();

    //     interface IHttpsHandler;
    // }

    // class CHttpEngine {
    //     constructor(
    //         [in] IHttpURLConnectionImpl* policy,
    //         [in] String method,
    //         [in] IRawHeaders* requestHeaders,
    //         [in] IHttpConnection* connection,
    //         [in] IRetryableOutputStream* requestBodyOut);

    //     interface IHttpEngine;
    // }

    // class CRawHeaders {
    //     constructor();

    //     constructor(
    //         [in] IRawHeaders* copyFrom);

    //     interface IRawHeaders;
    // }

    // singleton class CRawHeadersHelper {
    //     interface IRawHeadersHelper;
    // }

    // class CRequestHeaders {
    //     constructor(
    //         [in] IURI* uri,
    //         [in] IRawHeaders* headers);

    //     interface IRequestHeaders;
    // }

    // class CResponseHeaders {
    //     constructor(
    //         [in] IURI* uri,
    //         [in] IRawHeaders* headers);

    //     interface IResponseHeaders;
    // }

    // class CRetryableOutputStream {
    //     constructor();

    //     constructor(
    //         [in] Int32 limi);

    //     interface IRetryableOutputStream;
    //     interface IFlushable;
    // }

    // class CUnknownLengthHttpInputStream {
    //     constructor(
    //         [in] IInputStream* is,
    //         [in] ICacheRequest* cacheRequest,
    //         [in] IHttpEngine* httpEngine);

    //     interface IUnknownLengthHttpInputStream;
    // }

    // } // namespace Http
    // } // namespace Net
    // } // namespace Elastos

    // namespace Elastos {
    // namespace Net {
    // namespace Url {

    // class CFileHandler {
    //     constructor();

    //     interface IFileHandler;
    // }

    // class CFileURLConnection {
    //     constructor(
    //         [in] Elastos.Net.IURL* url);

    //     interface IFileURLConnection;
    // }

    // class CFtpHandler {
    //     constructor();

    //     interface IFtpHandler;
    // }

    // class CFtpURLInputStream {
    //     constructor(
    //         [in] IInputStream* is,
    //         [in] Elastos.Net.ISocket* controlSocket);

    //     interface IFtpURLInputStream;
    // }

    // class CUrlUtilsHelper {
    //     interface IUrlUtilsHelper;
    // }

    // } // namespace Url
    // } // namespace Net
    // } // namespace Elastos
}
