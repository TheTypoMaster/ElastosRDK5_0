
module
{
    interface Elastos.Core.ICharSequence;

    namespace Elastos {
    namespace Core {

    /**
     * @Involve
     * interface ICharSequence;
     */
    interface IStringBuffer {

        ToASCIILowerCase();

        ToASCIIUpperCase();

        /**
         * Reset the current content.
         */
        Reset();

        /**
         * The number of bytes.
         *
         * @return the number of bytes contained in this instance.
         */
        GetByteCount(
            [out] Int32* byteLength);

        /**
         * Returns the number of bytes that can be held without growing.
         *
         * @return the capacity
         * @see #ensureCapacity
         * @see #length
         */
        GetCapacity(
            [out] Int32* capacity);

        /**
         * Ensures that this object has a minimum capacity available before
         * requiring the internal buffer to be enlarged. The general policy of this
         * method is that if the {@code minimumCapacity} is larger than the current
         * {@link #capacity()}, then the capacity will be increased to the largest
         * value of either the {@code minimumCapacity} or the current capacity
         * multiplied by two plus two. Although this is the general policy, there is
         * no guarantee that the capacity will change.
         *
         * @param min
         *            the new minimum capacity to set.
         */
        EnsureCapacity(
            [in] Int32 min);

        /**
         * Sets the character at the {@code index} base on unicode.
         *
         * @param index
         *            the zero-based index of the unicode character to replace.
         * @param ch
         *            the character to set.
         * @throws IndexOutOfBoundsException
         *             if {@code index} is negative or greater than or equal to the
         *             current {@link #length()}.
         */
        SetCharAt(
            [in] Int32 index,
            [in] Char32 ch);

        /**
         * Copies the requested sequence of characters into {@code dst} passed
         * starting at {@code dst}.
         *
         * @param start
         *            the inclusive start index of the unicode characters to copy.
         * @param end
         *            the exclusive end index of the unicode characters to copy.
         * @param dst
         *            the {@code char[]} to copy the characters to.
         * @param dstStart
         *            the inclusive start index of {@code dst} to begin copying to.
         * @throws IndexOutOfBoundsException
         *             if the {@code start} is negative, the {@code dstStart} is
         *             negative, the {@code start} is greater than {@code end}, the
         *             {@code end} is greater than the current {@link #length()} or
         *             {@code dstStart + end - begin} is greater than
         *             {@code dst.length}.
         */
        GetChars(
            [in] Int32 start,
            [in] Int32 end,
            [out] ArrayOf<Char32> dst,
            [in] Int32 dstStart);

        /**
         * Returns the String value of the subsequence from the {@code start} index
         * to the current end.
         *
         * @param start
         *            the inclusive start index to begin the subsequence.
         * @return a String containing the subsequence.
         * @throws StringIndexOutOfBoundsException
         *             if {@code start} is negative or greater than the current
         *             {@link #length()}.
         */
        Substring(
            [in] Int32 start,
            [out] String* str);

        /**
         * Returns the String value of the subsequence from the {@code start} index
         * to the {@code end} index.
         *
         * @param start
         *            the inclusive start index to begin the subsequence.
         * @param end
         *            the exclusive end index to end the subsequence.
         * @return a String containing the subsequence.
         * @throws StringIndexOutOfBoundsException
         *             if {@code start} is negative, greater than {@code end} or if
         *             {@code end} is greater than the current {@link #length()}.
         */
        Substring(
            [in] Int32 start,
            [in] Int32 end,
            [out] String* str);

        /**
         * Searches for the first index of the specified character. The search for
         * the character starts at the beginning and moves towards the end.
         *
         * @param string
         *            the string to find.
         * @return the index of the specified character, -1 if the character isn't
         *         found.
         * @see #lastIndexOf(String)
         * @since 1.4
         */
        IndexOf(
            [in] String string,
            [out] Int32* index);

        /**
         * Searches for the index of the specified character. The search for the
         * character starts at the specified offset and moves towards the end.
         *
         * @param subString
         *            the string to find.
         * @param start
         *            the starting offset.
         * @return the index of the specified character, -1 if the character isn't
         *         found
         * @see #lastIndexOf(String,int)
         * @since 1.4
         */
        IndexOf(
            [in] String subString,
            [in] Int32 start,
            [out] Int32* index);

        /**
         * Searches for the last index of the specified character. The search for
         * the character starts at the end and moves towards the beginning.
         *
         * @param string
         *            the string to find.
         * @return the index of the specified character, -1 if the character isn't
         *         found.
         * @throws NullPointerException
         *             if {@code string} is {@code null}.
         * @see String#lastIndexOf(java.lang.String)
         * @since 1.4
         */
        LastIndexOf(
            [in] String string,
            [out] Int32* index);

        /**
         * Searches for the index of the specified character. The search for the
         * character starts at the specified offset and moves towards the beginning.
         *
         * @param subString
         *            the string to find.
         * @param start
         *            the starting offset.
         * @return the index of the specified character, -1 if the character isn't
         *         found.
         * @throws NullPointerException
         *             if {@code subString} is {@code null}.
         * @see String#lastIndexOf(String,int)
         * @since 1.4
         */
        LastIndexOf(
            [in] String subString,
            [in] Int32 start,
            [out] Int32* index);

        AppendNULL();

        /**
         * Adds the string representation of the specified boolean to the end of
         * this StringBuffer.
         * <p>
         * If the argument is {@code true} the string {@code "true"} is appended,
         * otherwise the string {@code "false"} is appended.
         *
         * @param b
         *            the boolean to append.
         * @return this StringBuffer.
         * @see String#valueOf(boolean)
         */
        AppendBoolean(
            [in] Boolean b);

        /**
         * Adds the specified character to the end of this buffer.
         *
         * @param ch
         *            the character to append.
         * @return this StringBuffer.
         * @see String#valueOf(char)
         */
        AppendChar32(
            [in] Char32 c);

        /**
         * Adds the string representation of the specified double to the end of this
         * StringBuffer.
         *
         * @param d
         *            the double to append.
         * @return this StringBuffer.
         * @see String#valueOf(double)
         */
        AppendDouble(
            [in] Double d);

        /**
         * Adds the string representation of the specified float to the end of this
         * StringBuffer.
         *
         * @param f
         *            the float to append.
         * @return this StringBuffer.
         * @see String#valueOf(float)
         */
        AppendFloat(
            [in] Float f);

        /**
         * Adds the string representation of the specified integer to the end of
         * this StringBuffer.
         *
         * @param i
         *            the integer to append.
         * @return this StringBuffer.
         * @see String#valueOf(int)
         */
        AppendInt32(
            [in] Int32 i);

        /**
         * Adds the string representation of the specified long to the end of this
         * StringBuffer.
         *
         * @param l
         *            the long to append.
         * @return this StringBuffer.
         * @see String#valueOf(long)
         */
        AppendInt64(
            [in] Int64 l);

        /**
         * Adds the string representation of the specified object to the end of this
         * StringBuffer.
         * <p>
         * If the specified object is {@code null} the string {@code "null"} is
         * appended, otherwise the objects {@code toString} is used to get its
         * string representation.
         *
         * @param obj
         *            the object to append (may be null).
         * @return this StringBuffer.
         * @see String#valueOf(Object)
         */
        AppendIInterface(
            [in] IInterface* obj);

        /**
         * Adds the specified string to the end of this buffer.
         * <p>
         * If the specified string is {@code null} the string {@code "null"} is
         * appended, otherwise the contents of the specified string is appended.
         *
         * @param string
         *            the string to append (may be null).
         * @return this StringBuffer.
         */
        AppendString(
            [in] String str);

        /**
         * Adds the specified StringBuffer to the end of this buffer.
         * <p>
         * If the specified StringBuffer is {@code null} the string {@code "null"}
         * is appended, otherwise the contents of the specified StringBuffer is
         * appended.
         *
         * @param sb
         *            the StringBuffer to append (may be null).
         * @return this StringBuffer.
         *
         * @since 1.4
         */
        AppendIStringBuffer(
            [in] IStringBuffer* sb);

        /**
         * Adds the specified StringBuilder to the end of this buffer.
         * <p>
         * If the specified StringBuilder is {@code null} the string {@code "null"}
         * is appended, otherwise the contents of the specified StringBuilder is
         * appended.
         *
         * @param sb
         *            the StringBuilder to append (may be null).
         * @return this StringBuffer.
         *
         * @since 1.4
         */
        AppendIStringBuilder(
            [in] IStringBuilder* sb);

        /**
         * Adds the character array to the end of this buffer.
         *
         * @param chars
         *            the character array to append.
         * @return this StringBuffer.
         * @throws NullPointerException
         *            if {@code chars} is {@code null}.
         */
        AppendArrayOf(
            [in] ArrayOf<Char32> chars);

        /**
         * Adds the specified sequence of characters to the end of this buffer.
         *
         * @param chars
         *            the character array to append.
         * @param start
         *            the starting offset.
         * @param length
         *            the number of characters.
         * @return this StringBuffer.
         * @throws ArrayIndexOutOfBoundsException
         *             if {@code length < 0} , {@code start < 0} or {@code start +
         *             length > chars.length}.
         * @throws NullPointerException
         *            if {@code chars} is {@code null}.
         */
        AppendArrayOf(
            [in] ArrayOf<Char32> str,
            [in] Int32 start,
            [in] Int32 length);

        /**
         * Appends the specified CharSequence to this buffer.
         * <p>
         * If the specified CharSequence is {@code null} the string {@code "null"}
         * is appended, otherwise the contents of the specified CharSequence is
         * appended.
         *
         * @param s
         *            the CharSequence to append.
         * @return this StringBuffer.
         * @since 1.5
         */
        AppendICharSequence(
            [in] ICharSequence* csq);

        /**
         * Appends the specified subsequence of the CharSequence to this buffer.
         * <p>
         * If the specified CharSequence is {@code null}, then the string {@code
         * "null"} is used to extract a subsequence.
         *
         * @param s
         *            the CharSequence to append.
         * @param start
         *            the inclusive start index.
         * @param end
         *            the exclusive end index.
         * @return this StringBuffer.
         * @throws IndexOutOfBoundsException
         *             if {@code start} or {@code end} are negative, {@code start}
         *             is greater than {@code end} or {@code end} is greater than
         *             the length of {@code s}.
         * @since 1.5
         */
        AppendICharSequence(
            [in] ICharSequence* csq,
            [in] Int32 start,
            [in] Int32 end);

        /**
         * Inserts the character into this buffer at the specified offset.
         *
         * @param index
         *            the index at which to insert.
         * @param ch
         *            the character to insert.
         * @return this buffer.
         * @throws ArrayIndexOutOfBoundsException
         *             if {@code index < 0} or {@code index > length()}.
         */
        InsertChar32(
            [in] Int32 offset,
            [in] Char32 c);

        /**
         * Inserts the string representation of the specified boolean into this
         * buffer at the specified offset.
         *
         * @param index
         *            the index at which to insert.
         * @param b
         *            the boolean to insert.
         * @return this buffer.
         * @throws StringIndexOutOfBoundsException
         *             if {@code index < 0} or {@code index > length()}.
         */
        InsertBoolean(
            [in] Int32 offset,
            [in] Boolean b);

        /**
         * Inserts the string representation of the specified integer into this
         * buffer at the specified offset.
         *
         * @param index
         *            the index at which to insert.
         * @param i
         *            the integer to insert.
         * @return this buffer.
         * @throws StringIndexOutOfBoundsException
         *             if {@code index < 0} or {@code index > length()}.
         */
        InsertInt32(
            [in] Int32 offset,
            [in] Int32 i);

        /**
         * Inserts the string representation of the specified long into this buffer
         * at the specified offset.
         *
         * @param index
         *            the index at which to insert.
         * @param l
         *            the long to insert.
         * @return this buffer.
         * @throws StringIndexOutOfBoundsException
         *             if {@code index < 0} or {@code index > length()}.
         */
        InsertInt64(
            [in] Int32 offset,
            [in] Int64 l);

        /**
         * Inserts the string representation of the specified into this buffer
         * double at the specified offset.
         *
         * @param index
         *            the index at which to insert.
         * @param d
         *            the double to insert.
         * @return this buffer.
         * @throws StringIndexOutOfBoundsException
         *             if {@code index < 0} or {@code index > length()}.
         */
        InsertDouble(
            [in] Int32 offset,
            [in] Double d);

        /**
         * Inserts the string representation of the specified float into this buffer
         * at the specified offset.
         *
         * @param index
         *            the index at which to insert.
         * @param f
         *            the float to insert.
         * @return this buffer.
         * @throws StringIndexOutOfBoundsException
         *             if {@code index < 0} or {@code index > length()}.
         */
        InsertFloat(
            [in] Int32 offset,
            [in] Float f);

        /**
         * Inserts the string representation of the specified object into this
         * buffer at the specified offset.
         * <p>
         * If the specified object is {@code null}, the string {@code "null"} is
         * inserted, otherwise the objects {@code toString} method is used to get
         * its string representation.
         *
         * @param index
         *            the index at which to insert.
         * @param obj
         *            the object to insert (may be null).
         * @return this buffer.
         * @throws StringIndexOutOfBoundsException
         *             if {@code index < 0} or {@code index > length()}.
         */
        InsertIInterface(
            [in] Int32 offset,
            [in] IInterface* obj);

        /**
         * Inserts the string into this buffer at the specified offset.
         * <p>
         * If the specified string is {@code null}, the string {@code "null"} is
         * inserted, otherwise the contents of the string is inserted.
         *
         * @param index
         *            the index at which to insert.
         * @param string
         *            the string to insert (may be null).
         * @return this buffer.
         * @throws StringIndexOutOfBoundsException
         *             if {@code index < 0} or {@code index > length()}.
         */
        InsertString(
            [in] Int32 offset,
            [in] String str);

        /**
         * Inserts the character array into this buffer at the specified offset.
         *
         * @param index
         *            the index at which to insert.
         * @param chars
         *            the character array to insert.
         * @return this buffer.
         * @throws StringIndexOutOfBoundsException
         *             if {@code index < 0} or {@code index > length()}.
         * @throws NullPointerException
         *            if {@code chars} is {@code null}.
         */
        InsertArrayOf(
            [in] Int32 offset,
            [in] ArrayOf<Char32> ch);

        /**
         * Inserts the specified subsequence of characters into this buffer at the
         * specified index.
         *
         * @param index
         *            the index at which to insert.
         * @param chars
         *            the character array to insert.
         * @param start
         *            the starting offset.
         * @param length
         *            the number of characters.
         * @return this buffer.
         * @throws NullPointerException
         *             if {@code chars} is {@code null}.
         * @throws StringIndexOutOfBoundsException
         *             if {@code length < 0}, {@code start < 0}, {@code start +
         *             length > chars.length}, {@code index < 0} or {@code index >
         *             length()}
         */
        InsertArrayOf(
            [in] Int32 offset,
            [in] ArrayOf<Char32> chars,
            [in] Int32 start,
            [in] Int32 length);

        /**
         * Inserts the specified CharSequence into this buffer at the specified
         * index.
         * <p>
         * If the specified CharSequence is {@code null}, the string {@code "null"}
         * is inserted, otherwise the contents of the CharSequence.
         *
         * @param index
         *            The index at which to insert.
         * @param s
         *            The char sequence to insert.
         * @return this buffer.
         * @throws IndexOutOfBoundsException
         *             if {@code index < 0} or {@code index > length()}.
         * @since 1.5
         */
        InsertICharSequence(
            [in] Int32 offset,
            [in] ICharSequence* s);

        /**
         * Inserts the specified subsequence into this buffer at the specified
         * index.
         * <p>
         * If the specified CharSequence is {@code null}, the string {@code "null"}
         * is inserted, otherwise the contents of the CharSequence.
         *
         * @param index
         *            The index at which to insert.
         * @param s
         *            The char sequence to insert.
         * @param start
         *            The inclusive start index in the char sequence.
         * @param end
         *            The exclusive end index in the char sequence.
         * @return this buffer.
         * @throws IndexOutOfBoundsException
         *             if {@code index} is negative or greater than the current
         *             length, {@code start} or {@code end} are negative, {@code
         *             start} is greater than {@code end} or {@code end} is greater
         *             than the length of {@code s}.
         * @since 1.5
         */
        InsertICharSequence(
            [in] Int32 offset,
            [in] ICharSequence* s,
            [in] Int32 start,
            [in] Int32 end);

        /**
         * Replaces the characters in the specified range with the contents of the
         * specified string.
         *
         * @param start
         *            the inclusive begin index.
         * @param end
         *            the exclusive end index.
         * @param string
         *            the string that will replace the contents in the range.
         * @return this buffer.
         * @throws StringIndexOutOfBoundsException
         *             if {@code start} or {@code end} are negative, {@code start}
         *             is greater than {@code end} or {@code end} is greater than
         *             the length of {@code s}.
         */
        Replace(
            [in] Int32 start,
            [in] Int32 end,
            [in] String string);

        /**
         * Reverses the order of characters in this buffer.
         *
         * @return this buffer.
         */
        Reverse();

        /**
         * Deletes the unicode character at the specified offset.
         *
         * @param location
         *            the offset of the character to delete.
         * @return this StringBuffer.
         * @throws StringIndexOutOfBoundsException
         *             if {@code location < 0} or {@code location >= length()}
         */
        DeleteCharAt(
            [in] Int32 location);

        /**
         * Deletes a range of unicode characters.
         *
         * @param start
         *            the offset of the first character.
         * @param end
         *            the offset one past the last character.
         * @return this StringBuffer.
         * @throws StringIndexOutOfBoundsException
         *             if {@code start < 0}, {@code start > end} or {@code end >
         *             length()}.
         */
        Delete(
            [in] Int32 start,
            [in] Int32 end);
    }

    } // namespace Core
    } // namespace Elastos
}
