module
{
    interface Elastos.Text.IAttributedCharacterIterator;
    interface Elastos.Text.IFieldPosition;
    interface Elastos.Text.IParsePosition;
    interface Elastos.Core.IStringBuffer;

    namespace Elastos {
    namespace Text {

    /**
     * Inner class used to represent Format attributes in the
     * AttributedCharacterIterator that the formatToCharacterIterator() method returns in Format subclasses.
     *
     * @implements Elastos.Text.IAttributedCharacterIteratorAttribute
     */
    /**
     * @Involve
     * interface IAttributedCharacterIteratorAttribute
     */
    interface IFormatField {
    }

    /**
     * The base class for all formats.
     * <p>
     * This is an abstract base class which specifies the protocol for classes which
     * convert other objects or values, such as numeric values and dates, and their
     * string representations. In some cases these representations may be localized or
     * contain localized characters or strings. For example, a numeric formatter such
     * as DecimalFormat may convert a numeric value such as 12345 to the string
     * "$12,345". It may also parse the string back into a numeric value. A date and
     * time formatter like SimpleDateFormat may represent a specific date, encoded
     * numerically, as a string such as "Wednesday, February 26, 1997 AD".
     * <p>
     * Many of the concrete subclasses of Format employ the notion of a pattern.
     * A pattern is a string representation of the rules which govern the conversion
     * between values and strings. For example, a DecimalFormat object may be
     * associated with the pattern "$#,##0.00;($#,##0.00)", which is a common US
     * English format for currency values, yielding strings such as "$1,234.45" for
     * 1234.45, and "($987.65)" for -987.6543. The specific syntax of a pattern is
     * defined by each subclass. Even though many subclasses use patterns, the notion
     * of a pattern is not inherent to Format classes in general, and is not part of
     * the explicit base class protocol.
     * <p>
     * Two complex formatting classes are worth mentioning: MessageFormat and
     * ChoiceFormat. ChoiceFormat is a subclass of NumberFormat which allows the user
     * to format different number ranges as strings. For instance, 0 may be
     * represented as "no files", 1 as "one file", and any number greater than 1 as
     * "many files". MessageFormat is a formatter which utilizes other Format objects
     * to format a string containing multiple values. For instance, a MessageFormat
     * object might produce the string "There are no files on the disk MyDisk on
     * February 27, 1997." given the arguments 0, "MyDisk", and the date value of
     * 2/27/97. See the ChoiceFormat and MessageFormat descriptions for further
     * information.
     */
    [deprecated]
    interface IFormat {

        /**
         * Formats the specified object using the rules of this format.
         *
         * @param object
         *         the object to format.
         * @return the formatted string.
         * @return ECode = NOERROR(0) if success, else as follows:
         * Value | Meaning |
         * :-|:------------|
         * IllegalArgumentException | if the object cannot be formatted by this format.
         */
        FormatObject(
            [in] IInterface* object,
            [out] String* value);

        /**
         * Appends the specified object to the specified string buffer using the
         * rules of this format.
         * <p>
         * {field} is an input/output parameter. If its {field}
         * member contains an enum value specifying a field on input, then its
         * {beginIndex} and {endIndex} members will be updated with the
         * text offset of the first occurrence of this field in the formatted text.
         *
         * @param object
         *            the object to format.
         * @param buffer
         *            the string buffer where the formatted string is appended to.
         * @param field
         *            on input: an optional alignment field; on output: the offsets
         *            of the alignment field in the formatted text.
         * @return the string buffer.
         * @return ECode = NOERROR(0) if success, else as follows:
         * Value | Meaning |
         * :-|:------------|
         * IllegalArgumentException | if the object cannot be formatted by this format.
         */
        FormatObjectEx(
            [in] IInterface* object,
            [in] IStringBuffer * buffer,
            [in] IFieldPosition* field,
            [out] IStringBuffer ** value);

        /**
         * Formats the specified object using the rules of this format and returns
         * an {AttributedCharacterIterator} with the formatted string and no
         * attributes.
         */
        FormatToCharacterIterator(
            [in] IInterface* object,
            [out] IAttributedCharacterIterator** charactorIterator);

        /**
         * Parses the specified string using the rules of this format.
         */
        ParseObject(
            [in] String string,
            [out] IInterface** object);

        /**
         * Parses the specified string starting at the index specified by
         * {position}. If the string is successfully parsed then the index of
         * the {ParsePosition} is updated to the index following the parsed
         * text. On error, the index is unchanged and the error index of
         * {ParsePosition} is set to the index where the error occurred.
         */
        ParseObjectEx(
            [in] String string,
            [in] IParsePosition* position,
            [out] IInterface** object);

        Equals(
            [in] IInterface* object,
            [out] Boolean* result);

//        GetHashCode(
//            [out] Int32 * value);

//        Clone(
//            [out] IInterface* object);
    }

    } // namespace Text
    } // namespace Elastos
}
