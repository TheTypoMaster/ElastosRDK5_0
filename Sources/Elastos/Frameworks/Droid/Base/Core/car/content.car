module
{
    merge("content/AbstractThreadedSyncAdapter.car");
    merge("content/AsyncQueryHandler.car");
    merge("content/AsyncTaskLoader.car");
    merge("content/BroadcastReceiver.car");
    merge("content/ClipData.car");
    merge("content/ClipDescription.car");
    merge("content/ClipboardManager.car");
    merge("content/ComponentCallbacks.car");
    merge("content/ComponentCallbacks2.car");
    merge("content/ComponentName.car");
    merge("content/ContentInsertHandler.car");
    merge("content/ContentProvider.car");
    merge("content/ContentProviderClient.car");
    merge("content/ContentProviderOperation.car");
    merge("content/ContentProviderResult.car");
    merge("content/ContentQueryMap.car");
    merge("content/ContentResolver.car");
    merge("content/ContentUris.car");
    merge("content/ContentValues.car");
    merge("content/Context.car");
    merge("content/ContextWrapper.car");
    merge("content/CursorEntityIterator.car");
    merge("content/CursorLoader.car");
    merge("content/DialogInterface.car");
    merge("content/Entity.car");
    merge("content/EntityIterator.car");
    merge("content/IClipboard.car");
    merge("content/IContentProvider.car");
    merge("content/IContentService.car");
    merge("content/IIntentReceiver.car");
    merge("content/IIntentSender.car");
    merge("content/IOnPrimaryClipChangedListener.car");
    merge("content/IRestrictionsManager.car");
    merge("content/ISyncAdapter.car");
    merge("content/ISyncContext.car");
    merge("content/ISyncServiceAdapter.car");
    merge("content/ISyncStatusObserver.car");
    merge("content/Intent.car");
    merge("content/IntentFilter.car");
    merge("content/IntentSender.car");
    merge("content/Loader.car");
    merge("content/MutableContextWrapper.car");
    merge("content/PeriodicSync.car");
    merge("content/RestrictionEntry.car");
    merge("content/RestrictionsManager.car");
    merge("content/SearchRecentSuggestionsProvider.car");
    merge("content/ServiceConnection.car");
    merge("content/SharedPreferences.car");
    merge("content/SyncAdapterType.car");
    merge("content/SyncContext.car");
    merge("content/SyncInfo.car");
    merge("content/SyncRequest.car");
    merge("content/SyncResult.car");
    merge("content/SyncStats.car");
    merge("content/SyncStatusInfo.car");
    merge("content/SyncStatusObserver.car");
    merge("content/UriMatcher.car");

//     merge("content/SyncManager.car");
//     merge("content/SyncOperation.car");
//     merge("content/SyncQueue.car");
//     merge("content/SyncStorageEngine.car");
//     merge("content/NativeLibraryHelper.car");
//     merge("content/PackageHelper.car");
//     merge("content/PackageMonitor.car");
//     merge("content/SelectionBuilder.car");

    merge("content/pm/ActivityInfo.car");

//     merge("content/pm/PackageItemInfo.car");
//     merge("content/pm/ComponentInfo.car");
//     merge("content/pm/ApplicationInfo.car");
//     merge("content/pm/ConfigurationInfo.car");
//     merge("content/pm/ContainerEncryptionParams.car");
//     merge("content/pm/FeatureInfo.car");
//     merge("content/pm/IPackageDataObserver.car");
//     merge("content/pm/IPackageDeleteObserver.car");
//     merge("content/pm/IPackageInstallObserver.car");
//     merge("content/pm/IPackageManager.car");
//     merge("content/pm/IPackageMoveObserver.car");
//     merge("content/pm/IPackageStatsObserver.car");
//     merge("content/pm/InstrumentationInfo.car");
//     merge("content/pm/LabeledIntent.car");
//     merge("content/pm/LimitedLengthInputStream.car");
//     merge("content/pm/MacAuthenticatedInputStream.car");
//     merge("content/pm/ManifestDigest.car");
//     merge("content/pm/PackageCleanItem.car");
//     merge("content/pm/PackageInfo.car");
//     merge("content/pm/PackageInfoLite.car");
//     merge("content/pm/PackageManager.car");
//     merge("content/pm/PackageStats.car");
//     merge("content/pm/ParceledListSlice.car");
//     merge("content/pm/PathPermission.car");
//     merge("content/pm/PermissionGroupInfo.car");
//     merge("content/pm/PermissionInfo.car");
//     merge("content/pm/ProviderInfo.car");
//     merge("content/pm/RegisteredServicesCacheListener.car");
//     merge("content/pm/ResolveInfo.car");
//     merge("content/pm/ServiceInfo.car");
//     merge("content/pm/Signature.car");
    merge("content/pm/UserInfo.car");
//     merge("content/pm/VerificationParams.car");
//     merge("content/pm/VerifierDeviceIdentity.car");
//     merge("content/pm/VerifierInfo.car");
//     merge("content/pm/XmlSerializerAndParser.car");

    merge("content/res/AssetFileDescriptor.car");
    merge("content/res/AssetManager.car");
    merge("content/res/ColorStateList.car");
    merge("content/res/CompatibilityInfo.car");
    merge("content/res/Configuration.car");
    merge("content/res/ObbInfo.car");
    merge("content/res/ObbScanner.car");
    merge("content/res/Resources.car");
    merge("content/res/TypedArray.car");
    merge("content/res/XmlResourceParser.car");

//     using interface Elastos.Utility.IObservable;
//     using interface Elastos.Core.ICharSequence;
//     using interface Elastos.Core.IComparable;
//     using interface Elastos.IO.IInputStream;
//     using interface Elastos.IO.IFlushable;
//     using interface Elastos.Crypto.IMac;

//     interface Elastos.Droid.Net.IUri;
//     interface Elastos.Droid.Content.IIntent;
//     interface Elastos.Droid.Content.IComponentName;

//     namespace Elastos {
//     namespace Droid {
//     namespace Content {
//     namespace Pm {

//     /**
//      * Information you can retrieve about a particular application
//      * activity or receiver. This corresponds to information collected
//      * from the AndroidManifest.xml's &lt;activity&gt; and
//      * &lt;receiver&gt; tags.
//      */
//     class CActivityInfo {
//         constructor();

//         constructor(
//             [in] IActivityInfo* orig);

//         interface IActivityInfo;
//         interface IParcelable;
//     }

//     singleton class CActivityInfoHelper {
//         interface IActivityInfoHelper;
//     }

//     /**
//      * Information you can retrieve about a particular application.  This
//      * corresponds to information collected from the AndroidManifest.xml's
//      * &lt;application&gt; tag.
//      */
//     class CApplicationInfo {
//         constructor();

//         constructor(
//             [in] IApplicationInfo* orig);

//         interface IApplicationInfo;
//         interface IParcelable;
//     }

//     class CApplicationInfoDisplayNameComparator {
//         constructor(
//             [in] IPackageManager* pm);

//         interface IApplicationInfoDisplayNameComparator;
//     }

//     /**
//      * Base class containing information common to all application components
//      * ({@link ActivityInfo}, {@link ServiceInfo}).  This class is not intended
//      * to be used by itself; it is simply here to share common definitions
//      * between all application components.  As such, it does not itself
//      * implement Parcelable, but does provide convenience methods to assist
//      * in the implementation of Parcelable in subclasses.
//      */
//     class CComponentInfo {
//         constructor();

//         constructor(
//             [in] IComponentInfo* orig);

//         interface IComponentInfo;
//     }

//     /**
//      * Information you can retrieve about hardware configuration preferences
//      * declared by an application. This corresponds to information collected from the
//      * AndroidManifest.xml's &lt;uses-configuration&gt; and &lt;uses-feature&gt; tags.
//      */
//     class CConfigurationInfo {
//         constructor();

//         constructor(
//             [in] IConfigurationInfo* orig);

//         interface IConfigurationInfo;
//         interface IParcelable;
//     }

//     /**
//      * Represents encryption parameters used to read a container.
//      *
//      * @hide
//      */
// //    [deprecated]
// //    class CContainerEncryptionParams {
// //        constructor();
// //
// //        constructor(
// //            [in] String encryptionAlgorithm,
// //            [in] IAlgorithmParameterSpec* encryptionSpec,
// //            [in] ISecretKey* encryptionKey);
// //
// //        /**
// //         * Creates container encryption specifications for installing from encrypted
// //         * containers.
// //         *
// //         * @param encryptionAlgorithm encryption algorithm to use; format matches
// //         *            JCE
// //         * @param encryptionSpec algorithm parameter specification
// //         * @param encryptionKey key used for decryption
// //         * @param macAlgorithm MAC algorithm to use; format matches JCE
// //         * @param macSpec algorithm parameters specification, may be {@code null}
// //         * @param macKey key used for authentication (i.e., for the MAC tag)
// //         * @param macTag message authentication code (MAC) tag for the authenticated
// //         *            data
// //         * @param authenticatedDataStart offset of start of authenticated data in
// //         *            stream
// //         * @param encryptedDataStart offset of start of encrypted data in stream
// //         * @param dataEnd offset of the end of both the authenticated and encrypted
// //         *            data
// //         * @throws InvalidAlgorithmParameterException
// //         */
// //        constructor(
// //            [in] String encryptionAlgorithm,
// //            [in] IAlgorithmParameterSpec* encryptionSpec,
// //            [in] ISecretKey* encryptionKey,
// //            [in] String macAlgorithm,
// //            [in] IAlgorithmParameterSpec* macSpec,
// //            [in] ISecretKey* macKey,
// //            [in] ArrayOf<Byte>* macTag,
// //            [in] Int64 authenticatedDataStart,
// //            [in] Int64 encryptedDataStart,
// //            [in] Int64 dataEnd);
// //
// //        interface IContainerEncryptionParams;
// //        interface IParcelable;
// //    }

//     /**
//      * A single feature that can be requested by an application. This corresponds
//      * to information collected from the
//      * AndroidManifest.xml's &lt;uses-feature&gt; tag.
//      */
//     class CFeatureInfo {
//         constructor();

//         constructor(
//             [in] IFeatureInfo* orig);

//         interface IFeatureInfo;
//         interface IParcelable;
//     }

//     /**
//      * Information you can retrieve about a particular piece of test
//      * instrumentation.  This corresponds to information collected
//      * from the AndroidManifest.xml's &lt;instrumentation&gt; tag.
//      */
//     class CInstrumentationInfo {
//         constructor();

//         constructor(
//             [in] IInstrumentationInfo* orig);

//         interface IInstrumentationInfo;
//         interface IParcelable;
//     }

//     /**
//      * A special subclass of Intent that can have a custom label/icon
//      * associated with it.  Primarily for use with {@link Intent#ACTION_CHOOSER}.
//      */
//    class CLabeledIntent {
//        /**
//         * Create a labeled intent from the given intent, supplying the label
//         * and icon resources for it.
//         *
//         * @param origIntent The original Intent to copy.
//         * @param sourcePackage The package in which the label and icon live.
//         * @param labelRes Resource containing the label, or 0 if none.
//         * @param icon Resource containing the icon, or 0 if none.
//         */
//         constructor(
//             [in] IIntent* origIntent,
//             [in] String sourcePackage,
//             [in] Int32 labelRes,
//             [in] Int32 icon);

//        /**
//         * Create a labeled intent from the given intent, supplying a textual
//         * label and icon resource for it.
//         *
//         * @param origIntent The original Intent to copy.
//         * @param sourcePackage The package in which the label and icon live.
//         * @param nonLocalizedLabel Concrete text to use for the label.
//         * @param icon Resource containing the icon, or 0 if none.
//         */
//         constructor(
//             [in] IIntent* origIntent,
//             [in] String sourcePackage,
//             [in] ICharSequence* nonLocalizedLabel,
//             [in] Int32 icon);

//         /**
//          * Create a labeled intent with no intent data but supplying the label
//          * and icon resources for it.
//          *
//          * @param sourcePackage The package in which the label and icon live.
//          * @param labelRes Resource containing the label, or 0 if none.
//          * @param icon Resource containing the icon, or 0 if none.
//          */
//         constructor(
//             [in] String sourcePackage,
//             [in] Int32 labelRes,
//             [in] Int32 icon);

//        /**
//         * Create a labeled intent with no intent data but supplying a textual
//         * label and icon resource for it.
//         *
//         * @param sourcePackage The package in which the label and icon live.
//         * @param nonLocalizedLabel Concrete text to use for the label.
//         * @param icon Resource containing the icon, or 0 if none.
//         */
//         constructor(
//             [in] String sourcePackage,
//             [in] ICharSequence* nonLocalizedLabel,
//             [in] Int32 icon);

//         constructor();

//        interface ILabeledIntent;
//        interface IParcelable;
//    }

//     /**
//      * A class that limits the amount of data that is read from an InputStream. When
//      * the specified length is reached, the stream returns an EOF even if the
//      * underlying stream still has more data.
//      *
//      * @hide
//      */
//    class CLimitedLengthInputStream {
//        /**
//         * @param in underlying stream to wrap
//         * @param offset offset into stream where data starts
//         * @param length length of data at offset
//         * @throws IOException if an error occurred with the underlying stream
//         */
//        constructor(
//            [in] IInputStream* inStream,
//            [in] Int64 offset,
//            [in] Int64 length);

//        interface ILimitedLengthInputStream;
//    }

//     /**
//      * An input stream filter that applies a MAC to the data passing through it. At
//      * the end of the data that should be authenticated, the tag can be calculated.
//      * After that, the stream should not be used.
//      *
//      * @hide
//      */
//    class CMacAuthenticatedInputStream {
//        constructor(
//            [in] IInputStream* inStream,
//            [in] IMac* mac);

//        interface IMacAuthenticatedInputStream;
//    }

//     /**
//      * Represents the manifest digest for a package. This is suitable for comparison
//      * of two packages to know whether the manifests are identical.
//      *
//      * @hide
//      */
//     [deprecated]
//     class CManifestDigest {
//         constructor();
//         constructor(
//             [in] ArrayOf<Byte>* digest);

//         interface IManifestDigest;
//         interface IParcelable;
//     }

//     singleton class CManifestDigestHelper {
//         interface IManifestDigestHelper;
//     }

//     /** @hide */
//     class CPackageCleanItem {
//         constructor();

//         constructor(
//             [in] Int32 userId,
//             [in] String packageName,
//             [in] Boolean andCode);

//         interface IPackageCleanItem;
//         interface IParcelable;
//     }

//     /**
//      * Overall information about the contents of a package.  This corresponds
//      * to all of the information collected from AndroidManifest.xml.
//      */
//     class CPackageInfo {
//         constructor();

//         interface IPackageInfo;
//         interface IParcelable;
//     }

//     /**
//      * Basic information about a package as specified in its manifest.
//      * Utility class used in PackageManager methods
//      * @hide
//      */
//     class CPackageInfoLite {
//         constructor();

//         interface IPackageInfoLite;
//         interface IParcelable;
//     }

//     /**
//      * Base class containing information common to all package items held by
//      * the package manager.  This provides a very common basic set of attributes:
//      * a label, icon, and meta-data.  This class is not intended
//      * to be used by itself; it is simply here to share common definitions
//      * between all items returned by the package manager.  As such, it does not
//      * itself implement Parcelable, but does provide convenience methods to assist
//      * in the implementation of Parcelable in subclasses.
//      */
//     class CPackageItemInfo {
//         constructor();

//         constructor(
//             [in] IPackageItemInfo* orig);

//         interface IPackageItemInfo;
//     }

//     class CPackageItemInfoDisplayNameComparator {
//         constructor(
//             [in] IPackageManager* pm);

//         interface IPackageItemInfoDisplayNameComparator;
//     }

// //    singleton class CPackageManagerHelper {
// //        interface IPackageManagerHelper;
// //    }

//     /**
//      * implementation of PackageStats associated with a
//      * application package.
//      */
//     class CPackageStats {
//         constructor();

//         constructor(
//             [in] String pkgName);

//         /** @hide */
//         constructor(
//             [in] String pkgName,
//             [in] Int32 userHandle);

//         constructor(
//             [in] IPackageStats* pStats);

//         interface IPackageStats;
//         interface IParcelable;
//     }

//     /**
//      * Builds up a parcel that is discarded when written to another parcel or
//      * written to a list. This is useful for API that sends huge lists across a
//      * Binder that may be larger than the IPC limit.
//      *
//      * @hide
//      */
//     class CParceledListSlice {
//         constructor();

//         interface IParceledListSlice;
//         interface IParcelable;
//     }

//     /**
//      * Description of permissions needed to access a particular path
//      * in a {@link ProviderInfo}.
//      */
//     class CPathPermission {
//         constructor();

//         constructor(
//             [in] String pattern,
//             [in] Int32 type,
//             [in] String readPermission,
//             [in] String writePermission);

//         interface IPathPermission;
//         interface IParcelable;
//     }

//     /**
//      * Information you can retrieve about a particular security permission
//      * group known to the system.  This corresponds to information collected from the
//      * AndroidManifest.xml's &lt;permission-group&gt; tags.
//      */
//     class CPermissionGroupInfo {
//         constructor();

//         constructor(
//             [in] IPermissionGroupInfo* orig);

//         interface IPermissionGroupInfo;
//         interface IParcelable;
//     }

//     /**
//      * Information you can retrieve about a particular security permission
//      * known to the system.  This corresponds to information collected from the
//      * AndroidManifest.xml's &lt;permission&gt; tags.
//      */
//     class CPermissionInfo {
//         constructor();

//         constructor(
//             [in] IPermissionInfo* orig);

//         interface IPermissionInfo;
//         interface IParcelable;
//     }

//     singleton class CPermissionInfoHelper {
//         interface IPermissionInfoHelper;
//     }

//     /**
//      * Holds information about a specific
//      * {@link android.content.ContentProvider content provider}. This is returned by
//      * {@link android.content.pm.PackageManager#resolveContentProvider(java.lang.String, int)
//      * PackageManager.resolveContentProvider()}.
//      */
//     class CProviderInfo {
//         constructor();

//         constructor(
//             [in] IProviderInfo* orig);

//         interface IProviderInfo;
//         interface IParcelable;
//     }

//     /**
//      * Information that is returned from resolving an intent
//      * against an IntentFilter. This partially corresponds to
//      * information collected from the AndroidManifest.xml's
//      * &lt;intent&gt; tags.
//      */
//     class CResolveInfo {
//         constructor();

//         constructor(
//             [in] IResolveInfo* orig);

//         interface IResolveInfo;
//         interface IParcelable;
//     }

//     class CResolveInfoDisplayNameComparator {
//         constructor(
//             [in] IPackageManager* pm);

//         interface IResolveInfoDisplayNameComparator;
//     }

//     /**
//      * Information you can retrieve about a particular application
//      * service. This corresponds to information collected from the
//      * AndroidManifest.xml's &lt;service&gt; tags.
//      */
//     class CServiceInfo {
//         constructor();

//         constructor(
//             [in] IServiceInfo* orig);

//         interface IServiceInfo;
//         interface IParcelable;
//     }

//     /**
//      * Opaque, immutable representation of a signature associated with an
//      * application package.
//      */
//     [deprecated]
//     class CSignature {
//         /**
//          * Create Signature from an existing raw byte array.
//          */
//         constructor(
//             [in] ArrayOf<Byte>* signature);

//         /**
//          * Create Signature from a text representation previously returned by
//          * {@link #toChars} or {@link #toCharsString()}. Signatures are expected to
//          * be a hex-encoded ASCII string.
//          *
//          * @param text hex-encoded string representing the signature
//          * @throws IllegalArgumentException when signature is odd-length
//          */
//         constructor(
//             [in] String text);

//         constructor();

//         interface ISignature;
//         interface IParcelable;
//     }

//     /**
//      * Per-user information.
//      * @hide
//      */
//     class CUserInfo {
//         constructor();

//         constructor(
//             [in] IUserInfo* orig);

//         constructor(
//             [in] Int32 id,
//             [in] String name,
//             [in] Int32 flags);

//         constructor(
//             [in] Int32 id,
//             [in] String name,
//             [in] String iconPath,
//             [in] Int32 flags);

//         interface IUserInfo;
//         interface IParcelable;
//     }

//     /**
//      * Represents verification parameters used to verify packages to be installed.
//      *
//      * @hide
//      */
//      [deprecated]
//      class CVerificationParams {
//          /**
//           * Creates verification specifications for installing with application verification.
//           *
//           * @param verificationURI The location of the supplementary verification
//           *            file. This can be a 'file:' or a 'content:' URI. May be {@code null}.
//           * @param originatingURI URI referencing where the package was downloaded
//           *            from. May be {@code null}.
//           * @param referrer HTTP referrer URI associated with the originatingURI.
//           *            May be {@code null}.
//           * @param originatingUid UID of the application that the install request originated
//           *            from, or NO_UID if not present
//           * @param manifestDigest an object that holds the digest of the package
//           *            which can be used to verify ownership. May be {@code null}.
//           */
//          constructor(
//              [in] IUri* verificationURI,
//              [in] IUri* originatingURI,
//              [in] IUri* referrer,
//              [in] Int32 originatingUid,
//              [in] IManifestDigest* manifestDigest);

//          constructor();

//          interface IVerificationParams;
//          interface IParcelable;
//      }

//     /**
//      * An identity that uniquely identifies a particular device. In this
//      * implementation, the identity is represented as a 64-bit integer encoded to a
//      * 13-character string using RFC 4648's Base32 encoding without the trailing
//      * padding. This makes it easy for users to read and write the code without
//      * confusing 'I' (letter) with '1' (one) or 'O' (letter) with '0' (zero).
//      *
//      * @hide
//      */
//      class CVerifierDeviceIdentity {
//          /**
//           * Create a verifier device identity from a long.
//           *
//           * @param identity device identity in a 64-bit integer.
//           * @throws
//           */
//          constructor(
//              [in] Int64 identity);

//          constructor();

//          interface IVerifierDeviceIdentity;
//          interface IParcelable;
//      }

//      singleton class CVerifierDeviceIdentityHelper {
//          interface IVerifierDeviceIdentityHelper;
//      }

// //    class CVerifierInfo {
// //        /**
// //         * Creates an object that represents a verifier info object.
// //         *
// //         * @param packageName the package name in Java-style. Must not be {@code
// //         *            null} or empty.
// //         * @param publicKey the public key for the signer encoded in Base64. Must
// //         *            not be {@code null} or empty.
// //         * @throws IllegalArgumentException if either argument is null or empty.
// //         */
// //        constructor(
// //            [in] String packageName,
// //            [in] IPublicKey* publicKey);
// //
// //        constructor();
// //
// //        interface IVerifierInfo;
// //        interface IParcelable;
// //    }

//     } // namespace Pm
//     } // namespace Content
//     } // namespace Droid
//     } // namespace Elastos

//     interface Elastos.Droid.Os.IParcelFileDescriptor;
//     interface Elastos.Droid.Content.Pm.IApplicationInfo;
//     interface Elastos.Droid.Utility.IDisplayMetrics;

//     namespace Elastos {
//     namespace Droid {
//     namespace Content {
//     namespace Res{

//     class CAssetFileDescriptor {
//         /**
//          * Create a new AssetFileDescriptor from the given values.
//          * @param fd The underlying file descriptor.
//          * @param startOffset The location within the file that the asset starts.
//          * This must be 0 if length is UNKNOWN_LENGTH.
//          * @param length The number of bytes of the asset, or
//          * {@link #UNKNOWN_LENGTH} if it extends to the end of the file.
//          */
//         constructor(
//             [in] IParcelFileDescriptor* fd,
//             [in] Int64 startOffset,
//             [in] Int64 length);

//         /**
//         * Create an empty surface, which will later be filled in by
//         * readFromParcel().
//         */
//         constructor();

//         interface IAssetFileDescriptor;
//         interface IParcelable;
//     }

//     class CAssetFileDescriptorAutoCloseInputStream {
//         constructor(
//             [in] IAssetFileDescriptor* fd);

//         interface IAssetFileDescriptorAutoCloseInputStream;
//     }

//     class CAssetFileDescriptorAutoCloseOutputStream {
//         constructor(
//             [in] IAssetFileDescriptor* fd);

//         interface IAssetFileDescriptorAutoCloseOutputStream;
//         interface IFlushable;
//     }

//     class CAssetManager {

//         /**
//          * Create a new AssetManager containing only the basic system assets.
//          * Applications will not generally use this method, instead retrieving the
//          * appropriate asset manager with {@link Resources#getAssets}.    Not for
//          * use by applications.
//          * {@hide}
//          */
//         constructor();

//         constructor(
//             [in] Boolean isSystem);

//         interface IAssetManager;
//     }

//     singleton class CAssetManagerHelper{
//         interface IAssetManagerHelper;
//     }

//     [deprecated]
//     class CColorStateList {
//         constructor();

//         /**
//          * Creates a ColorStateList that returns the specified mapping from
//          * states to colors.
//          */
//         constructor(
//             [in] ArrayOf<Handle32>* states,
//             [in] ArrayOf<Int32>* colors);

//         interface IColorStateList;
//         interface IParcelable;
//     }

//     singleton class CColorStateListHelper{

//         interface IColorStateListHelper;
//     }

//     class CCompatibilityInfo{
//         constructor(
//             [in] IApplicationInfo* appInfo,
//             [in] Int32 screenLayout,
//             [in] Int32 sw,
//             [in] Boolean forceCompat);

//         constructor(
//             [in] Int32 compFlags,
//             [in] Int32 dens,
//             [in] Float scale,
//             [in] Float invertedScale);

//         constructor();

//         interface ICompatibilityInfo;
//         interface IParcelable;
//     }

//     singleton class CCompatibilityInfoHelper{
//         interface ICompatibilityInfoHelper;
//     }

//     class CConfiguration{
//         /**
//          * Construct an invalid Configuration.  You must call {@link #setToDefaults}
//          * for this object to be valid.  {@more}
//          */
//         constructor();

//         /**
//          * Makes a deep copy suitable for modification.
//          */
//         constructor(
//             [in] IConfiguration* o);

//         interface IConfiguration;
//         interface IParcelable;
//         interface IComparable;
//     }

//     singleton class CConfigurationHelper{
//         interface IConfigurationHelper;
//     }

//     class CObbInfo {
//         constructor();

//         interface IObbInfo;
//         interface IParcelable;
//     }

//     singleton class CObbScanner {
//         // Don't allow others to instantiate this class

//         interface IObbScanner;
//     }

//     class CResources{
//         constructor();

//          /**
//          * Create a new Resources object on top of an existing set of assets in an
//          * AssetManager.
//          *
//          * @param assets Previously created AssetManager.
//          * @param metrics Current display metrics to consider when
//          *                selecting/computing resource values.
//          * @param config Desired device configuration to consider when
//          *               selecting/computing resource values (optional).
//          */
//         constructor(
//             [in] IAssetManager* assets,
//             [in] IDisplayMetrics* metrics,
//             [in] IConfiguration* config);

//         /**
//          * Creates a new Resources object with CompatibilityInfo.
//          *
//          * @param assets Previously created AssetManager.
//          * @param metrics Current display metrics to consider when
//          *                selecting/computing resource values.
//          * @param config Desired device configuration to consider when
//          *               selecting/computing resource values (optional).
//          * @param compInfo this resource's compatibility info. It will use the default compatibility
//          *  info when it's null.
//          * @hide
//          */
//         constructor(
//             [in] IAssetManager* assets,
//             [in] IDisplayMetrics* metrics,
//             [in] IConfiguration* config,
//             [in] ICompatibilityInfo* compInfo);

//         interface IResources;
//     }

//     singleton class CResourcesHelper {
//         interface IResourcesHelper;
//     }

//     [deprecated]
//     class CTypedArray{
//         constructor(
//             [in] IResources* resources,
//             [in] ArrayOf<Int32>* data,
//             [in] ArrayOf<Int32>* indices,
//             [in] Int32 len);

//         interface ITypedArray;
//     }

//     } // namespace Res
//     } // namespace Content
//     } // namepsace Droid
//     } // namespace Elastos


//     // using interface Elastos.Core.ICharSequence;
//     using interface Elastos.IO.IFile;
//     interface Elastos.Droid.Os.IBundle;
//     interface Elastos.Droid.Os.IBinder;
//     interface Elastos.Droid.Accounts.IAccount;
//     interface Elastos.Droid.Database.ICursor;
//     interface Elastos.Droid.Os.IHandler;

//     namespace Elastos {
//     namespace Droid {
//     namespace Content {

//     /**
//      * State for a result that is pending for a broadcast receiver.  Returned
//      * by {@link BroadcastReceiver#goAsync() goAsync()}
//      * while in {@link BroadcastReceiver#onReceive BroadcastReceiver.onReceive()}.
//      * This allows you to return from onReceive() without having the broadcast
//      * terminate; you must call {@link #finish()} once you are done with the
//      * broadcast.  This allows you to process the broadcast off of the main
//      * thread of your app.
//      *
//      * <p>Note on threading: the state inside of this class is not itself
//      * thread-safe, however you can use it from any thread if you properly
//      * sure that you do not have races.  Typically this means you will hand
//      * the entire object to another thread, which will be solely responsible
//      * for setting any results and finally calling {@link #finish()}.
//      */
//     class CPendingResult {
//         /** @hide */
//         constructor(
//             [in] Int32 resultCode,
//             [in] String resultData,
//             [in] IBundle* resultExtras,
//             [in] Int32 type,
//             [in] Boolean ordered,
//             [in] Boolean sticky,
//             [in] IBinder* token,
//             [in] Int32 userId);

//         interface IPendingResult;
//     }

//     /**
//      * Interface to the clipboard service, for placing and retrieving text in
//      * the global clipboard.
//      *
//      * <p>
//      * You do not instantiate this class directly; instead, retrieve it through
//      * {@link android.content.Context#getSystemService}.
//      *
//      * <p>
//      * The ClipboardManager API itself is very simple: it consists of methods
//      * to atomically get and set the current primary clipboard data.  That data
//      * is expressed as a {@link ClipData} object, which defines the protocol
//      * for data exchange between applications.
//      *
//      * <div class="special reference">
//      * <h3>Developer Guides</h3>
//      * <p>For more information about using the clipboard framework, read the
//      * <a href="{@docRoot}guide/topics/clipboard/copy-paste.html">Copy and Paste</a>
//      * developer guide.</p>
//      * </div>
//      *
//      * @see android.content.Context#getSystemService
//      */
//     [local]
//     class CClipboardManager {
//         /** {@hide} */
//         constructor(
//             [in] IContext* ctx);

//         interface IClipboardManager;
//     }

//     /**
//      * Representation of a clipped data on the clipboard.
//      *
//      * <p>ClippedData is a complex type containing one or Item instances,
//      * each of which can hold one or more representations of an item of data.
//      * For display to the user, it also has a label and iconic representation.</p>
//      *
//      * <p>A ClipData contains a {@link ClipDescription}, which describes
//      * important meta-data about the clip.  In particular, its
//      * {@link ClipDescription#getMimeType(int) getDescription().getMimeType(int)}
//      * must return correct MIME type(s) describing the data in the clip.  For help
//      * in correctly constructing a clip with the correct MIME type, use
//      * {@link #newPlainText(CharSequence, CharSequence)},
//      * {@link #newUri(ContentResolver, CharSequence, Uri)}, and
//      * {@link #newIntent(CharSequence, Intent)}.
//      *
//      * <p>Each Item instance can be one of three main classes of data: a simple
//      * CharSequence of text, a single Intent object, or a Uri.  See {@link Item}
//      * for more details.
//      *
//      * <div class="special reference">
//      * <h3>Developer Guides</h3>
//      * <p>For more information about using the clipboard framework, read the
//      * <a href="{@docRoot}guide/topics/clipboard/copy-paste.html">Copy and Paste</a>
//      * developer guide.</p>
//      * </div>
//      *
//      * <a name="ImplementingPaste"></a>
//      * <h3>Implementing Paste or Drop</h3>
//      *
//      * <p>To implement a paste or drop of a ClippedData object into an application,
//      * the application must correctly interpret the data for its use.  If the {@link Item}
//      * it contains is simple text or an Intent, there is little to be done: text
//      * can only be interpreted as text, and an Intent will typically be used for
//      * creating shortcuts (such as placing icons on the home screen) or other
//      * actions.
//      *
//      * <p>If all you want is the textual representation of the clipped data, you
//      * can use the convenience method {@link Item#coerceToText Item.coerceToText}.
//      * In this case there is generally no need to worry about the MIME types
//      * reported by {@link ClipDescription#getMimeType(int) getDescription().getMimeType(int)},
//      * since any clip item an always be converted to a string.
//      *
//      * <p>More complicated exchanges will be done through URIs, in particular
//      * "content:" URIs.  A content URI allows the recipient of a ClippedData item
//      * to interact closely with the ContentProvider holding the data in order to
//      * negotiate the transfer of that data.  The clip must also be filled in with
//      * the available MIME types; {@link #newUri(ContentResolver, CharSequence, Uri)}
//      * will take care of correctly doing this.
//      *
//      * <p>For example, here is the paste function of a simple NotePad application.
//      * When retrieving the data from the clipboard, it can do either two things:
//      * if the clipboard contains a URI reference to an existing note, it copies
//      * the entire structure of the note into a new note; otherwise, it simply
//      * coerces the clip into text and uses that as the new note's contents.
//      *
//      * {@sample development/samples/NotePad/src/com/example/android/notepad/NoteEditor.java
//      *      paste}
//      *
//      * <p>In many cases an application can paste various types of streams of data.  For
//      * example, an e-mail application may want to allow the user to paste an image
//      * or other binary data as an attachment.  This is accomplished through the
//      * ContentResolver {@link ContentResolver#getStreamTypes(Uri, String)} and
//      * {@link ContentResolver#openTypedAssetFileDescriptor(Uri, String, android.os.Bundle)}
//      * methods.  These allow a client to discover the type(s) of data that a particular
//      * content URI can make available as a stream and retrieve the stream of data.
//      *
//      * <p>For example, the implementation of {@link Item#coerceToText Item.coerceToText}
//      * itself uses this to try to retrieve a URI clip as a stream of text:
//      *
//      * {@sample frameworks/base/core/java/android/content/ClipData.java coerceToText}
//      *
//      * <a name="ImplementingCopy"></a>
//      * <h3>Implementing Copy or Drag</h3>
//      *
//      * <p>To be the source of a clip, the application must construct a ClippedData
//      * object that any recipient can interpret best for their context.  If the clip
//      * is to contain a simple text, Intent, or URI, this is easy: an {@link Item}
//      * containing the appropriate data type can be constructed and used.
//      *
//      * <p>More complicated data types require the implementation of support in
//      * a ContentProvider for describing and generating the data for the recipient.
//      * A common scenario is one where an application places on the clipboard the
//      * content: URI of an object that the user has copied, with the data at that
//      * URI consisting of a complicated structure that only other applications with
//      * direct knowledge of the structure can use.
//      *
//      * <p>For applications that do not have intrinsic knowledge of the data structure,
//      * the content provider holding it can make the data available as an arbitrary
//      * number of types of data streams.  This is done by implementing the
//      * ContentProvider {@link ContentProvider#getStreamTypes(Uri, String)} and
//      * {@link ContentProvider#openTypedAssetFile(Uri, String, android.os.Bundle)}
//      * methods.
//      *
//      * <p>Going back to our simple NotePad application, this is the implementation
//      * it may have to convert a single note URI (consisting of a title and the note
//      * text) into a stream of plain text data.
//      *
//      * {@sample development/samples/NotePad/src/com/example/android/notepad/NotePadProvider.java
//      *      stream}
//      *
//      * <p>The copy operation in our NotePad application is now just a simple matter
//      * of making a clip containing the URI of the note being copied:
//      *
//      * {@sample development/samples/NotePad/src/com/example/android/notepad/NotesList.java
//      *      copy}
//      *
//      * <p>Note if a paste operation needs this clip as text (for example to paste
//      * into an editor), then {@link Item#coerceToText(Context)} will ask the content
//      * provider for the clip URI as text and successfully paste the entire note.
//      */
//     [deprecated]
//     class CClipData {
//         /**
//          * Create a new clip.
//          *
//          * @param label Label to show to the user describing this clip.
//          * @param mimeTypes An array of MIME types this data is available as.
//          * @param item The contents of the first item in the clip.
//          */
//         constructor(
//             [in] ICharSequence* label,
//             [in] ArrayOf<String>* mimeTypes,
//             [in] IClipDataItem* item);

//         /**
//          * Create a new clip.
//          *
//          * @param description The ClipDescription describing the clip contents.
//          * @param item The contents of the first item in the clip.
//          */
//         constructor(
//             [in] IClipDescription* description,
//             [in] IClipDataItem* item);

//         /**
//          * Create a new clip that is a copy of another clip.  This does a deep-copy
//          * of all items in the clip.
//          *
//          * @param other The existing ClipData that is to be copied.
//          */
//         constructor(
//             [in] IClipData* other);

//         constructor();

//         interface IParcelable;
//         interface IClipData;
//     }

//     class CClipDataItem {
//         /**
//          * Create an Item consisting of a single block of (possibly styled) text.
//          */
//         constructor(
//             [in] ICharSequence* text);

//         /**
//          * Create an Item consisting of a single block of (possibly styled) text,
//          * with an alternative HTML formatted representation.  You <em>must</em>
//          * supply a plain text representation in addition to HTML text; coercion
//          * will not be done from HTML formated text into plain text.
//          */
//         constructor(
//             [in] ICharSequence* text,
//             [in] String htmlText);

//         /**
//          * Create an Item consisting of an arbitrary Intent.
//          */
//         constructor(
//             [in] IIntent* intent);

//         /**
//          * Create an Item consisting of an arbitrary URI.
//          */
//         constructor(
//             [in] IUri* uri);

//         /**
//          * Create a complex Item, containing multiple representations of
//          * text, Intent, and/or URI.
//          */
//         constructor(
//             [in] ICharSequence* text,
//             [in] IIntent* intent,
//             [in] IUri* uri);

//         /**
//          * Create a complex Item, containing multiple representations of
//          * text, HTML text, Intent, and/or URI.  If providing HTML text, you
//          * <em>must</em> supply a plain text representation as well; coercion
//          * will not be done from HTML formated text into plain text.
//          */
//         constructor(
//             [in] ICharSequence* text,
//             [in] String htmlText,
//             [in] IIntent* intent,
//             [in] IUri* uri);

//         interface IClipDataItem;
//     }

//     singleton class CClipDataHelper {
//         interface IClipDataHelper;
//     }

//     /**
//      * Meta-data describing the contents of a {@link ClipData}.  Provides enough
//      * information to know if you can handle the ClipData, but not the data
//      * itself.
//      *
//      * <div class="special reference">
//      * <h3>Developer Guides</h3>
//      * <p>For more information about using the clipboard framework, read the
//      * <a href="{@docRoot}guide/topics/clipboard/copy-paste.html">Copy and Paste</a>
//      * developer guide.</p>
//      * </div>
//      */
//     [deprecated]
//     class CClipDescription {
//         /**
//          * Create a new clip.
//          *
//          * @param label Label to show to the user describing this clip.
//          * @param mimeTypes An array of MIME types this data is available as.
//          */
//         constructor(
//             [in] ICharSequence* label,
//             [in] ArrayOf<String>* mimeTypes);

//         /**
//          * Create a copy of a ClipDescription.
//          */
//         constructor(
//             [in] IClipDescription* o);

//         constructor();

//         interface IClipDescription;
//         interface IParcelable;
//     }

//     singleton class CClipDescriptionHelper {
//         interface IClipDescriptionHelper;
//     }

//     /**
//      * Identifier for a specific application component
//      * ({@link android.app.Activity}, {@link android.app.Service},
//      * {@link android.content.BroadcastReceiver}, or
//      * {@link android.content.ContentProvider}) that is available.  Two
//      * pieces of information, encapsulated here, are required to identify
//      * a component: the package (a String) it exists in, and the class (a String)
//      * name inside of that package.
//      *
//      */
//     [local]
//     class CComponentName {
//         constructor();

//         /**
//          * Create a new component identifier.
//          *
//          * @param pkg The name of the package that the component exists in.  Can
//          * not be null.
//          * @param cls The name of the class inside of <var>pkg</var> that
//          * implements the component.  Can not be null.
//          */
//         constructor(
//             [in] String pkg,
//             [in] String cls);

//         /**
//          * Create a new component identifier from a Context and class name.
//          *
//          * @param pkg A Context for the package implementing the component,
//          * from which the actual package name will be retrieved.
//          * @param cls The name of the class inside of <var>pkg</var> that
//          * implements the component.
//          */
//         constructor(
//             [in] IContext* pkgCtx,
//             [in] String cls);

//         /**
//          * Create a new component identifier from a Context and Class object.
//          *
//          * @param pkg A Context for the package implementing the component, from
//          * which the actual package name will be retrieved.
//          * @param cls The Class object of the desired component, from which the
//          * actual class name will be retrieved.
//          */
//         constructor(
//             [in] IContext* pkg,
//             [in] IClassInfo* IClassInfo);

//         interface IComponentName;
//         interface IParcelable;
//     }

//     singleton class CComponentNameHelper {

//         interface IComponentNameHelper;
//     }

//     singleton class CContentProviderHelper {

//         interface IContentProviderHelper;
//     }

//     class CContentProviderTransport {
//         constructor(
//             [in] Handle32 owner);

//         interface IContentProviderTransport;
//         interface IBinder;
//     }

//     /**
//      * The public interface object used to interact with a {@link ContentProvider}. This is obtained by
//      * calling {@link ContentResolver#acquireContentProviderClient}. This object must be released
//      * using {@link #release} in order to indicate to the system that the {@link ContentProvider} is
//      * no longer needed and can be killed to free up resources.
//      *
//      * <p>Note that you should generally create a new ContentProviderClient instance
//      * for each thread that will be performing operations.  Unlike
//      * {@link ContentResolver}, the methods here such as {@link #query} and
//      * {@link #openFile} are not thread safe -- you must not call
//      * {@link #release()} on the ContentProviderClient those calls are made from
//      * until you are finished with the data they have returned.
//      */
//     class CContentProviderClient {
//         /**
//          * @hide
//          */
//         constructor(
//             [in] IContentResolver* resolver,
//             [in] IIContentProvider* provider,
//             [in] Boolean stable);

//         interface IContentProviderClient;
//     }

//     class CContentProviderOperation {
//         /**
//         * Creates a {@link ContentProviderOperation} by copying the contents of a
//         * {@link Builder}.
//         */
//         constructor(
//             [in] IContentProviderOperationBuilder* operationBuilder);

//         constructor();

//         interface IContentProviderOperation;
//         interface IParcelable;
//     }

//     class CContentProviderOperationBuilder {
//         constructor(
//             [in] Int32 type,
//             [in] IUri* uri);

//         interface IContentProviderOperationBuilder;
//     }

//     singleton class CContentProviderOperationHelper {

//         interface IContentProviderOperationHelper;
//     }

//     class CIntegerMapWrapper {
//         constructor(
//             [in] Int32 key,
//             [in] Int32 value);

//         interface IIntegerMapWrapper;
//     }

//     /**
//      * Contains the result of the application of a {@link ContentProviderOperation}. It is guaranteed
//      * to have exactly one of {@link #uri} or {@link #count} set.
//      */
//     class CContentProviderResult {
//         constructor(
//             [in] IUri* uri);

//         constructor(
//             [in] Int32 count);

//         constructor();

//         interface IContentProviderResult;
//         interface IParcelable;
//     }

//     singleton class CContentResolverHelper {

//         interface IContentResolverHelper;
//     }

//     class CContentResolverOpenResourceIdResult {

//         interface IContentResolverOpenResourceIdResult;
//     }

//     /**
//      * Utility methods useful for working with {@link android.net.Uri} objects
//      * that use the &quot;content&quot; (content://) scheme.
//      *
//      *<p>
//      *   Content URIs have the syntax
//      *</p>
//      *<p>
//      *   <code>content://<em>authority</em>/<em>path</em>/<em>id</em></code>
//      *</p>
//      *<dl>
//      *   <dt>
//      *       <code>content:</code>
//      *   </dt>
//      *   <dd>
//      *       The scheme portion of the URI. This is always set to {@link
//      *       android.content.ContentResolver#SCHEME_CONTENT ContentResolver.SCHEME_CONTENT} (value
//      *       <code>content://</code>).
//      *   </dd>
//      *   <dt>
//      *       <em>authority</em>
//      *   </dt>
//      *   <dd>
//      *       A string that identifies the entire content provider. All the content URIs for the provider
//      *       start with this string. To guarantee a unique authority, providers should consider
//      *       using an authority that is the same as the provider class' package identifier.
//      *   </dd>
//      *   <dt>
//      *       <em>path</em>
//      *   </dt>
//      *   <dd>
//      *       Zero or more segments, separated by a forward slash (<code>/</code>), that identify
//      *       some subset of the provider's data. Most providers use the path part to identify
//      *       individual tables. Individual segments in the path are often called
//      *       &quot;directories&quot; although they do not refer to file directories. The right-most
//      *       segment in a path is often called a &quot;twig&quot;
//      *   </dd>
//      *   <dt>
//      *       <em>id</em>
//      *   </dt>
//      *   <dd>
//      *       A unique numeric identifier for a single row in the subset of data identified by the
//      *       preceding path part. Most providers recognize content URIs that contain an id part
//      *       and give them special handling. A table that contains a column named <code>_ID</code>
//      *       often expects the id part to be a particular value for that column.
//      *   </dd>
//      *</dl>
//      *
//      */
//     singleton class CContentUris {

//         interface IContentUris;
//     }

//     /**
//      * This class is used to store a set of values that the {@link ContentResolver}
//      * can process.
//      */
//     class CContentValues {
//         /**
//          * Creates an empty set of values using the default initial size
//          */
//         constructor();

//         /**
//          * Creates an empty set of values using the given initial size
//          *
//          * @param size the initial size of the set of values
//          */
//         constructor(
//             [in] Int32 size);

//         /**
//          * Creates a set of values copied from the given set
//          *
//          * @param from the values to copy
//          */
//         constructor(
//             [in] IContentValues* from);

//         interface IContentValues;
//         interface IParcelable;
//     }

//     /**
//      * Proxying implementation of Context that simply delegates all of its calls to
//      * another Context.  Can be subclassed to modify behavior without changing
//      * the original Context.
//      */
//     [local]
//     class CContextWrapper {
//         constructor(
//             [in] IContext* ctx);

//         interface IContextWrapper;
//     }

//     /**
//      * An abstract class that performs asynchronous loading of data. While Loaders are active
//      * they should monitor the source of their data and deliver new results when the contents
//      * change.  See {@link android.app.LoaderManager} for more detail.
//      *
//      * <p><b>Note on threading:</b> Clients of loaders should as a rule perform
//      * any calls on to a Loader from the main thread of their process (that is,
//      * the thread the Activity callbacks and other things occur on).  Subclasses
//      * of Loader (such as {@link AsyncTaskLoader}) will often perform their work
//      * in a separate thread, but when delivering their results this too should
//      * be done on the main thread.</p>
//      *
//      * <p>Subclasses generally must implement at least {@link #onStartLoading()},
//      * {@link #onStopLoading()}, {@link #onForceLoad()}, and {@link #onReset()}.</p>
//      *
//      * <p>Most implementations should not derive directly from this class, but
//      * instead inherit from {@link AsyncTaskLoader}.</p>
//      *
//      * <div class="special reference">
//      * <h3>Developer Guides</h3>
//      * <p>For more information about using loaders, read the
//      * <a href="{@docRoot}guide/topics/fundamentals/loaders.html">Loaders</a> developer guide.</p>
//      * </div>
//      *
//      * @param <D> The result returned when the load is complete
//      */
// //    class CLoader {
// //        /**
// //         * Stores away the application context associated with context.
// //         * Since Loaders can be used across multiple activities it's dangerous to
// //         * store the context directly; always use {@link #getContext()} to retrieve
// //         * the Loader's Context, don't use the constructor argument directly.
// //         * The Context returned by {@link #getContext} is safe to use across
// //         * Activity instances.
// //         *
// //         * @param context used to retrieve the application context.
// //         */
// //        constructor(
// //            [in] IContext* ctx);
// //
// //        interface ILoader;
// //    }

//     /**
//      * An implementation of a ContentObserver that takes care of connecting
//      * it to the Loader to have the loader re-load its data when the observer
//      * is told it has changed.  You do not normally need to use this yourself;
//      * it is used for you by {@link CursorLoader} to take care of executing
//      * an update when the cursor's backing data changes.
//      */
// //    class CLoaderForceLoadContentObserver {
// //        constructor();
// //
// //        interface ILoaderForceLoadContentObserver;
// //    }

//     /**
//      * A loader that queries the {@link ContentResolver} and returns a {@link Cursor}.
//      * This class implements the {@link Loader} protocol in a standard way for
//      * querying cursors, building on {@link AsyncTaskLoader} to perform the cursor
//      * query on a background thread so that it does not block the application's UI.
//      *
//      * <p>A CursorLoader must be built with the full information for the query to
//      * perform, either through the
//      * {@link #CursorLoader(Context, Uri, String[], String, String[], String)} or
//      * creating an empty instance with {@link #CursorLoader(Context)} and filling
//      * in the desired paramters with {@link #setUri(Uri)}, {@link #setSelection(String)},
//      * {@link #setSelectionArgs(String[])}, {@link #setSortOrder(String)},
//      * and {@link #setProjection(String[])}.
//      */
// //    [deprecated]
// //    class CCursorLoader {
// //        /**
// //         * Creates an empty unspecified CursorLoader.  You must follow this with
// //         * calls to {@link #setUri(Uri)}, {@link #setSelection(String)}, etc
// //         * to specify the query to perform.
// //         */
// //        constructor(
// //            [in] IContext* ctx);
// //
// //        /**
// //         * Creates a fully-specified CursorLoader.  See
// //         * {@link ContentResolver#query(Uri, String[], String, String[], String)
// //         * ContentResolver.query()} for documentation on the meaning of the
// //         * parameters.  These will be passed as-is to that call.
// //         */
// //        constructor(
// //            [in] IContext* ctx,
// //            [in] IUri* uri,
// //            [in] ArrayOf<String>* projection,
// //            [in] String selection,
// //            [in] ArrayOf<String>* selectionArgs,
// //            [in] String sortOrder);
// //
// //        interface ICursorLoader;
// //    }

//     /**
//      * A representation of a item using ContentValues. It contains one top level ContentValue
//      * plus a collection of Uri, ContentValues tuples as subvalues. One example of its use
//      * is in Contacts, where the top level ContentValue contains the columns from the RawContacts
//      * table and the subvalues contain a ContentValues object for each row from the Data table that
//      * corresponds to that RawContact. The uri refers to the Data table uri for each row.
//      */
//     class CEntity {
//         constructor(
//             [in] IContentValues* values);

//         interface IEntity;
//     }

//     class CEntityNamedContentValues {
//         constructor(
//             [in] IUri* uri,
//             [in] IContentValues* values);

//         interface IEntityNamedContentValues;
//     }

//     *
//      * An intent is an abstract description of an operation to be performed.  It
//      * can be used with {@link Context#startActivity(Intent) startActivity} to
//      * launch an {@link android.app.Activity},
//      * {@link android.content.Context#sendBroadcast(Intent) broadcastIntent} to
//      * send it to any interested {@link BroadcastReceiver BroadcastReceiver} components,
//      * and {@link android.content.Context#startService} or
//      * {@link android.content.Context#bindService} to communicate with a
//      * background {@link android.app.Service}.
//      *
//      * <p>An Intent provides a facility for performing late runtime binding between the code in
//      * different applications. Its most significant use is in the launching of activities, where it
//      * can be thought of as the glue between activities. It is basically a passive data structure
//      * holding an abstract description of an action to be performed.</p>
//      *
//      * <div class="special reference">
//      * <h3>Developer Guides</h3>
//      * <p>For information about how to create and resolve intents, read the
//      * <a href="{@docRoot}guide/topics/intents/intents-filters.html">Intents and Intent Filters</a>
//      * developer guide.</p>
//      * </div>
//      *
//      * <a name="IntentStructure"></a>
//      * <h3>Intent Structure</h3>
//      * <p>The primary pieces of information in an intent are:</p>
//      *
//      * <ul>
//      *   <li> <p><b>action</b> -- The general action to be performed, such as
//      *     {@link #ACTION_VIEW}, {@link #ACTION_EDIT}, {@link #ACTION_MAIN},
//      *     etc.</p>
//      *   </li>
//      *   <li> <p><b>data</b> -- The data to operate on, such as a person record
//      *     in the contacts database, expressed as a {@link android.net.Uri}.</p>
//      *   </li>
//      * </ul>
//      *
//      *
//      * <p>Some examples of action/data pairs are:</p>
//      *
//      * <ul>
//      *   <li> <p><b>{@link #ACTION_VIEW} <i>content://contacts/people/1</i></b> -- Display
//      *     information about the person whose identifier is "1".</p>
//      *   </li>
//      *   <li> <p><b>{@link #ACTION_DIAL} <i>content://contacts/people/1</i></b> -- Display
//      *     the phone dialer with the person filled in.</p>
//      *   </li>
//      *   <li> <p><b>{@link #ACTION_VIEW} <i>tel:123</i></b> -- Display
//      *     the phone dialer with the given number filled in.  Note how the
//      *     VIEW action does what what is considered the most reasonable thing for
//      *     a particular URI.</p>
//      *   </li>
//      *   <li> <p><b>{@link #ACTION_DIAL} <i>tel:123</i></b> -- Display
//      *     the phone dialer with the given number filled in.</p>
//      *   </li>
//      *   <li> <p><b>{@link #ACTION_EDIT} <i>content://contacts/people/1</i></b> -- Edit
//      *     information about the person whose identifier is "1".</p>
//      *   </li>
//      *   <li> <p><b>{@link #ACTION_VIEW} <i>content://contacts/people/</i></b> -- Display
//      *     a list of people, which the user can browse through.  This example is a
//      *     typical top-level entry into the Contacts application, showing you the
//      *     list of people. Selecting a particular person to view would result in a
//      *     new intent { <b>{@link #ACTION_VIEW} <i>content://contacts/N</i></b> }
//      *     being used to start an activity to display that person.</p>
//      *   </li>
//      * </ul>
//      *
//      * <p>In addition to these primary attributes, there are a number of secondary
//      * attributes that you can also include with an intent:</p>
//      *
//      * <ul>
//      *     <li> <p><b>category</b> -- Gives additional information about the action
//      *         to execute.  For example, {@link #CATEGORY_LAUNCHER} means it should
//      *         appear in the Launcher as a top-level application, while
//      *         {@link #CATEGORY_ALTERNATIVE} means it should be included in a list
//      *         of alternative actions the user can perform on a piece of data.</p>
//      *     <li> <p><b>type</b> -- Specifies an explicit type (a MIME type) of the
//      *         intent data.  Normally the type is inferred from the data itself.
//      *         By setting this attribute, you disable that evaluation and force
//      *         an explicit type.</p>
//      *     <li> <p><b>component</b> -- Specifies an explicit name of a component
//      *         class to use for the intent.  Normally this is determined by looking
//      *         at the other information in the intent (the action, data/type, and
//      *         categories) and matching that with a component that can handle it.
//      *         If this attribute is set then none of the evaluation is performed,
//      *         and this component is used exactly as is.  By specifying this attribute,
//      *         all of the other Intent attributes become optional.</p>
//      *     <li> <p><b>extras</b> -- This is a {@link Bundle} of any additional information.
//      *         This can be used to provide extended information to the component.
//      *         For example, if we have a action to send an e-mail message, we could
//      *         also include extra pieces of data here to supply a subject, body,
//      *         etc.</p>
//      * </ul>
//      *
//      * <p>Here are some examples of other operations you can specify as intents
//      * using these additional parameters:</p>
//      *
//      * <ul>
//      *   <li> <p><b>{@link #ACTION_MAIN} with category {@link #CATEGORY_HOME}</b> --
//      *     Launch the home screen.</p>
//      *   </li>
//      *   <li> <p><b>{@link #ACTION_GET_CONTENT} with MIME type
//      *     <i>{@link android.provider.Contacts.Phones#CONTENT_URI
//      *     vnd.android.cursor.item/phone}</i></b>
//      *     -- Display the list of people's phone numbers, allowing the user to
//      *     browse through them and pick one and return it to the parent activity.</p>
//      *   </li>
//      *   <li> <p><b>{@link #ACTION_GET_CONTENT} with MIME type
//      *     <i>*{@literal /}*</i> and category {@link #CATEGORY_OPENABLE}</b>
//      *     -- Display all pickers for data that can be opened with
//      *     {@link ContentResolver#openInputStream(Uri) ContentResolver.openInputStream()},
//      *     allowing the user to pick one of them and then some data inside of it
//      *     and returning the resulting URI to the caller.  This can be used,
//      *     for example, in an e-mail application to allow the user to pick some
//      *     data to include as an attachment.</p>
//      *   </li>
//      * </ul>
//      *
//      * <p>There are a variety of standard Intent action and category constants
//      * defined in the Intent class, but applications can also define their own.
//      * These strings use java style scoping, to ensure they are unique -- for
//      * example, the standard {@link #ACTION_VIEW} is called
//      * "android.intent.action.VIEW".</p>
//      *
//      * <p>Put together, the set of actions, data types, categories, and extra data
//      * defines a language for the system allowing for the expression of phrases
//      * such as "call john smith's cell".  As applications are added to the system,
//      * they can extend this language by adding new actions, types, and categories, or
//      * they can modify the behavior of existing phrases by supplying their own
//      * activities that handle them.</p>
//      *
//      * <a name="IntentResolution"></a>
//      * <h3>Intent Resolution</h3>
//      *
//      * <p>There are two primary forms of intents you will use.
//      *
//      * <ul>
//      *     <li> <p><b>Explicit Intents</b> have specified a component (via
//      *     {@link #setComponent} or {@link #setClass}), which provides the exact
//      *     class to be run.  Often these will not include any other information,
//      *     simply being a way for an application to launch various internal
//      *     activities it has as the user interacts with the application.
//      *
//      *     <li> <p><b>Implicit Intents</b> have not specified a component;
//      *     instead, they must include enough information for the system to
//      *     determine which of the available components is best to run for that
//      *     intent.
//      * </ul>
//      *
//      * <p>When using implicit intents, given such an arbitrary intent we need to
//      * know what to do with it. This is handled by the process of <em>Intent
//      * resolution</em>, which maps an Intent to an {@link android.app.Activity},
//      * {@link BroadcastReceiver}, or {@link android.app.Service} (or sometimes two or
//      * more activities/receivers) that can handle it.</p>
//      *
//      * <p>The intent resolution mechanism basically revolves around matching an
//      * Intent against all of the &lt;intent-filter&gt; descriptions in the
//      * installed application packages.  (Plus, in the case of broadcasts, any {@link BroadcastReceiver}
//      * objects explicitly registered with {@link Context#registerReceiver}.)  More
//      * details on this can be found in the documentation on the {@link
//      * IntentFilter} class.</p>
//      *
//      * <p>There are three pieces of information in the Intent that are used for
//      * resolution: the action, type, and category.  Using this information, a query
//      * is done on the {@link PackageManager} for a component that can handle the
//      * intent. The appropriate component is determined based on the intent
//      * information supplied in the <code>AndroidManifest.xml</code> file as
//      * follows:</p>
//      *
//      * <ul>
//      *     <li> <p>The <b>action</b>, if given, must be listed by the component as
//      *         one it handles.</p>
//      *     <li> <p>The <b>type</b> is retrieved from the Intent's data, if not
//      *         already supplied in the Intent.  Like the action, if a type is
//      *         included in the intent (either explicitly or implicitly in its
//      *         data), then this must be listed by the component as one it handles.</p>
//      *     <li> For data that is not a <code>content:</code> URI and where no explicit
//      *         type is included in the Intent, instead the <b>scheme</b> of the
//      *         intent data (such as <code>http:</code> or <code>mailto:</code>) is
//      *         considered. Again like the action, if we are matching a scheme it
//      *         must be listed by the component as one it can handle.
//      *     <li> <p>The <b>categories</b>, if supplied, must <em>all</em> be listed
//      *         by the activity as categories it handles.  That is, if you include
//      *         the categories {@link #CATEGORY_LAUNCHER} and
//      *         {@link #CATEGORY_ALTERNATIVE}, then you will only resolve to components
//      *         with an intent that lists <em>both</em> of those categories.
//      *         Activities will very often need to support the
//      *         {@link #CATEGORY_DEFAULT} so that they can be found by
//      *         {@link Context#startActivity Context.startActivity()}.</p>
//      * </ul>
//      *
//      * <p>For example, consider the Note Pad sample application that
//      * allows user to browse through a list of notes data and view details about
//      * individual items.  Text in italics indicate places were you would replace a
//      * name with one specific to your own package.</p>
//      *
//      * <pre> &lt;manifest xmlns:android="http://schemas.android.com/apk/res/android"
//      *       package="<i>com.android.notepad</i>"&gt;
//      *     &lt;application android:icon="@drawable/app_notes"
//      *             android:label="@string/app_name"&gt;
//      *
//      *         &lt;provider class=".NotePadProvider"
//      *                 android:authorities="<i>com.google.provider.NotePad</i>" /&gt;
//      *
//      *         &lt;activity class=".NotesList" android:label="@string/title_notes_list"&gt;
//      *             &lt;intent-filter&gt;
//      *                 &lt;action android:name="android.intent.action.MAIN" /&gt;
//      *                 &lt;category android:name="android.intent.category.LAUNCHER" /&gt;
//      *             &lt;/intent-filter&gt;
//      *             &lt;intent-filter&gt;
//      *                 &lt;action android:name="android.intent.action.VIEW" /&gt;
//      *                 &lt;action android:name="android.intent.action.EDIT" /&gt;
//      *                 &lt;action android:name="android.intent.action.PICK" /&gt;
//      *                 &lt;category android:name="android.intent.category.DEFAULT" /&gt;
//      *                 &lt;data android:mimeType="vnd.android.cursor.dir/<i>vnd.google.note</i>" /&gt;
//      *             &lt;/intent-filter&gt;
//      *             &lt;intent-filter&gt;
//      *                 &lt;action android:name="android.intent.action.GET_CONTENT" /&gt;
//      *                 &lt;category android:name="android.intent.category.DEFAULT" /&gt;
//      *                 &lt;data android:mimeType="vnd.android.cursor.item/<i>vnd.google.note</i>" /&gt;
//      *             &lt;/intent-filter&gt;
//      *         &lt;/activity&gt;
//      *
//      *         &lt;activity class=".NoteEditor" android:label="@string/title_note"&gt;
//      *             &lt;intent-filter android:label="@string/resolve_edit"&gt;
//      *                 &lt;action android:name="android.intent.action.VIEW" /&gt;
//      *                 &lt;action android:name="android.intent.action.EDIT" /&gt;
//      *                 &lt;category android:name="android.intent.category.DEFAULT" /&gt;
//      *                 &lt;data android:mimeType="vnd.android.cursor.item/<i>vnd.google.note</i>" /&gt;
//      *             &lt;/intent-filter&gt;
//      *
//      *             &lt;intent-filter&gt;
//      *                 &lt;action android:name="android.intent.action.INSERT" /&gt;
//      *                 &lt;category android:name="android.intent.category.DEFAULT" /&gt;
//      *                 &lt;data android:mimeType="vnd.android.cursor.dir/<i>vnd.google.note</i>" /&gt;
//      *             &lt;/intent-filter&gt;
//      *
//      *         &lt;/activity&gt;
//      *
//      *         &lt;activity class=".TitleEditor" android:label="@string/title_edit_title"
//      *                 android:theme="@android:style/Theme.Dialog"&gt;
//      *             &lt;intent-filter android:label="@string/resolve_title"&gt;
//      *                 &lt;action android:name="<i>com.android.notepad.action.EDIT_TITLE</i>" /&gt;
//      *                 &lt;category android:name="android.intent.category.DEFAULT" /&gt;
//      *                 &lt;category android:name="android.intent.category.ALTERNATIVE" /&gt;
//      *                 &lt;category android:name="android.intent.category.SELECTED_ALTERNATIVE" /&gt;
//      *                 &lt;data android:mimeType="vnd.android.cursor.item/<i>vnd.google.note</i>" /&gt;
//      *             &lt;/intent-filter&gt;
//      *         &lt;/activity&gt;
//      *
//      *     &lt;/application&gt;
//      * &lt;/manifest&gt;</pre>
//      *
//      * <p>The first activity,
//      * <code>com.android.notepad.NotesList</code>, serves as our main
//      * entry into the app.  It can do three things as described by its three intent
//      * templates:
//      * <ol>
//      * <li><pre>
//      * &lt;intent-filter&gt;
//      *     &lt;action android:name="{@link #ACTION_MAIN android.intent.action.MAIN}" /&gt;
//      *     &lt;category android:name="{@link #CATEGORY_LAUNCHER android.intent.category.LAUNCHER}" /&gt;
//      * &lt;/intent-filter&gt;</pre>
//      * <p>This provides a top-level entry into the NotePad application: the standard
//      * MAIN action is a main entry point (not requiring any other information in
//      * the Intent), and the LAUNCHER category says that this entry point should be
//      * listed in the application launcher.</p>
//      * <li><pre>
//      * &lt;intent-filter&gt;
//      *     &lt;action android:name="{@link #ACTION_VIEW android.intent.action.VIEW}" /&gt;
//      *     &lt;action android:name="{@link #ACTION_EDIT android.intent.action.EDIT}" /&gt;
//      *     &lt;action android:name="{@link #ACTION_PICK android.intent.action.PICK}" /&gt;
//      *     &lt;category android:name="{@link #CATEGORY_DEFAULT android.intent.category.DEFAULT}" /&gt;
//      *     &lt;data mimeType:name="vnd.android.cursor.dir/<i>vnd.google.note</i>" /&gt;
//      * &lt;/intent-filter&gt;</pre>
//      * <p>This declares the things that the activity can do on a directory of
//      * notes.  The type being supported is given with the &lt;type&gt; tag, where
//      * <code>vnd.android.cursor.dir/vnd.google.note</code> is a URI from which
//      * a Cursor of zero or more items (<code>vnd.android.cursor.dir</code>) can
//      * be retrieved which holds our note pad data (<code>vnd.google.note</code>).
//      * The activity allows the user to view or edit the directory of data (via
//      * the VIEW and EDIT actions), or to pick a particular note and return it
//      * to the caller (via the PICK action).  Note also the DEFAULT category
//      * supplied here: this is <em>required</em> for the
//      * {@link Context#startActivity Context.startActivity} method to resolve your
//      * activity when its component name is not explicitly specified.</p>
//      * <li><pre>
//      * &lt;intent-filter&gt;
//      *     &lt;action android:name="{@link #ACTION_GET_CONTENT android.intent.action.GET_CONTENT}" /&gt;
//      *     &lt;category android:name="{@link #CATEGORY_DEFAULT android.intent.category.DEFAULT}" /&gt;
//      *     &lt;data android:mimeType="vnd.android.cursor.item/<i>vnd.google.note</i>" /&gt;
//      * &lt;/intent-filter&gt;</pre>
//      * <p>This filter describes the ability return to the caller a note selected by
//      * the user without needing to know where it came from.  The data type
//      * <code>vnd.android.cursor.item/vnd.google.note</code> is a URI from which
//      * a Cursor of exactly one (<code>vnd.android.cursor.item</code>) item can
//      * be retrieved which contains our note pad data (<code>vnd.google.note</code>).
//      * The GET_CONTENT action is similar to the PICK action, where the activity
//      * will return to its caller a piece of data selected by the user.  Here,
//      * however, the caller specifies the type of data they desire instead of
//      * the type of data the user will be picking from.</p>
//      * </ol>
//      *
//      * <p>Given these capabilities, the following intents will resolve to the
//      * NotesList activity:</p>
//      *
//      * <ul>
//      *     <li> <p><b>{ action=android.app.action.MAIN }</b> matches all of the
//      *         activities that can be used as top-level entry points into an
//      *         application.</p>
//      *     <li> <p><b>{ action=android.app.action.MAIN,
//      *         category=android.app.category.LAUNCHER }</b> is the actual intent
//      *         used by the Launcher to populate its top-level list.</p>
//      *     <li> <p><b>{ action=android.intent.action.VIEW
//      *          data=content://com.google.provider.NotePad/notes }</b>
//      *         displays a list of all the notes under
//      *         "content://com.google.provider.NotePad/notes", which
//      *         the user can browse through and see the details on.</p>
//      *     <li> <p><b>{ action=android.app.action.PICK
//      *          data=content://com.google.provider.NotePad/notes }</b>
//      *         provides a list of the notes under
//      *         "content://com.google.provider.NotePad/notes", from which
//      *         the user can pick a note whose data URL is returned back to the caller.</p>
//      *     <li> <p><b>{ action=android.app.action.GET_CONTENT
//      *          type=vnd.android.cursor.item/vnd.google.note }</b>
//      *         is similar to the pick action, but allows the caller to specify the
//      *         kind of data they want back so that the system can find the appropriate
//      *         activity to pick something of that data type.</p>
//      * </ul>
//      *
//      * <p>The second activity,
//      * <code>com.android.notepad.NoteEditor</code>, shows the user a single
//      * note entry and allows them to edit it.  It can do two things as described
//      * by its two intent templates:
//      * <ol>
//      * <li><pre>
//      * &lt;intent-filter android:label="@string/resolve_edit"&gt;
//      *     &lt;action android:name="{@link #ACTION_VIEW android.intent.action.VIEW}" /&gt;
//      *     &lt;action android:name="{@link #ACTION_EDIT android.intent.action.EDIT}" /&gt;
//      *     &lt;category android:name="{@link #CATEGORY_DEFAULT android.intent.category.DEFAULT}" /&gt;
//      *     &lt;data android:mimeType="vnd.android.cursor.item/<i>vnd.google.note</i>" /&gt;
//      * &lt;/intent-filter&gt;</pre>
//      * <p>The first, primary, purpose of this activity is to let the user interact
//      * with a single note, as decribed by the MIME type
//      * <code>vnd.android.cursor.item/vnd.google.note</code>.  The activity can
//      * either VIEW a note or allow the user to EDIT it.  Again we support the
//      * DEFAULT category to allow the activity to be launched without explicitly
//      * specifying its component.</p>
//      * <li><pre>
//      * &lt;intent-filter&gt;
//      *     &lt;action android:name="{@link #ACTION_INSERT android.intent.action.INSERT}" /&gt;
//      *     &lt;category android:name="{@link #CATEGORY_DEFAULT android.intent.category.DEFAULT}" /&gt;
//      *     &lt;data android:mimeType="vnd.android.cursor.dir/<i>vnd.google.note</i>" /&gt;
//      * &lt;/intent-filter&gt;</pre>
//      * <p>The secondary use of this activity is to insert a new note entry into
//      * an existing directory of notes.  This is used when the user creates a new
//      * note: the INSERT action is executed on the directory of notes, causing
//      * this activity to run and have the user create the new note data which
//      * it then adds to the content provider.</p>
//      * </ol>
//      *
//      * <p>Given these capabilities, the following intents will resolve to the
//      * NoteEditor activity:</p>
//      *
//      * <ul>
//      *     <li> <p><b>{ action=android.intent.action.VIEW
//      *          data=content://com.google.provider.NotePad/notes/<var>{ID}</var> }</b>
//      *         shows the user the content of note <var>{ID}</var>.</p>
//      *     <li> <p><b>{ action=android.app.action.EDIT
//      *          data=content://com.google.provider.NotePad/notes/<var>{ID}</var> }</b>
//      *         allows the user to edit the content of note <var>{ID}</var>.</p>
//      *     <li> <p><b>{ action=android.app.action.INSERT
//      *          data=content://com.google.provider.NotePad/notes }</b>
//      *         creates a new, empty note in the notes list at
//      *         "content://com.google.provider.NotePad/notes"
//      *         and allows the user to edit it.  If they keep their changes, the URI
//      *         of the newly created note is returned to the caller.</p>
//      * </ul>
//      *
//      * <p>The last activity,
//      * <code>com.android.notepad.TitleEditor</code>, allows the user to
//      * edit the title of a note.  This could be implemented as a class that the
//      * application directly invokes (by explicitly setting its component in
//      * the Intent), but here we show a way you can publish alternative
//      * operations on existing data:</p>
//      *
//      * <pre>
//      * &lt;intent-filter android:label="@string/resolve_title"&gt;
//      *     &lt;action android:name="<i>com.android.notepad.action.EDIT_TITLE</i>" /&gt;
//      *     &lt;category android:name="{@link #CATEGORY_DEFAULT android.intent.category.DEFAULT}" /&gt;
//      *     &lt;category android:name="{@link #CATEGORY_ALTERNATIVE android.intent.category.ALTERNATIVE}" /&gt;
//      *     &lt;category android:name="{@link #CATEGORY_SELECTED_ALTERNATIVE android.intent.category.SELECTED_ALTERNATIVE}" /&gt;
//      *     &lt;data android:mimeType="vnd.android.cursor.item/<i>vnd.google.note</i>" /&gt;
//      * &lt;/intent-filter&gt;</pre>
//      *
//      * <p>In the single intent template here, we
//      * have created our own private action called
//      * <code>com.android.notepad.action.EDIT_TITLE</code> which means to
//      * edit the title of a note.  It must be invoked on a specific note
//      * (data type <code>vnd.android.cursor.item/vnd.google.note</code>) like the previous
//      * view and edit actions, but here displays and edits the title contained
//      * in the note data.
//      *
//      * <p>In addition to supporting the default category as usual, our title editor
//      * also supports two other standard categories: ALTERNATIVE and
//      * SELECTED_ALTERNATIVE.  Implementing
//      * these categories allows others to find the special action it provides
//      * without directly knowing about it, through the
//      * {@link android.content.pm.PackageManager#queryIntentActivityOptions} method, or
//      * more often to build dynamic menu items with
//      * {@link android.view.Menu#addIntentOptions}.  Note that in the intent
//      * template here was also supply an explicit name for the template
//      * (via <code>android:label="@string/resolve_title"</code>) to better control
//      * what the user sees when presented with this activity as an alternative
//      * action to the data they are viewing.
//      *
//      * <p>Given these capabilities, the following intent will resolve to the
//      * TitleEditor activity:</p>
//      *
//      * <ul>
//      *     <li> <p><b>{ action=com.android.notepad.action.EDIT_TITLE
//      *          data=content://com.google.provider.NotePad/notes/<var>{ID}</var> }</b>
//      *         displays and allows the user to edit the title associated
//      *         with note <var>{ID}</var>.</p>
//      * </ul>
//      *
//      * <h3>Standard Activity Actions</h3>
//      *
//      * <p>These are the current standard actions that Intent defines for launching
//      * activities (usually through {@link Context#startActivity}.  The most
//      * important, and by far most frequently used, are {@link #ACTION_MAIN} and
//      * {@link #ACTION_EDIT}.
//      *
//      * <ul>
//      *     <li> {@link #ACTION_MAIN}
//      *     <li> {@link #ACTION_VIEW}
//      *     <li> {@link #ACTION_ATTACH_DATA}
//      *     <li> {@link #ACTION_EDIT}
//      *     <li> {@link #ACTION_PICK}
//      *     <li> {@link #ACTION_CHOOSER}
//      *     <li> {@link #ACTION_GET_CONTENT}
//      *     <li> {@link #ACTION_DIAL}
//      *     <li> {@link #ACTION_CALL}
//      *     <li> {@link #ACTION_SEND}
//      *     <li> {@link #ACTION_SENDTO}
//      *     <li> {@link #ACTION_ANSWER}
//      *     <li> {@link #ACTION_INSERT}
//      *     <li> {@link #ACTION_DELETE}
//      *     <li> {@link #ACTION_RUN}
//      *     <li> {@link #ACTION_SYNC}
//      *     <li> {@link #ACTION_PICK_ACTIVITY}
//      *     <li> {@link #ACTION_SEARCH}
//      *     <li> {@link #ACTION_WEB_SEARCH}
//      *     <li> {@link #ACTION_FACTORY_TEST}
//      * </ul>
//      *
//      * <h3>Standard Broadcast Actions</h3>
//      *
//      * <p>These are the current standard actions that Intent defines for receiving
//      * broadcasts (usually through {@link Context#registerReceiver} or a
//      * &lt;receiver&gt; tag in a manifest).
//      *
//      * <ul>
//      *     <li> {@link #ACTION_TIME_TICK}
//      *     <li> {@link #ACTION_TIME_CHANGED}
//      *     <li> {@link #ACTION_TIMEZONE_CHANGED}
//      *     <li> {@link #ACTION_BOOT_COMPLETED}
//      *     <li> {@link #ACTION_PACKAGE_ADDED}
//      *     <li> {@link #ACTION_PACKAGE_CHANGED}
//      *     <li> {@link #ACTION_PACKAGE_REMOVED}
//      *     <li> {@link #ACTION_PACKAGE_RESTARTED}
//      *     <li> {@link #ACTION_PACKAGE_DATA_CLEARED}
//      *     <li> {@link #ACTION_UID_REMOVED}
//      *     <li> {@link #ACTION_BATTERY_CHANGED}
//      *     <li> {@link #ACTION_POWER_CONNECTED}
//      *     <li> {@link #ACTION_POWER_DISCONNECTED}
//      *     <li> {@link #ACTION_SHUTDOWN}
//      * </ul>
//      *
//      * <h3>Standard Categories</h3>
//      *
//      * <p>These are the current standard categories that can be used to further
//      * clarify an Intent via {@link #addCategory}.
//      *
//      * <ul>
//      *     <li> {@link #CATEGORY_DEFAULT}
//      *     <li> {@link #CATEGORY_BROWSABLE}
//      *     <li> {@link #CATEGORY_TAB}
//      *     <li> {@link #CATEGORY_ALTERNATIVE}
//      *     <li> {@link #CATEGORY_SELECTED_ALTERNATIVE}
//      *     <li> {@link #CATEGORY_LAUNCHER}
//      *     <li> {@link #CATEGORY_INFO}
//      *     <li> {@link #CATEGORY_HOME}
//      *     <li> {@link #CATEGORY_PREFERENCE}
//      *     <li> {@link #CATEGORY_TEST}
//      *     <li> {@link #CATEGORY_CAR_DOCK}
//      *     <li> {@link #CATEGORY_DESK_DOCK}
//      *     <li> {@link #CATEGORY_LE_DESK_DOCK}
//      *     <li> {@link #CATEGORY_HE_DESK_DOCK}
//      *     <li> {@link #CATEGORY_CAR_MODE}
//      *     <li> {@link #CATEGORY_APP_MARKET}
//      * </ul>
//      *
//      * <h3>Standard Extra Data</h3>
//      *
//      * <p>These are the current standard fields that can be used as extra data via
//      * {@link #putExtra}.
//      *
//      * <ul>
//      *     <li> {@link #EXTRA_ALARM_COUNT}
//      *     <li> {@link #EXTRA_BCC}
//      *     <li> {@link #EXTRA_CC}
//      *     <li> {@link #EXTRA_CHANGED_COMPONENT_NAME}
//      *     <li> {@link #EXTRA_DATA_REMOVED}
//      *     <li> {@link #EXTRA_DOCK_STATE}
//      *     <li> {@link #EXTRA_DOCK_STATE_HE_DESK}
//      *     <li> {@link #EXTRA_DOCK_STATE_LE_DESK}
//      *     <li> {@link #EXTRA_DOCK_STATE_CAR}
//      *     <li> {@link #EXTRA_DOCK_STATE_DESK}
//      *     <li> {@link #EXTRA_DOCK_STATE_UNDOCKED}
//      *     <li> {@link #EXTRA_DONT_KILL_APP}
//      *     <li> {@link #EXTRA_EMAIL}
//      *     <li> {@link #EXTRA_INITIAL_INTENTS}
//      *     <li> {@link #EXTRA_INTENT}
//      *     <li> {@link #EXTRA_KEY_EVENT}
//      *     <li> {@link #EXTRA_ORIGINATING_URI}
//      *     <li> {@link #EXTRA_PHONE_NUMBER}
//      *     <li> {@link #EXTRA_REFERRER}
//      *     <li> {@link #EXTRA_REMOTE_INTENT_TOKEN}
//      *     <li> {@link #EXTRA_REPLACING}
//      *     <li> {@link #EXTRA_SHORTCUT_ICON}
//      *     <li> {@link #EXTRA_SHORTCUT_ICON_RESOURCE}
//      *     <li> {@link #EXTRA_SHORTCUT_INTENT}
//      *     <li> {@link #EXTRA_STREAM}
//      *     <li> {@link #EXTRA_SHORTCUT_NAME}
//      *     <li> {@link #EXTRA_SUBJECT}
//      *     <li> {@link #EXTRA_TEMPLATE}
//      *     <li> {@link #EXTRA_TEXT}
//      *     <li> {@link #EXTRA_TITLE}
//      *     <li> {@link #EXTRA_UID}
//      * </ul>
//      *
//      * <h3>Flags</h3>
//      *
//      * <p>These are the possible flags that can be used in the Intent via
//      * {@link #setFlags} and {@link #addFlags}.  See {@link #setFlags} for a list
//      * of all possible flags.

//     [local]
//     class CIntent {
//         /**
//          * Create an empty intent.
//          */
//         constructor();

//         /**
//          * Copy constructor.
//          */
//         constructor(
//             [in] IIntent* intent);

//         constructor(
//             [in] IIntent* intent,
//             [in] Boolean all);

//         /**
//          * Create an intent with a given action.  All other fields (data, type,
//          * class) are null.  Note that the action <em>must</em> be in a
//          * namespace because Intents are used globally in the system -- for
//          * example the system VIEW action is android.intent.action.VIEW; an
//          * application's custom action would be something like
//          * com.google.app.myapp.CUSTOM_ACTION.
//          *
//          * @param action The Intent action, such as ACTION_VIEW.
//          */
//         constructor(
//             [in] String action);

//         /**
//          * Create an intent with a given action and for a given data url.  Note
//          * that the action <em>must</em> be in a namespace because Intents are
//          * used globally in the system -- for example the system VIEW action is
//          * android.intent.action.VIEW; an application's custom action would be
//          * something like com.google.app.myapp.CUSTOM_ACTION.
//          *
//          * <p><em>Note: scheme and host name matching in the Android framework is
//          * case-sensitive, unlike the formal RFC.  As a result,
//          * you should always ensure that you write your Uri with these elements
//          * using lower case letters, and normalize any Uris you receive from
//          * outside of Android to ensure the scheme and host is lower case.</em></p>
//          *
//          * @param action The Intent action, such as ACTION_VIEW.
//          * @param uri The Intent data URI.
//          */
//         constructor(
//             [in] String action,
//             [in] IUri* uri);

//         /**
//          * Create an intent for a specific component.  All other fields (action, data,
//          * type, class) are null, though they can be modified later with explicit
//          * calls.  This provides a convenient way to create an intent that is
//          * intended to execute a hard-coded class name, rather than relying on the
//          * system to find an appropriate class for you; see {@link #setComponent}
//          * for more information on the repercussions of this.
//          *
//          * @param packageContext A Context of the application package implementing
//          * this class.
//          * @param cls The component class that is to be used for the intent.
//          *
//          * @see #setClass
//          * @see #setComponent
//          * @see #Intent(String, android.net.Uri , Context, Class)
//          */
//         constructor(
//             [in] IContext* packageContext,
//             [in] ClassID clsId);

//         /**
//          * Create an intent for a specific component with a specified action and data.
//          * This is equivalent using {@link #Intent(String, android.net.Uri)} to
//          * construct the Intent and then calling {@link #setClass} to set its
//          * class.
//          *
//          * <p><em>Note: scheme and host name matching in the Android framework is
//          * case-sensitive, unlike the formal RFC.  As a result,
//          * you should always ensure that you write your Uri with these elements
//          * using lower case letters, and normalize any Uris you receive from
//          * outside of Android to ensure the scheme and host is lower case.</em></p>
//          *
//          * @param action The Intent action, such as ACTION_VIEW.
//          * @param uri The Intent data URI.
//          * @param packageContext A Context of the application package implementing
//          * this class.
//          * @param cls The component class that is to be used for the intent.
//          *
//          * @see #Intent(String, android.net.Uri)
//          * @see #Intent(Context, Class)
//          * @see #setClass
//          * @see #setComponent
//          */
//         constructor(
//             [in] String action,
//             [in] IUri* uri,
//             [in] IContext* packageContext,
//             [in] IClassInfo* clsinfo);

//         interface IIntent;
//         interface IParcelable;
//     }

//     singleton class CIntentHelper {

//         interface IIntentHelper;
//     }

//     /**
//      * Represents a shortcut/live folder icon resource.
//      *
//      * @see Intent#ACTION_CREATE_SHORTCUT
//      * @see Intent#EXTRA_SHORTCUT_ICON_RESOURCE
//      * @see android.provider.LiveFolders#ACTION_CREATE_LIVE_FOLDER
//      * @see android.provider.LiveFolders#EXTRA_LIVE_FOLDER_ICON
//      */
//     class CIntentShortcutIconResource {
//         constructor();

//         interface IIntentShortcutIconResource;
//         interface IParcelable;
//     }

//     singleton class CIntentShortcutIconResourceHelper {

//         interface IIntentShortcutIconResourceHelper;
//     }

//     /**
//      * Wrapper class holding an Intent and implementing comparisons on it for
//      * the purpose of filtering.  The class implements its
//      * {@link #equals equals()} and {@link #hashCode hashCode()} methods as
//      * simple calls to {@link Intent#filterEquals(Intent)}  filterEquals()} and
//      * {@link android.content.Intent#filterHashCode()}  filterHashCode()}
//      * on the wrapped Intent.
//      */
//     class CIntentFilterComparison {
//         constructor(
//             [in] IIntent* intent);

//         interface IIntentFilterComparison;
//     }

//     /**
//      * Structured description of Intent values to be matched.  An IntentFilter can
//      * match against actions, categories, and data (either via its type, scheme,
//      * and/or path) in an Intent.  It also includes a "priority" value which is
//      * used to order multiple matching filters.
//      *
//      * <p>IntentFilter objects are often created in XML as part of a package's
//      * {@link android.R.styleable#AndroidManifest AndroidManifest.xml} file,
//      * using {@link android.R.styleable#AndroidManifestIntentFilter intent-filter}
//      * tags.
//      *
//      * <p>There are three Intent characteristics you can filter on: the
//      * <em>action</em>, <em>data</em>, and <em>categories</em>.  For each of these
//      * characteristics you can provide
//      * multiple possible matching values (via {@link #addAction},
//      * {@link #addDataType}, {@link #addDataScheme} {@link #addDataAuthority},
//      * {@link #addDataPath}, and {@link #addCategory}, respectively).
//      * For actions, the field
//      * will not be tested if no values have been given (treating it as a wildcard);
//      * if no data characteristics are specified, however, then the filter will
//      * only match intents that contain no data.
//      *
//      * <p>The data characteristic is
//      * itself divided into three attributes: type, scheme, authority, and path.
//      * Any that are
//      * specified must match the contents of the Intent.  If you specify a scheme
//      * but no type, only Intent that does not have a type (such as mailto:) will
//      * match; a content: URI will never match because they always have a MIME type
//      * that is supplied by their content provider.  Specifying a type with no scheme
//      * has somewhat special meaning: it will match either an Intent with no URI
//      * field, or an Intent with a content: or file: URI.  If you specify neither,
//      * then only an Intent with no data or type will match.  To specify an authority,
//      * you must also specify one or more schemes that it is associated with.
//      * To specify a path, you also must specify both one or more authorities and
//      * one or more schemes it is associated with.
//      *
//      * <div class="special reference">
//      * <h3>Developer Guides</h3>
//      * <p>For information about how to create and resolve intents, read the
//      * <a href="{@docRoot}guide/topics/intents/intents-filters.html">Intents and Intent Filters</a>
//      * developer guide.</p>
//      * </div>
//      *
//      * <h3>Filter Rules</h3>
//      * <p>A match is based on the following rules.  Note that
//      * for an IntentFilter to match an Intent, three conditions must hold:
//      * the <strong>action</strong> and <strong>category</strong> must match, and
//      * the data (both the <strong>data type</strong> and
//      * <strong>data scheme+authority+path</strong> if specified) must match.
//      *
//      * <p><strong>Action</strong> matches if any of the given values match the
//      * Intent action, <em>or</em> if no actions were specified in the filter.
//      *
//      * <p><strong>Data Type</strong> matches if any of the given values match the
//      * Intent type.  The Intent
//      * type is determined by calling {@link Intent#resolveType}.  A wildcard can be
//      * used for the MIME sub-type, in both the Intent and IntentFilter, so that the
//      * type "audio/*" will match "audio/mpeg", "audio/aiff", "audio/*", etc.
//      * <em>Note that MIME type matching here is <b>case sensitive</b>, unlike
//      * formal RFC MIME types!</em>  You should thus always use lower case letters
//      * for your MIME types.
//      *
//      * <p><strong>Data Scheme</strong> matches if any of the given values match the
//      * Intent data's scheme.
//      * The Intent scheme is determined by calling {@link Intent#getData}
//      * and {@link android.net.Uri#getScheme} on that URI.
//      * <em>Note that scheme matching here is <b>case sensitive</b>, unlike
//      * formal RFC schemes!</em>  You should thus always use lower case letters
//      * for your schemes.
//      *
//      * <p><strong>Data Authority</strong> matches if any of the given values match
//      * the Intent's data authority <em>and</em> one of the data scheme's in the filter
//      * has matched the Intent, <em>or</em> no authories were supplied in the filter.
//      * The Intent authority is determined by calling
//      * {@link Intent#getData} and {@link android.net.Uri#getAuthority} on that URI.
//      * <em>Note that authority matching here is <b>case sensitive</b>, unlike
//      * formal RFC host names!</em>  You should thus always use lower case letters
//      * for your authority.
//      *
//      * <p><strong>Data Path</strong> matches if any of the given values match the
//      * Intent's data path <em>and</em> both a scheme and authority in the filter
//      * has matched against the Intent, <em>or</em> no paths were supplied in the
//      * filter.  The Intent authority is determined by calling
//      * {@link Intent#getData} and {@link android.net.Uri#getPath} on that URI.
//      *
//      * <p><strong>Categories</strong> match if <em>all</em> of the categories in
//      * the Intent match categories given in the filter.  Extra categories in the
//      * filter that are not in the Intent will not cause the match to fail.  Note
//      * that unlike the action, an IntentFilter with no categories
//      * will only match an Intent that does not have any categories.
//      */
//     class CIntentFilter {
//         /**
//          * New empty IntentFilter.
//          */
//         constructor();

//         /**
//          * New IntentFilter that matches a single action with no data.  If
//          * no data characteristics are subsequently specified, then the
//          * filter will only match intents that contain no data.
//          *
//          * @param action The action to match, i.e. Intent.ACTION_MAIN.
//          */
//         constructor(
//             [in] String action);

//         /**
//          * New IntentFilter that matches a single action and data type.
//          *
//          * <p><em>Note: MIME type matching in the Android framework is
//          * case-sensitive, unlike formal RFC MIME types.  As a result,
//          * you should always write your MIME types with lower case letters,
//          * and any MIME types you receive from outside of Android should be
//          * converted to lower case before supplying them here.</em></p>
//          *
//          * <p>Throws {@link MalformedMimeTypeException} if the given MIME type is
//          * not syntactically correct.
//          *
//          * @param action The action to match, i.e. Intent.ACTION_VIEW.
//          * @param dataType The type to match, i.e. "vnd.android.cursor.dir/person".
//          *
//          */
//         constructor(
//             [in] String action,
//             [in] String dataType);

//         /**
//          * New IntentFilter containing a copy of an existing filter.
//          *
//          * @param o The original filter to copy.
//          */
//         constructor(
//             [in] IIntentFilter* o);

//         interface IIntentFilter;
//         interface IParcelable;
//     }

//     singleton class CIntentFilterHelper {

//         interface IIntentFilterHelper;
//     }

//     /**
//      * This is an entry for a single authority in the Iterator returned by
//      * {@link #authoritiesIterator()}.
//      */
//     class CIntentFilterAuthorityEntry {
//         constructor();

//         constructor(
//             [in] String host,
//             [in] String port);

//         interface IIntentFilterAuthorityEntry;
//         interface IParcelable;
//     }

//     /**
//      * A description of an Intent and target action to perform with it.
//      * The returned object can be
//      * handed to other applications so that they can perform the action you
//      * described on your behalf at a later time.
//      *
//      * <p>By giving a IntentSender to another application,
//      * you are granting it the right to perform the operation you have specified
//      * as if the other application was yourself (with the same permissions and
//      * identity).  As such, you should be careful about how you build the IntentSender:
//      * often, for example, the base Intent you supply will have the component
//      * name explicitly set to one of your own components, to ensure it is ultimately
//      * sent there and nowhere else.
//      *
//      * <p>A IntentSender itself is simply a reference to a token maintained by
//      * the system describing the original data used to retrieve it.  This means
//      * that, even if its owning application's process is killed, the
//      * IntentSender itself will remain usable from other processes that
//      * have been given it.  If the creating application later re-retrieves the
//      * same kind of IntentSender (same operation, same Intent action, data,
//      * categories, and components, and same flags), it will receive a IntentSender
//      * representing the same token if that is still valid.
//      *
//      * <p>Instances of this class can not be made directly, but rather must be
//      * created from an existing {@link android.app.PendingIntent} with
//      * {@link android.app.PendingIntent#getIntentSender() PendingIntent.getIntentSender()}.
//      */
//     class CIntentSender {
//         constructor();

//         /** @hide */
//         constructor(
//             [in] IIIntentSender* target);

//         interface IIntentSender;
//         interface IParcelable;
//     }

//     singleton class CIntentSenderHelper {
//         interface IIntentSenderHelper;
//     }

//     /**
//      * Value type that contains information about a periodic sync. Is parcelable, making it suitable
//      * for passing in an IPC.
//      */
//     class CPeriodicSync {
//         constructor();

//         /** Creates a new PeriodicSync, copying the Bundle */
//         constructor(
//             [in] IAccount* account,
//             [in] String authority,
//             [in] IBundle* extras,
//             [in] Int64 period);

//         interface IPeriodicSync;
//         interface IParcelable;
//     }

//     /**
//      * Value type that represents a SyncAdapterType. This object overrides {@link #equals} and
//      * {@link #hashCode}, making it suitable for use as the key of a {@link java.util.Map}
//      */
//     class CSyncAdapterType {
//         constructor();

//         constructor(
//             [in] String authority,
//             [in] String accountType,
//             [in] Boolean userVisible,
//             [in] Boolean supportsUploading);

//         /** @hide */
//         constructor(
//             [in] String authority,
//             [in] String accountType,
//             [in] Boolean userVisible,
//             [in] Boolean supportsUploading,
//             [in] Boolean isAlwaysSyncable,
//             [in] Boolean allowParallelSyncs,
//             [in] String settingsActivity);

//         constructor(
//             [in] String authority,
//             [in] String accountType);

//         interface ISyncAdapterType;
//         interface IParcelable;
//     }

//     singleton class CSyncAdapterTypeHelper {

//         interface ISyncAdapterTypeHelper;
//     }

//     class CSyncContext {
//         /**
//          * @hide
//          */
//         constructor(
//             [in] IISyncContext* syncContextInterface);

//         interface ISyncContext;
//     }

//     /**
//      * Information about the sync operation that is currently underway.
//      */
//     class CSyncInfo {
//         constructor();

//         /** @hide */
//         constructor(
//             [in] Int32 authorityId,
//             [in] IAccount* account,
//             [in] String authority,
//             [in] Int64 startTime);

//         interface ISyncInfo;
//         interface IParcelable;
//     }

//     /**
//      * @hide
//      */
//     [local]
//     class CSyncManager {
//         /**
//          * Should only be created after {@link ContentService#systemReady()} so that
//          * {@link PackageManager} is ready to query.
//          */
//         constructor(
//             [in] IContext* ctx,
//             [in] Boolean factoryTest);

//         interface ISyncManager;
//     }

//     /**
//      * Value type that represents a sync operation.
//      * @hide
//      */
//     class CSyncOperation {
//         constructor(
//             [in] ISyncOperation* other);

//         constructor(
//             [in] IAccount* account,
//             [in] Int32 userId,
//             [in] Int32 source,
//             [in] String authority,
//             [in] IBundle* extras,
//             [in] Int64 delayInMs,
//             [in] Int64 backoff,
//             [in] Int64 delayUntil,
//             [in] Boolean allowParallelSyncs);

//         interface ISyncOperation;
//     }

//     /**
//      * This class is used to communicate the results of a sync operation to the SyncManager.
//      * Based on the values here the SyncManager will determine the disposition of the
//      * sync and whether or not a new sync operation needs to be scheduled in the future.
//      *
//      */
//     class CSyncResult {
//         /**
//          * Create a "clean" SyncResult. If this is returned without any changes then the
//          * SyncManager will consider the sync to have completed successfully. The various fields
//          * can be set by the SyncAdapter in order to give the SyncManager more information as to
//          * the disposition of the sync.
//          * <p>
//          * The errors are classified into two broad categories: hard errors and soft errors.
//          * Soft errors are retried with exponential backoff. Hard errors are not retried (except
//          * when the hard error is for a {@link ContentResolver#SYNC_EXTRAS_UPLOAD} request,
//          * in which the request is retryed without the {@link ContentResolver#SYNC_EXTRAS_UPLOAD}
//          * extra set). The SyncManager checks the type of error by calling
//          * {@link SyncResult#hasHardError()} and  {@link SyncResult#hasSoftError()}. If both are
//          * true then the SyncManager treats it as a hard error, not a soft error.
//          */
//         constructor();

//         /**
//          * Internal helper for creating a clean SyncResult or one that indicated that
//          * a sync is already in progress.
//          * @param syncAlreadyInProgress if true then set the {@link #syncAlreadyInProgress} flag
//          */
//         constructor(
//             [in] Boolean syncAlreadyInProgress);

//         interface ISyncResult;
//         interface IParcelable;
//     }

//     singleton class CSyncResultHelper {

//         interface ISyncResultHelper;
//     }

//     /**
//      * Used to record various statistics about the result of a sync operation. The SyncManager
//      * gets access to these via a {@link SyncResult} and uses some of them to determine the
//      * disposition of the sync. See {@link SyncResult} for further dicussion on how the
//      * SyncManager uses these values.
//      */
//     class CSyncStats {
//         constructor();

//         interface ISyncStats;
//         interface IParcelable;
//     }

//     /** @hide */
//     class CSyncStatusInfo {
//         constructor();

//         constructor(
//             [in] Int32 authorityId);

//         interface ISyncStatusInfo;
//         interface IParcelable;
//     }

//     /**
//      * Singleton that tracks the sync data and overall sync
//      * history on the device.
//      *
//      * @hide
//      */
//     [local]
//     class CSyncStorageEngine {
//         constructor(
//             [in] IContext* ctx,
//             [in] IFile* dataDir);

//         interface ISyncStorageEngine;
//     }

//     class CSyncStorageEnginePendingOperation {
//         constructor(
//             [in] IAccount* account,
//             [in] Int32 userId,
//             [in] Int32 source,
//             [in] String authority,
//             [in] IBundle* extras,
//             [in] Boolean expedited);

//         constructor(
//             [in] ISyncStorageEnginePendingOperation* other);

//         interface ISyncStorageEnginePendingOperation;
//     }

//     class CSyncStorageEngineAuthorityInfo {
//         /**
//          * Copy constructor for making deep-ish copies. Only the bundles stored
//          * in periodic syncs can make unexpected changes.
//          *
//          * @param toCopy AuthorityInfo to be copied.
//          */
//         constructor(
//             [in] ISyncStorageEngineAuthorityInfo* toCopy);

//         constructor(
//             [in] IAccount* account,
//             [in] Int32 userId,
//             [in] String authority,
//             [in] Int32 ident);

//         interface ISyncStorageEngineAuthorityInfo;
//     }

//     class CSyncStorageEngineSyncHistoryItem {

//         interface ISyncStorageEngineSyncHistoryItem;
//     }

//     class CSyncStorageEngineDayStats {
//         constructor(
//             [in] Int32 day);

//         interface ISyncStorageEngineDayStats;
//     }

//     singleton class CSyncStorageEngineHelper {

//         interface ISyncStorageEngineHelper;
//     }

//     /***
//      * Utility class to aid in matching URIs in content providers.
//      *
//      * <p>To use this class, build up a tree of <code>UriMatcher</code> objects.
//      * For example:
//      * <pre>
//      *     private static final int PEOPLE = 1;
//      *     private static final int PEOPLE_ID = 2;
//      *     private static final int PEOPLE_PHONES = 3;
//      *     private static final int PEOPLE_PHONES_ID = 4;
//      *     private static final int PEOPLE_CONTACTMETHODS = 7;
//      *     private static final int PEOPLE_CONTACTMETHODS_ID = 8;
//      *
//      *     private static final int DELETED_PEOPLE = 20;
//      *
//      *     private static final int PHONES = 9;
//      *     private static final int PHONES_ID = 10;
//      *     private static final int PHONES_FILTER = 14;
//      *
//      *     private static final int CONTACTMETHODS = 18;
//      *     private static final int CONTACTMETHODS_ID = 19;
//      *
//      *     private static final int CALLS = 11;
//      *     private static final int CALLS_ID = 12;
//      *     private static final int CALLS_FILTER = 15;
//      *
//      *     private static final UriMatcher sURIMatcher = new UriMatcher(UriMatcher.NO_MATCH);
//      *
//      *     static
//      *     {
//      *         sURIMatcher.addURI("contacts", "people", PEOPLE);
//      *         sURIMatcher.addURI("contacts", "people/#", PEOPLE_ID);
//      *         sURIMatcher.addURI("contacts", "people/#/phones", PEOPLE_PHONES);
//      *         sURIMatcher.addURI("contacts", "people/#/phones/#", PEOPLE_PHONES_ID);
//      *         sURIMatcher.addURI("contacts", "people/#/contact_methods", PEOPLE_CONTACTMETHODS);
//      *         sURIMatcher.addURI("contacts", "people/#/contact_methods/#", PEOPLE_CONTACTMETHODS_ID);
//      *         sURIMatcher.addURI("contacts", "deleted_people", DELETED_PEOPLE);
//      *         sURIMatcher.addURI("contacts", "phones", PHONES);
//      *         sURIMatcher.addURI("contacts", "phones/filter/*", PHONES_FILTER);
//      *         sURIMatcher.addURI("contacts", "phones/#", PHONES_ID);
//      *         sURIMatcher.addURI("contacts", "contact_methods", CONTACTMETHODS);
//      *         sURIMatcher.addURI("contacts", "contact_methods/#", CONTACTMETHODS_ID);
//      *         sURIMatcher.addURI("call_log", "calls", CALLS);
//      *         sURIMatcher.addURI("call_log", "calls/filter/*", CALLS_FILTER);
//      *         sURIMatcher.addURI("call_log", "calls/#", CALLS_ID);
//      *     }
//      * </pre>
//      * <p>Then when you need to match against a URI, call {@link #match}, providing
//      * the URL that you have been given.  You can use the result to build a query,
//      * return a type, insert or delete a row, or whatever you need, without duplicating
//      * all of the if-else logic that you would otherwise need.  For example:
//      * <pre>
//      *     public String getType(Uri url)
//      *     {
//      *         int match = sURIMatcher.match(url);
//      *         switch (match)
//      *         {
//      *             case PEOPLE:
//      *                 return "vnd.android.cursor.dir/person";
//      *             case PEOPLE_ID:
//      *                 return "vnd.android.cursor.item/person";
//      * ... snip ...
//      *                 return "vnd.android.cursor.dir/snail-mail";
//      *             case PEOPLE_ADDRESS_ID:
//      *                 return "vnd.android.cursor.item/snail-mail";
//      *             default:
//      *                 return null;
//      *         }
//      *     }
//      * </pre>
//      * instead of:
//      * <pre>
//      *     public String getType(Uri url)
//      *     {
//      *         List<String> pathSegments = url.getPathSegments();
//      *         if (pathSegments.size() >= 2) {
//      *             if ("people".equals(pathSegments.get(1))) {
//      *                 if (pathSegments.size() == 2) {
//      *                     return "vnd.android.cursor.dir/person";
//      *                 } else if (pathSegments.size() == 3) {
//      *                     return "vnd.android.cursor.item/person";
//      * ... snip ...
//      *                     return "vnd.android.cursor.dir/snail-mail";
//      *                 } else if (pathSegments.size() == 3) {
//      *                     return "vnd.android.cursor.item/snail-mail";
//      *                 }
//      *             }
//      *         }
//      *         return null;
//      *     }
//      * </pre>
//      */
//     class CUriMatcher {
//         /**
//          * Creates the root node of the URI tree.
//          *
//          * @param code the code to match for the root URI
//          */
//         constructor(
//             [in] Int32 code);

//         interface IUriMatcher;
//     }

//     /**
//      * Inserts default data from InputStream, should be in XML format.
//      * If the provider syncs data to the server, the imported data will be synced to the server.
//      * <p>Samples:</p>
//      * <br/>
//      *  Insert one row:
//      * <pre>
//      * &lt;row uri="content://contacts/people">
//      *  &lt;Col column = "name" value = "foo feebe "/>
//      *  &lt;Col column = "addr" value = "Tx"/>
//      * &lt;/row></pre>
//      * <br/>
//      * Delete, it must be in order of uri, select, and arg:
//      * <pre>
//      * &lt;del uri="content://contacts/people" select="name=? and addr=?"
//      *  arg1 = "foo feebe" arg2 ="Tx"/></pre>
//      * <br/>
//      *  Use first row's uri to insert into another table,
//      *  content://contacts/people/1/phones:
//      * <pre>
//      * &lt;row uri="content://contacts/people">
//      *  &lt;col column = "name" value = "foo feebe"/>
//      *  &lt;col column = "addr" value = "Tx"/>
//      *  &lt;row postfix="phones">
//      *    &lt;col column="number" value="512-514-6535"/>
//      *  &lt;/row>
//      *  &lt;row postfix="phones">
//      *    &lt;col column="cell" value="512-514-6535"/>
//      *  &lt;/row>
//      * &lt;/row></pre>
//      * <br/>
//      *  Insert multiple rows in to same table and same attributes:
//      * <pre>
//      * &lt;row uri="content://contacts/people" >
//      *  &lt;row>
//      *   &lt;col column= "name" value = "foo feebe"/>
//      *   &lt;col column= "addr" value = "Tx"/>
//      *  &lt;/row>
//      *  &lt;row>
//      *  &lt;/row>
//      * &lt;/row></pre>
//      *
//      * @hide
//      */
//     class CDefaultDataHandler {

//         interface IContentInsertHandler;
//     }

//     /**
//      * Special version of {@link ContextWrapper} that allows the base context to
//      * be modified after it is initially set.
//      */
//     [local]
//     class CMutableContextWrapper {
//         constructor(
//             [in] IContext* base);

//         interface IMutableContextWrapper;
//     }

//     /**
//      * This superclass can be used to create a simple search suggestions provider for your application.
//      * It creates suggestions (as the user types) based on recent queries and/or recent views.
//      *
//      * <p>In order to use this class, you must do the following.
//      *
//      * <ul>
//      * <li>Implement and test query search, as described in {@link android.app.SearchManager}.  (This
//      * provider will send any suggested queries via the standard
//      * {@link android.content.Intent#ACTION_SEARCH ACTION_SEARCH} Intent, which you'll already
//      * support once you have implemented and tested basic searchability.)</li>
//      * <li>Create a Content Provider within your application by extending
//      * {@link android.content.SearchRecentSuggestionsProvider}.  The class you create will be
//      * very simple - typically, it will have only a constructor.  But the constructor has a very
//      * important responsibility:  When it calls {@link #setupSuggestions(String, int)}, it
//      * <i>configures</i> the provider to match the requirements of your searchable activity.</li>
//      * <li>Create a manifest entry describing your provider.  Typically this would be as simple
//      * as adding the following lines:
//      * <pre class="prettyprint">
//      *     &lt;!-- Content provider for search suggestions --&gt;
//      *     &lt;provider android:name="YourSuggestionProviderClass"
//      *               android:authorities="your.suggestion.authority" /&gt;</pre>
//      * </li>
//      * <li>Please note that you <i>do not</i> instantiate this content provider directly from within
//      * your code.  This is done automatically by the system Content Resolver, when the search dialog
//      * looks for suggestions.</li>
//      * <li>In order for the Content Resolver to do this, you must update your searchable activity's
//      * XML configuration file with information about your content provider.  The following additions
//      * are usually sufficient:
//      * <pre class="prettyprint">
//      *     android:searchSuggestAuthority="your.suggestion.authority"
//      *     android:searchSuggestSelection=" ? "</pre>
//      * </li>
//      * <li>In your searchable activities, capture any user-generated queries and record them
//      * for future searches by calling {@link android.provider.SearchRecentSuggestions#saveRecentQuery
//      * SearchRecentSuggestions.saveRecentQuery()}.</li>
//      * </ul>
//      *
//      * <div class="special reference">
//      * <h3>Developer Guides</h3>
//      * <p>For information about using search suggestions in your application, read the
//      * <a href="{@docRoot}guide/topics/search/index.html">Search</a> developer guide.</p>
//      * </div>
//      *
//      * @see android.provider.SearchRecentSuggestions
//      */
//     class CSearchRecentSuggestionsProvider {

//         interface IContentProvider;
//     }

//     /**
//      * Caches the contents of a cursor into a Map of String->ContentValues and optionally
//      * keeps the cache fresh by registering for updates on the content backing the cursor. The column of
//      * the database that is to be used as the key of the map is user-configurable, and the
//      * ContentValues contains all columns other than the one that is designated the key.
//      * <p>
//      * The cursor data is accessed by row key and column name via getValue().
//      */
//     class CContentQueryMap {
//         /**
//          * Creates a ContentQueryMap that caches the content backing the cursor
//          *
//          * @param cursor the cursor whose contents should be cached
//          * @param columnNameOfKey the column that is to be used as the key of the values map
//          * @param keepUpdated true if the cursor's ContentProvider should be monitored for changes and
//          * the map updated when changes do occur
//          * @param handlerForUpdateNotifications the Handler that should be used to receive
//          *  notifications of changes (if requested). Normally you pass null here, but if
//          *  you know that the thread that is creating this isn't a thread that can receive
//          *  messages then you can create your own handler and use that here.
//          */
//         constructor(
//             [in] ICursor* cursor,
//             [in] String columnNameOfKey,
//             [in] Boolean keepUpdated,
//             [in] IHandler* handlerForUpdateNotifications);

//         interface IContentQueryMap;
//         interface IObservable;
//     }

//     } // namespace Content
//     } // namespace Droid
//     } // namespace Elastos

//     namespace Elastos {
//     namespace Droid {
//     namespace Internal {
//     namespace Content {

//     /**
//      * Native libraries helper.
//      *
//      * @hide
//      */
//     singleton class CNativeLibraryHelper {

//         interface INativeLibraryHelper;
//     }

//     /**
//      * Constants used internally between the PackageManager
//      * and media container service transports.
//      * Some utility methods to invoke MountService api.
//      */
//     singleton class CPackageHelper {

//         interface IPackageHelper;
//     }

//     /**
//      * Helper for building selection clauses for {@link SQLiteDatabase}. Each
//      * appended clause is combined using {@code AND}. This class is <em>not</em>
//      * thread safe.
//      *
//      * @hide
//      */
//     class CSelectionBuilder {

//         interface ISelectionBuilder;
//     }

//     } // namespace Content
//     } // namespace Internal
//     } // namespace Droid
//     } // namespace Elastos

}

