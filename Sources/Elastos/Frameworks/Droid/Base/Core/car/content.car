module
{
    merge("content/AbstractThreadedSyncAdapter.car");
    merge("content/AsyncQueryHandler.car");
    merge("content/AsyncTaskLoader.car");
    merge("content/BroadcastReceiver.car");
    merge("content/ClipData.car");
    merge("content/ClipDescription.car");
    merge("content/ClipboardManager.car");
    merge("content/ComponentCallbacks.car");
    merge("content/ComponentCallbacks2.car");
    merge("content/ComponentName.car");
    merge("content/ContentInsertHandler.car");
    merge("content/ContentProvider.car");
    merge("content/ContentProviderClient.car");
    merge("content/ContentProviderOperation.car");
    merge("content/ContentProviderResult.car");
    merge("content/ContentQueryMap.car");
    merge("content/ContentResolver.car");
    merge("content/ContentUris.car");
    merge("content/ContentValues.car");
    merge("content/Context.car");
    merge("content/ContextWrapper.car");
    merge("content/CursorEntityIterator.car");
    merge("content/CursorLoader.car");
    merge("content/DialogInterface.car");
    merge("content/Entity.car");
    merge("content/EntityIterator.car");
    merge("content/IClipboard.car");
    merge("content/IContentProvider.car");
    merge("content/IContentService.car");
    merge("content/IIntentReceiver.car");
    merge("content/IIntentSender.car");
    merge("content/IOnPrimaryClipChangedListener.car");
    merge("content/IRestrictionsManager.car");
    merge("content/ISyncAdapter.car");
    merge("content/ISyncContext.car");
    merge("content/ISyncServiceAdapter.car");
    merge("content/ISyncStatusObserver.car");
    merge("content/Intent.car");
    merge("content/IntentFilter.car");
    merge("content/IntentSender.car");
    merge("content/Loader.car");
    merge("content/MutableContextWrapper.car");
    merge("content/PeriodicSync.car");
    merge("content/RestrictionEntry.car");
    merge("content/RestrictionsManager.car");
    merge("content/SearchRecentSuggestionsProvider.car");
    merge("content/ServiceConnection.car");
    merge("content/SharedPreferences.car");
    merge("content/SyncAdapterType.car");
    merge("content/SyncContext.car");
    merge("content/SyncInfo.car");
    merge("content/SyncRequest.car");
    merge("content/SyncResult.car");
    merge("content/SyncStats.car");
    merge("content/SyncStatusInfo.car");
    merge("content/SyncStatusObserver.car");
    merge("content/UriMatcher.car");
    merge("content/UndoOwner.car");
    merge("content/UndoOperation.car");
    merge("content/UndoManager.car");


//     merge("content/SyncManager.car");
//     merge("content/SyncOperation.car");
//     merge("content/SyncQueue.car");
//     merge("content/SyncStorageEngine.car");

    merge("content/pm/ActivityInfo.car");
    merge("content/pm/ApplicationInfo.car");
    merge("content/pm/ComponentInfo.car");
    merge("content/pm/ConfigurationInfo.car");
    merge("content/pm/ContainerEncryptionParams.car");
    merge("content/pm/FeatureGroupInfo.car");
    merge("content/pm/FeatureInfo.car");
    merge("content/pm/ILauncherApps.car");
    merge("content/pm/IOnAppsChangedListener.car");
    merge("content/pm/IPackageDataObserver.car");
    merge("content/pm/IPackageDeleteObserver.car");
    merge("content/pm/IPackageDeleteObserver2.car");
    merge("content/pm/IPackageInstallObserver.car");
    merge("content/pm/IPackageInstallObserver2.car");
    merge("content/pm/IPackageInstaller.car");
    merge("content/pm/IPackageInstallerCallback.car");
    merge("content/pm/IPackageInstallerSession.car");
    merge("content/pm/IPackageManager.car");
    merge("content/pm/IPackageMoveObserver.car");
    merge("content/pm/IPackageStatsObserver.car");
    merge("content/pm/InstrumentationInfo.car");
    merge("content/pm/KeySet.car");
    merge("content/pm/LabeledIntent.car");
    merge("content/pm/LauncherActivityInfo.car");
    merge("content/pm/LauncherApps.car");
    merge("content/pm/LimitedLengthInputStream.car");
    merge("content/pm/MacAuthenticatedInputStream.car");
    merge("content/pm/ManifestDigest.car");
    merge("content/pm/PackageCleanItem.car");
    merge("content/pm/PackageInfo.car");
    merge("content/pm/PackageInfoLite.car");
    merge("content/pm/PackageInstaller.car");
    merge("content/pm/PackageItemInfo.car");
    merge("content/pm/PackageManager.car");
    merge("content/pm/PackageStats.car");
    merge("content/pm/ParceledListSlice.car");
    merge("content/pm/PathPermission.car");
    merge("content/pm/PermissionGroupInfo.car");
    merge("content/pm/PermissionInfo.car");
    merge("content/pm/ProviderInfo.car");
    merge("content/pm/RegisteredServicesCacheListener.car");
    merge("content/pm/ResolveInfo.car");
    merge("content/pm/ServiceInfo.car");
    merge("content/pm/Signature.car");
    merge("content/pm/UserInfo.car");
    merge("content/pm/VerificationParams.car");
    merge("content/pm/VerifierDeviceIdentity.car");
    merge("content/pm/VerifierInfo.car");
    merge("content/pm/XmlSerializerAndParser.car");

    merge("content/res/AssetFileDescriptor.car");
    merge("content/res/AssetManager.car");
    merge("content/res/ColorStateList.car");
    merge("content/res/CompatibilityInfo.car");
    merge("content/res/Configuration.car");
    merge("content/res/ObbInfo.car");
    merge("content/res/ObbScanner.car");
    merge("content/res/Resources.car");
    merge("content/res/TypedArray.car");
    merge("content/res/XmlResourceParser.car");

    using interface Elastos.Core.IComparable;
    using interface Elastos.Core.ICloneable;
    using interface Elastos.Core.ICharSequence;
    using interface Elastos.Utility.IObservable;
    using interface Org.Xml.Sax.IContentHandler;

    interface Elastos.Droid.Os.IBundle;
    interface Elastos.Droid.Os.IHandler;
    interface Elastos.Droid.Os.IBinder;
    interface Elastos.Droid.Net.IUri;
    interface Elastos.Droid.Database.ICursor;
    interface Elastos.Droid.Database.IContentObserver;
    interface Elastos.Droid.Content.ILoader;
    interface Elastos.Droid.Content.Res.IResources;

    namespace Elastos {
    namespace Droid {
    namespace Content {

        class CLoader {
            /**
             * Stores away the application context associated with context.
             * Since Loaders can be used across multiple activities it's dangerous to
             * store the context directly; always use {@link #getContext()} to retrieve
             * the Loader's Context, don't use the constructor argument directly.
             * The Context returned by {@link #getContext} is safe to use across
             * Activity instances.
             *
             * @param context used to retrieve the application context.
             */
            constructor(
                [in] IContext* ctx);

            interface ILoader;
        }

        /**
         * State for a result that is pending for a broadcast receiver.  Returned
         * by {@link BroadcastReceiver#goAsync() goAsync()}
         * while in {@link BroadcastReceiver#onReceive BroadcastReceiver.onReceive()}.
         * This allows you to return from onReceive() without having the broadcast
         * terminate; you must call {@link #finish()} once you are done with the
         * broadcast.  This allows you to process the broadcast off of the main
         * thread of your app.
         *
         * <p>Note on threading: the state inside of this class is not itself
         * thread-safe, however you can use it from any thread if you properly
         * sure that you do not have races.  Typically this means you will hand
         * the entire object to another thread, which will be solely responsible
         * for setting any results and finally calling {@link #finish()}.
         */
        class CPendingResult {
            /** @hide */
            constructor(
                [in] Int32 resultCode,
                [in] String resultData,
                [in] IBundle* resultExtras,
                [in] Int32 type,
                [in] Boolean ordered,
                [in] Boolean sticky,
                [in] IBinder* token,
                [in] Int32 userId);

            interface IPendingResult;
        }

        [deprecated]
        class CClipData {

            constructor();

            /**
             * Create a new clip.
             *
             * @param label Label to show to the user describing this clip.
             * @param mimeTypes An array of MIME types this data is available as.
             * @param item The contents of the first item in the clip.
             */
            constructor(
                [in] ICharSequence* label,
                [in] ArrayOf<String>* mimeTypes,
                [in] IClipDataItem* item);

            /**
             * Create a new clip.
             *
             * @param description The ClipDescription describing the clip contents.
             * @param item The contents of the first item in the clip.
             */
            constructor(
                [in] IClipDescription* description,
                [in] IClipDataItem* item);

            /**
             * Create a new clip that is a copy of another clip.  This does a deep-copy
             * of all items in the clip.
             *
             * @param other The existing ClipData that is to be copied.
             */
            constructor(
                [in] IClipData* other);

            interface IClipData;
            interface IParcelable;
        }

        class CClipDataItem {
            /**
             * Create an Item consisting of a single block of (possibly styled) text.
             */
            constructor(
                [in] ICharSequence* text);

            /**
             * Create an Item consisting of a single block of (possibly styled) text,
             * with an alternative HTML formatted representation.  You <em>must</em>
             * supply a plain text representation in addition to HTML text; coercion
             * will not be done from HTML formated text into plain text.
             */
            constructor(
                [in] ICharSequence* text,
                [in] String htmlText);

            /**
             * Create an Item consisting of an arbitrary Intent.
             */
            constructor(
                [in] IIntent* intent);

            /**
             * Create an Item consisting of an arbitrary URI.
             */
            constructor(
                [in] IUri* uri);

            /**
             * Create a complex Item, containing multiple representations of
             * text, Intent, and/or URI.
             */
            constructor(
                [in] ICharSequence* text,
                [in] IIntent* intent,
                [in] IUri* uri);

            /**
             * Create a complex Item, containing multiple representations of
             * text, HTML text, Intent, and/or URI.  If providing HTML text, you
             * <em>must</em> supply a plain text representation as well; coercion
             * will not be done from HTML formated text into plain text.
             */
            constructor(
                [in] ICharSequence* text,
                [in] String htmlText,
                [in] IIntent* intent,
                [in] IUri* uri);

            interface IClipDataItem;
        }

        singleton class CClipDataHelper {
            interface IClipDataHelper;
        }

        [deprecated]
        class CClipDescription {
            /**
             * Create a new clip.
             *
             * @param label Label to show to the user describing this clip.
             * @param mimeTypes An array of MIME types this data is available as.
             */
            constructor(
                [in] ICharSequence* label,
                [in] ArrayOf<String>* mimeTypes);

            /**
             * Create a copy of a ClipDescription.
             */
            constructor(
                [in] IClipDescription* o);

            constructor();

            interface IClipDescription;
            interface IParcelable;
        }

        singleton class CClipDescriptionHelper {
            interface IClipDescriptionHelper;
        }

        [local]
        class CClipboardManager {
            /** {@hide} */
            constructor(
                [in] IContext* ctx);

            interface IClipboardManager;
            interface Elastos.Droid.Text.IClipboardManager;
        }

        /**
         * Identifier for a specific application component
         * ({@link android.app.Activity}, {@link android.app.Service},
         * {@link android.content.BroadcastReceiver}, or
         * {@link android.content.ContentProvider}) that is available.  Two
         * pieces of information, encapsulated here, are required to identify
         * a component: the package (a String) it exists in, and the class (a String)
         * name inside of that package.
         *
         */
        [local]
        class CComponentName {
            constructor();

            /**
             * Create a new component identifier.
             *
             * @param pkg The name of the package that the component exists in.  Can
             * not be null.
             * @param cls The name of the class inside of <var>pkg</var> that
             * implements the component.  Can not be null.
             */
            constructor(
                [in] String pkg,
                [in] String cls);

            /**
             * Create a new component identifier from a Context and class name.
             *
             * @param pkg A Context for the package implementing the component,
             * from which the actual package name will be retrieved.
             * @param cls The name of the class inside of <var>pkg</var> that
             * implements the component.
             */
            constructor(
                [in] IContext* pkgCtx,
                [in] String cls);

            /**
             * Create a new component identifier from a Context and Class object.
             *
             * @param pkg A Context for the package implementing the component, from
             * which the actual package name will be retrieved.
             * @param cls The Class object of the desired component, from which the
             * actual class name will be retrieved.
             */
            constructor(
                [in] IContext* pkg,
                [in] IClassInfo* IClassInfo);

            interface IComponentName;
            interface IParcelable;
            interface ICloneable;
            interface IComparable;
        }

        singleton class CComponentNameHelper {
            interface IComponentNameHelper;
        }

        singleton class CContentProviderHelper {
            interface IContentProviderHelper;
        }

        class CContentProviderTransport {
            constructor(
                [in] IContentProvider* owner);

            interface IContentProviderTransport;
            interface IIContentProvider;
            interface IBinder;
        }

        /**
         * The public interface object used to interact with a {@link ContentProvider}. This is obtained by
         * calling {@link ContentResolver#acquireContentProviderClient}. This object must be released
         * using {@link #release} in order to indicate to the system that the {@link ContentProvider} is
         * no longer needed and can be killed to free up resources.
         *
         * <p>Note that you should generally create a new ContentProviderClient instance
         * for each thread that will be performing operations.  Unlike
         * {@link ContentResolver}, the methods here such as {@link #query} and
         * {@link #openFile} are not thread safe -- you must not call
         * {@link #release()} on the ContentProviderClient those calls are made from
         * until you are finished with the data they have returned.
         */
        class CContentProviderClient {
            /**
             * @hide
             */
            constructor(
                [in] IContentResolver* resolver,
                [in] IIContentProvider* provider,
                [in] Boolean stable);

            interface IContentProviderClient;
        }

        class CContentProviderOperation {
            /**
            * Creates a {@link ContentProviderOperation} by copying the contents of a
            * {@link Builder}.
            */
            constructor(
                [in] IContentProviderOperationBuilder* operationBuilder);

            constructor();

            interface IContentProviderOperation;
            interface IParcelable;
        }

        class CContentProviderOperationBuilder {
            interface IContentProviderOperationBuilder;
        }

        singleton class CContentProviderOperationHelper {
            interface IContentProviderOperationHelper;
        }

        /**
         * Contains the result of the application of a {@link ContentProviderOperation}. It is guaranteed
         * to have exactly one of {@link #uri} or {@link #count} set.
         */
        class CContentProviderResult {
            constructor(
                [in] IUri* uri);

            constructor(
                [in] Int32 count);

            constructor();

            interface IContentProviderResult;
            interface IParcelable;
        }

        /**
         * Caches the contents of a cursor into a Map of String->ContentValues and optionally
         * keeps the cache fresh by registering for updates on the content backing the cursor. The column of
         * the database that is to be used as the key of the map is user-configurable, and the
         * ContentValues contains all columns other than the one that is designated the key.
         * <p>
         * The cursor data is accessed by row key and column name via getValue().
         */
        class CContentQueryMap {

            constructor(
                [in] ICursor* cursor,
                [in] String columnNameOfKey,
                [in] Boolean keepUpdated,
                [in] IHandler* handlerForUpdateNotifications);

            interface IContentQueryMap;
            interface IObservable;
        }

        /**
         * This class is used to store a set of values that the {@link ContentResolver}
         * can process.
         */
        class CContentValues {
            /**
             * Creates an empty set of values using the default initial size
             */
            constructor();

            /**
             * Creates an empty set of values using the given initial size
             *
             * @param size the initial size of the set of values
             */
            constructor(
                [in] Int32 size);

            /**
             * Creates a set of values copied from the given set
             *
             * @param from the values to copy
             */
            constructor(
                [in] IContentValues* from);

            interface IContentValues;
            interface IParcelable;
        }

        singleton class CContentUris {
            interface IContentUris;
        }

        singleton class CContentResolverHelper {
            interface IContentResolverHelper;
        }

        class CContentResolverOpenResourceIdResult {
            constructor(
                [in] IResources* res,
                [in] Int32 id);

            interface IContentResolverOpenResourceIdResult;
        }

        [local]
        class CContextWrapper {
            constructor(
               [in] IContext* ctx);

           interface IContextWrapper;
           interface IContext;
        }

        [local]
        class CLoaderForceLoadContentObserver {
            constructor(
                [in] ILoader* loader);

            interface ILoaderForceLoadContentObserver;
            interface IContentObserver;
        }

        [deprecated]
        class CCursorLoader {
            constructor(
                [in] IContext* ctx);

            constructor(
                [in] IContext* ctx,
                [in] IUri* uri,
                [in] ArrayOf<String>* projection,
                [in] String selection,
                [in] ArrayOf<String>* selectionArgs,
                [in] String sortOrder);

            interface ICursorLoader;
            interface IAsyncTaskLoader;
            interface ILoader;
        }

        class CDefaultDataHandler {
            interface IContentInsertHandler;
            interface IContentHandler;
        }

        /**
         * A representation of a item using ContentValues. It contains one top level ContentValue
         * plus a collection of Uri, ContentValues tuples as subvalues. One example of its use
         * is in Contacts, where the top level ContentValue contains the columns from the RawContacts
         * table and the subvalues contain a ContentValues object for each row from the Data table that
         * corresponds to that RawContact. The uri refers to the Data table uri for each row.
         */
        class CEntity {
            constructor(
                [in] IContentValues* values);

            interface IEntity;
        }

        class CEntityNamedContentValues {
            constructor(
                [in] IUri* uri,
                [in] IContentValues* values);

            interface IEntityNamedContentValues;
        }

        [local]
        class CIntent {
            constructor();

            constructor(
                [in] IIntent* intent);

            constructor(
                [in] IIntent* intent,
                [in] Boolean all);

            constructor(
                [in] String action);

            constructor(
                [in] String action,
                [in] IUri* uri);

            constructor(
                [in] IContext* packageContext,
                [in] ClassID clsId);

            constructor(
                [in] String action,
                [in] IUri* uri,
                [in] IContext* packageContext,
                [in] IClassInfo* clsinfo);

            interface IIntent;
            interface IParcelable;
            interface ICloneable;
        }

        singleton class CIntentHelper {
            interface IIntentHelper;
        }

    }//namespace Content
    }//namespace Droid
    }//namespace Elastos

//        namespace Pm {

//     /**
//      * Information you can retrieve about a particular application
//      * activity or receiver. This corresponds to information collected
//      * from the AndroidManifest.xml's &lt;activity&gt; and
//      * &lt;receiver&gt; tags.
//      */
//     class CActivityInfo {
//         constructor();

//         constructor(
//             [in] IActivityInfo* orig);

//         interface IActivityInfo;
//         interface IParcelable;
//     }

//     singleton class CActivityInfoHelper {
//         interface IActivityInfoHelper;
//     }

//     /**
//      * Information you can retrieve about a particular application.  This
//      * corresponds to information collected from the AndroidManifest.xml's
//      * &lt;application&gt; tag.
//      */
//     class CApplicationInfo {
//         constructor();

//         constructor(
//             [in] IApplicationInfo* orig);

//         interface IApplicationInfo;
//         interface IParcelable;
//     }

//     class CApplicationInfoDisplayNameComparator {
//         constructor(
//             [in] IPackageManager* pm);

//         interface IApplicationInfoDisplayNameComparator;
//     }

//     /**
//      * Base class containing information common to all application components
//      * ({@link ActivityInfo}, {@link ServiceInfo}).  This class is not intended
//      * to be used by itself; it is simply here to share common definitions
//      * between all application components.  As such, it does not itself
//      * implement Parcelable, but does provide convenience methods to assist
//      * in the implementation of Parcelable in subclasses.
//      */
//     class CComponentInfo {
//         constructor();

//         constructor(
//             [in] IComponentInfo* orig);

//         interface IComponentInfo;
//     }

//     /**
//      * Information you can retrieve about hardware configuration preferences
//      * declared by an application. This corresponds to information collected from the
//      * AndroidManifest.xml's &lt;uses-configuration&gt; and &lt;uses-feature&gt; tags.
//      */
//     class CConfigurationInfo {
//         constructor();

//         constructor(
//             [in] IConfigurationInfo* orig);

//         interface IConfigurationInfo;
//         interface IParcelable;
//     }

//     /**
//      * Represents encryption parameters used to read a container.
//      *
//      * @hide
//      */
// //    [deprecated]
// //    class CContainerEncryptionParams {
// //        constructor();
// //
// //        constructor(
// //            [in] String encryptionAlgorithm,
// //            [in] IAlgorithmParameterSpec* encryptionSpec,
// //            [in] ISecretKey* encryptionKey);
// //
// //        /**
// //         * Creates container encryption specifications for installing from encrypted
// //         * containers.
// //         *
// //         * @param encryptionAlgorithm encryption algorithm to use; format matches
// //         *            JCE
// //         * @param encryptionSpec algorithm parameter specification
// //         * @param encryptionKey key used for decryption
// //         * @param macAlgorithm MAC algorithm to use; format matches JCE
// //         * @param macSpec algorithm parameters specification, may be {@code null}
// //         * @param macKey key used for authentication (i.e., for the MAC tag)
// //         * @param macTag message authentication code (MAC) tag for the authenticated
// //         *            data
// //         * @param authenticatedDataStart offset of start of authenticated data in
// //         *            stream
// //         * @param encryptedDataStart offset of start of encrypted data in stream
// //         * @param dataEnd offset of the end of both the authenticated and encrypted
// //         *            data
// //         * @throws InvalidAlgorithmParameterException
// //         */
// //        constructor(
// //            [in] String encryptionAlgorithm,
// //            [in] IAlgorithmParameterSpec* encryptionSpec,
// //            [in] ISecretKey* encryptionKey,
// //            [in] String macAlgorithm,
// //            [in] IAlgorithmParameterSpec* macSpec,
// //            [in] ISecretKey* macKey,
// //            [in] ArrayOf<Byte>* macTag,
// //            [in] Int64 authenticatedDataStart,
// //            [in] Int64 encryptedDataStart,
// //            [in] Int64 dataEnd);
// //
// //        interface IContainerEncryptionParams;
// //        interface IParcelable;
// //    }

//     /**
//      * A single feature that can be requested by an application. This corresponds
//      * to information collected from the
//      * AndroidManifest.xml's &lt;uses-feature&gt; tag.
//      */
//     class CFeatureInfo {
//         constructor();

//         constructor(
//             [in] IFeatureInfo* orig);

//         interface IFeatureInfo;
//         interface IParcelable;
//     }

//     /**
//      * Information you can retrieve about a particular piece of test
//      * instrumentation.  This corresponds to information collected
//      * from the AndroidManifest.xml's &lt;instrumentation&gt; tag.
//      */
//     class CInstrumentationInfo {
//         constructor();

//         constructor(
//             [in] IInstrumentationInfo* orig);

//         interface IInstrumentationInfo;
//         interface IParcelable;
//     }

//     /**
//      * A special subclass of Intent that can have a custom label/icon
//      * associated with it.  Primarily for use with {@link Intent#ACTION_CHOOSER}.
//      */
//    class CLabeledIntent {
//        /**
//         * Create a labeled intent from the given intent, supplying the label
//         * and icon resources for it.
//         *
//         * @param origIntent The original Intent to copy.
//         * @param sourcePackage The package in which the label and icon live.
//         * @param labelRes Resource containing the label, or 0 if none.
//         * @param icon Resource containing the icon, or 0 if none.
//         */
//         constructor(
//             [in] IIntent* origIntent,
//             [in] String sourcePackage,
//             [in] Int32 labelRes,
//             [in] Int32 icon);

//        /**
//         * Create a labeled intent from the given intent, supplying a textual
//         * label and icon resource for it.
//         *
//         * @param origIntent The original Intent to copy.
//         * @param sourcePackage The package in which the label and icon live.
//         * @param nonLocalizedLabel Concrete text to use for the label.
//         * @param icon Resource containing the icon, or 0 if none.
//         */
//         constructor(
//             [in] IIntent* origIntent,
//             [in] String sourcePackage,
//             [in] ICharSequence* nonLocalizedLabel,
//             [in] Int32 icon);

//         /**
//          * Create a labeled intent with no intent data but supplying the label
//          * and icon resources for it.
//          *
//          * @param sourcePackage The package in which the label and icon live.
//          * @param labelRes Resource containing the label, or 0 if none.
//          * @param icon Resource containing the icon, or 0 if none.
//          */
//         constructor(
//             [in] String sourcePackage,
//             [in] Int32 labelRes,
//             [in] Int32 icon);

//        /**
//         * Create a labeled intent with no intent data but supplying a textual
//         * label and icon resource for it.
//         *
//         * @param sourcePackage The package in which the label and icon live.
//         * @param nonLocalizedLabel Concrete text to use for the label.
//         * @param icon Resource containing the icon, or 0 if none.
//         */
//         constructor(
//             [in] String sourcePackage,
//             [in] ICharSequence* nonLocalizedLabel,
//             [in] Int32 icon);

//         constructor();

//        interface ILabeledIntent;
//        interface IParcelable;
//    }

//     /**
//      * A class that limits the amount of data that is read from an InputStream. When
//      * the specified length is reached, the stream returns an EOF even if the
//      * underlying stream still has more data.
//      *
//      * @hide
//      */
//    class CLimitedLengthInputStream {
//        /**
//         * @param in underlying stream to wrap
//         * @param offset offset into stream where data starts
//         * @param length length of data at offset
//         * @throws IOException if an error occurred with the underlying stream
//         */
//        constructor(
//            [in] IInputStream* inStream,
//            [in] Int64 offset,
//            [in] Int64 length);

//        interface ILimitedLengthInputStream;
//    }

//     /**
//      * An input stream filter that applies a MAC to the data passing through it. At
//      * the end of the data that should be authenticated, the tag can be calculated.
//      * After that, the stream should not be used.
//      *
//      * @hide
//      */
//    class CMacAuthenticatedInputStream {
//        constructor(
//            [in] IInputStream* inStream,
//            [in] IMac* mac);

//        interface IMacAuthenticatedInputStream;
//    }

//     /**
//      * Represents the manifest digest for a package. This is suitable for comparison
//      * of two packages to know whether the manifests are identical.
//      *
//      * @hide
//      */
//     [deprecated]
//     class CManifestDigest {
//         constructor();
//         constructor(
//             [in] ArrayOf<Byte>* digest);

//         interface IManifestDigest;
//         interface IParcelable;
//     }

//     singleton class CManifestDigestHelper {
//         interface IManifestDigestHelper;
//     }

//     /** @hide */
//     class CPackageCleanItem {
//         constructor();

//         constructor(
//             [in] Int32 userId,
//             [in] String packageName,
//             [in] Boolean andCode);

//         interface IPackageCleanItem;
//         interface IParcelable;
//     }

//     /**
//      * Overall information about the contents of a package.  This corresponds
//      * to all of the information collected from AndroidManifest.xml.
//      */
//     class CPackageInfo {
//         constructor();

//         interface IPackageInfo;
//         interface IParcelable;
//     }

//     /**
//      * Basic information about a package as specified in its manifest.
//      * Utility class used in PackageManager methods
//      * @hide
//      */
//     class CPackageInfoLite {
//         constructor();

//         interface IPackageInfoLite;
//         interface IParcelable;
//     }

//     /**
//      * Base class containing information common to all package items held by
//      * the package manager.  This provides a very common basic set of attributes:
//      * a label, icon, and meta-data.  This class is not intended
//      * to be used by itself; it is simply here to share common definitions
//      * between all items returned by the package manager.  As such, it does not
//      * itself implement Parcelable, but does provide convenience methods to assist
//      * in the implementation of Parcelable in subclasses.
//      */
//     class CPackageItemInfo {
//         constructor();

//         constructor(
//             [in] IPackageItemInfo* orig);

//         interface IPackageItemInfo;
//     }

//     class CPackageItemInfoDisplayNameComparator {
//         constructor(
//             [in] IPackageManager* pm);

//         interface IPackageItemInfoDisplayNameComparator;
//     }

// //    singleton class CPackageManagerHelper {
// //        interface IPackageManagerHelper;
// //    }

//     /**
//      * implementation of PackageStats associated with a
//      * application package.
//      */
//     class CPackageStats {
//         constructor();

//         constructor(
//             [in] String pkgName);

//         /** @hide */
//         constructor(
//             [in] String pkgName,
//             [in] Int32 userHandle);

//         constructor(
//             [in] IPackageStats* pStats);

//         interface IPackageStats;
//         interface IParcelable;
//     }

//     /**
//      * Builds up a parcel that is discarded when written to another parcel or
//      * written to a list. This is useful for API that sends huge lists across a
//      * Binder that may be larger than the IPC limit.
//      *
//      * @hide
//      */
//     class CParceledListSlice {
//         constructor();

//         interface IParceledListSlice;
//         interface IParcelable;
//     }

//     /**
//      * Description of permissions needed to access a particular path
//      * in a {@link ProviderInfo}.
//      */
//     class CPathPermission {
//         constructor();

//         constructor(
//             [in] String pattern,
//             [in] Int32 type,
//             [in] String readPermission,
//             [in] String writePermission);

//         interface IPathPermission;
//         interface IParcelable;
//     }

//     /**
//      * Information you can retrieve about a particular security permission
//      * group known to the system.  This corresponds to information collected from the
//      * AndroidManifest.xml's &lt;permission-group&gt; tags.
//      */
//     class CPermissionGroupInfo {
//         constructor();

//         constructor(
//             [in] IPermissionGroupInfo* orig);

//         interface IPermissionGroupInfo;
//         interface IParcelable;
//     }

//     /**
//      * Information you can retrieve about a particular security permission
//      * known to the system.  This corresponds to information collected from the
//      * AndroidManifest.xml's &lt;permission&gt; tags.
//      */
//     class CPermissionInfo {
//         constructor();

//         constructor(
//             [in] IPermissionInfo* orig);

//         interface IPermissionInfo;
//         interface IParcelable;
//     }

//     singleton class CPermissionInfoHelper {
//         interface IPermissionInfoHelper;
//     }

//     /**
//      * Holds information about a specific
//      * {@link android.content.ContentProvider content provider}. This is returned by
//      * {@link android.content.pm.PackageManager#resolveContentProvider(java.lang.String, int)
//      * PackageManager.resolveContentProvider()}.
//      */
//     class CProviderInfo {
//         constructor();

//         constructor(
//             [in] IProviderInfo* orig);

//         interface IProviderInfo;
//         interface IParcelable;
//     }

//     /**
//      * Information that is returned from resolving an intent
//      * against an IntentFilter. This partially corresponds to
//      * information collected from the AndroidManifest.xml's
//      * &lt;intent&gt; tags.
//      */
//     class CResolveInfo {
//         constructor();

//         constructor(
//             [in] IResolveInfo* orig);

//         interface IResolveInfo;
//         interface IParcelable;
//     }

//     class CResolveInfoDisplayNameComparator {
//         constructor(
//             [in] IPackageManager* pm);

//         interface IResolveInfoDisplayNameComparator;
//     }

//     /**
//      * Information you can retrieve about a particular application
//      * service. This corresponds to information collected from the
//      * AndroidManifest.xml's &lt;service&gt; tags.
//      */
//     class CServiceInfo {
//         constructor();

//         constructor(
//             [in] IServiceInfo* orig);

//         interface IServiceInfo;
//         interface IParcelable;
//     }

//     /**
//      * Opaque, immutable representation of a signature associated with an
//      * application package.
//      */
//     [deprecated]
//     class CSignature {
//         /**
//          * Create Signature from an existing raw byte array.
//          */
//         constructor(
//             [in] ArrayOf<Byte>* signature);

//         /**
//          * Create Signature from a text representation previously returned by
//          * {@link #toChars} or {@link #toCharsString()}. Signatures are expected to
//          * be a hex-encoded ASCII string.
//          *
//          * @param text hex-encoded string representing the signature
//          * @throws IllegalArgumentException when signature is odd-length
//          */
//         constructor(
//             [in] String text);

//         constructor();

//         interface ISignature;
//         interface IParcelable;
//     }

//     /**
//      * Per-user information.
//      * @hide
//      */
//     class CUserInfo {
//         constructor();

//         constructor(
//             [in] IUserInfo* orig);

//         constructor(
//             [in] Int32 id,
//             [in] String name,
//             [in] Int32 flags);

//         constructor(
//             [in] Int32 id,
//             [in] String name,
//             [in] String iconPath,
//             [in] Int32 flags);

//         interface IUserInfo;
//         interface IParcelable;
//     }

//     /**
//      * Represents verification parameters used to verify packages to be installed.
//      *
//      * @hide
//      */
//      [deprecated]
//      class CVerificationParams {
//          /**
//           * Creates verification specifications for installing with application verification.
//           *
//           * @param verificationURI The location of the supplementary verification
//           *            file. This can be a 'file:' or a 'content:' URI. May be {@code null}.
//           * @param originatingURI URI referencing where the package was downloaded
//           *            from. May be {@code null}.
//           * @param referrer HTTP referrer URI associated with the originatingURI.
//           *            May be {@code null}.
//           * @param originatingUid UID of the application that the install request originated
//           *            from, or NO_UID if not present
//           * @param manifestDigest an object that holds the digest of the package
//           *            which can be used to verify ownership. May be {@code null}.
//           */
//          constructor(
//              [in] IUri* verificationURI,
//              [in] IUri* originatingURI,
//              [in] IUri* referrer,
//              [in] Int32 originatingUid,
//              [in] IManifestDigest* manifestDigest);

//          constructor();

//          interface IVerificationParams;
//          interface IParcelable;
//      }

//     /**
//      * An identity that uniquely identifies a particular device. In this
//      * implementation, the identity is represented as a 64-bit integer encoded to a
//      * 13-character string using RFC 4648's Base32 encoding without the trailing
//      * padding. This makes it easy for users to read and write the code without
//      * confusing 'I' (letter) with '1' (one) or 'O' (letter) with '0' (zero).
//      *
//      * @hide
//      */
//      class CVerifierDeviceIdentity {
//          /**
//           * Create a verifier device identity from a long.
//           *
//           * @param identity device identity in a 64-bit integer.
//           * @throws
//           */
//          constructor(
//              [in] Int64 identity);

//          constructor();

//          interface IVerifierDeviceIdentity;
//          interface IParcelable;
//      }

//      singleton class CVerifierDeviceIdentityHelper {
//          interface IVerifierDeviceIdentityHelper;
//      }

// //    class CVerifierInfo {
// //        /**
// //         * Creates an object that represents a verifier info object.
// //         *
// //         * @param packageName the package name in Java-style. Must not be {@code
// //         *            null} or empty.
// //         * @param publicKey the public key for the signer encoded in Base64. Must
// //         *            not be {@code null} or empty.
// //         * @throws IllegalArgumentException if either argument is null or empty.
// //         */
// //        constructor(
// //            [in] String packageName,
// //            [in] IPublicKey* publicKey);
// //
// //        constructor();
// //
// //        interface IVerifierInfo;
// //        interface IParcelable;
// //    }

//     } // namespace Pm
//     } // namespace Content
//     } // namespace Droid
//     } // namespace Elastos

//     interface Elastos.Droid.Os.IParcelFileDescriptor;
//     interface Elastos.Droid.Content.Pm.IApplicationInfo;
//     interface Elastos.Droid.Utility.IDisplayMetrics;

//     namespace Elastos {
//     namespace Droid {
//     namespace Content {
//     namespace Res{

//     class CAssetFileDescriptor {
//         /**
//          * Create a new AssetFileDescriptor from the given values.
//          * @param fd The underlying file descriptor.
//          * @param startOffset The location within the file that the asset starts.
//          * This must be 0 if length is UNKNOWN_LENGTH.
//          * @param length The number of bytes of the asset, or
//          * {@link #UNKNOWN_LENGTH} if it extends to the end of the file.
//          */
//         constructor(
//             [in] IParcelFileDescriptor* fd,
//             [in] Int64 startOffset,
//             [in] Int64 length);

//         /**
//         * Create an empty surface, which will later be filled in by
//         * readFromParcel().
//         */
//         constructor();

//         interface IAssetFileDescriptor;
//         interface IParcelable;
//     }

//     class CAssetFileDescriptorAutoCloseInputStream {
//         constructor(
//             [in] IAssetFileDescriptor* fd);

//         interface IAssetFileDescriptorAutoCloseInputStream;
//     }

//     class CAssetFileDescriptorAutoCloseOutputStream {
//         constructor(
//             [in] IAssetFileDescriptor* fd);

//         interface IAssetFileDescriptorAutoCloseOutputStream;
//         interface IFlushable;
//     }

//     class CAssetManager {

//         /**
//          * Create a new AssetManager containing only the basic system assets.
//          * Applications will not generally use this method, instead retrieving the
//          * appropriate asset manager with {@link Resources#getAssets}.    Not for
//          * use by applications.
//          * {@hide}
//          */
//         constructor();

//         constructor(
//             [in] Boolean isSystem);

//         interface IAssetManager;
//     }

//     singleton class CAssetManagerHelper{
//         interface IAssetManagerHelper;
//     }

//     [deprecated]
//     class CColorStateList {
//         constructor();

//         /**
//          * Creates a ColorStateList that returns the specified mapping from
//          * states to colors.
//          */
//         constructor(
//             [in] ArrayOf<Handle32>* states,
//             [in] ArrayOf<Int32>* colors);

//         interface IColorStateList;
//         interface IParcelable;
//     }

//     singleton class CColorStateListHelper{

//         interface IColorStateListHelper;
//     }

//     class CCompatibilityInfo{
//         constructor(
//             [in] IApplicationInfo* appInfo,
//             [in] Int32 screenLayout,
//             [in] Int32 sw,
//             [in] Boolean forceCompat);

//         constructor(
//             [in] Int32 compFlags,
//             [in] Int32 dens,
//             [in] Float scale,
//             [in] Float invertedScale);

//         constructor();

//         interface ICompatibilityInfo;
//         interface IParcelable;
//     }

//     singleton class CCompatibilityInfoHelper{
//         interface ICompatibilityInfoHelper;
//     }

//     class CConfiguration{
//         /**
//          * Construct an invalid Configuration.  You must call {@link #setToDefaults}
//          * for this object to be valid.  {@more}
//          */
//         constructor();

//         /**
//          * Makes a deep copy suitable for modification.
//          */
//         constructor(
//             [in] IConfiguration* o);

//         interface IConfiguration;
//         interface IParcelable;
//         interface IComparable;
//     }

//     singleton class CConfigurationHelper{
//         interface IConfigurationHelper;
//     }

//     class CObbInfo {
//         constructor();

//         interface IObbInfo;
//         interface IParcelable;
//     }

//     singleton class CObbScanner {
//         // Don't allow others to instantiate this class

//         interface IObbScanner;
//     }

//     class CResources{
//         constructor();

//          /**
//          * Create a new Resources object on top of an existing set of assets in an
//          * AssetManager.
//          *
//          * @param assets Previously created AssetManager.
//          * @param metrics Current display metrics to consider when
//          *                selecting/computing resource values.
//          * @param config Desired device configuration to consider when
//          *               selecting/computing resource values (optional).
//          */
//         constructor(
//             [in] IAssetManager* assets,
//             [in] IDisplayMetrics* metrics,
//             [in] IConfiguration* config);

//         /**
//          * Creates a new Resources object with CompatibilityInfo.
//          *
//          * @param assets Previously created AssetManager.
//          * @param metrics Current display metrics to consider when
//          *                selecting/computing resource values.
//          * @param config Desired device configuration to consider when
//          *               selecting/computing resource values (optional).
//          * @param compInfo this resource's compatibility info. It will use the default compatibility
//          *  info when it's null.
//          * @hide
//          */
//         constructor(
//             [in] IAssetManager* assets,
//             [in] IDisplayMetrics* metrics,
//             [in] IConfiguration* config,
//             [in] ICompatibilityInfo* compInfo);

//         interface IResources;
//     }

//     singleton class CResourcesHelper {
//         interface IResourcesHelper;
//     }

//     [deprecated]
//     class CTypedArray{
//         constructor(
//             [in] IResources* resources,
//             [in] ArrayOf<Int32>* data,
//             [in] ArrayOf<Int32>* indices,
//             [in] Int32 len);

//         interface ITypedArray;
//     }

//     } // namespace Res
//     } // namespace Content
//     } // namepsace Droid
//     } // namespace Elastos


//     // using interface Elastos.Core.ICharSequence;
//     using interface Elastos.IO.IFile;
//     interface Elastos.Droid.Os.IBundle;
//     interface Elastos.Droid.Os.IBinder;
//     interface Elastos.Droid.Accounts.IAccount;
//     interface Elastos.Droid.Database.ICursor;
//     interface Elastos.Droid.Os.IHandler;

//     namespace Elastos {
//     namespace Droid {
//     namespace Content {


//     /**
//      * Represents a shortcut/live folder icon resource.
//      *
//      * @see Intent#ACTION_CREATE_SHORTCUT
//      * @see Intent#EXTRA_SHORTCUT_ICON_RESOURCE
//      * @see android.provider.LiveFolders#ACTION_CREATE_LIVE_FOLDER
//      * @see android.provider.LiveFolders#EXTRA_LIVE_FOLDER_ICON
//      */
//     class CIntentShortcutIconResource {
//         constructor();

//         interface IIntentShortcutIconResource;
//         interface IParcelable;
//     }

//     singleton class CIntentShortcutIconResourceHelper {

//         interface IIntentShortcutIconResourceHelper;
//     }

//     /**
//      * Wrapper class holding an Intent and implementing comparisons on it for
//      * the purpose of filtering.  The class implements its
//      * {@link #equals equals()} and {@link #hashCode hashCode()} methods as
//      * simple calls to {@link Intent#filterEquals(Intent)}  filterEquals()} and
//      * {@link android.content.Intent#filterHashCode()}  filterHashCode()}
//      * on the wrapped Intent.
//      */
//     class CIntentFilterComparison {
//         constructor(
//             [in] IIntent* intent);

//         interface IIntentFilterComparison;
//     }

//     /**
//      * Structured description of Intent values to be matched.  An IntentFilter can
//      * match against actions, categories, and data (either via its type, scheme,
//      * and/or path) in an Intent.  It also includes a "priority" value which is
//      * used to order multiple matching filters.
//      *
//      * <p>IntentFilter objects are often created in XML as part of a package's
//      * {@link android.R.styleable#AndroidManifest AndroidManifest.xml} file,
//      * using {@link android.R.styleable#AndroidManifestIntentFilter intent-filter}
//      * tags.
//      *
//      * <p>There are three Intent characteristics you can filter on: the
//      * <em>action</em>, <em>data</em>, and <em>categories</em>.  For each of these
//      * characteristics you can provide
//      * multiple possible matching values (via {@link #addAction},
//      * {@link #addDataType}, {@link #addDataScheme} {@link #addDataAuthority},
//      * {@link #addDataPath}, and {@link #addCategory}, respectively).
//      * For actions, the field
//      * will not be tested if no values have been given (treating it as a wildcard);
//      * if no data characteristics are specified, however, then the filter will
//      * only match intents that contain no data.
//      *
//      * <p>The data characteristic is
//      * itself divided into three attributes: type, scheme, authority, and path.
//      * Any that are
//      * specified must match the contents of the Intent.  If you specify a scheme
//      * but no type, only Intent that does not have a type (such as mailto:) will
//      * match; a content: URI will never match because they always have a MIME type
//      * that is supplied by their content provider.  Specifying a type with no scheme
//      * has somewhat special meaning: it will match either an Intent with no URI
//      * field, or an Intent with a content: or file: URI.  If you specify neither,
//      * then only an Intent with no data or type will match.  To specify an authority,
//      * you must also specify one or more schemes that it is associated with.
//      * To specify a path, you also must specify both one or more authorities and
//      * one or more schemes it is associated with.
//      *
//      * <div class="special reference">
//      * <h3>Developer Guides</h3>
//      * <p>For information about how to create and resolve intents, read the
//      * <a href="{@docRoot}guide/topics/intents/intents-filters.html">Intents and Intent Filters</a>
//      * developer guide.</p>
//      * </div>
//      *
//      * <h3>Filter Rules</h3>
//      * <p>A match is based on the following rules.  Note that
//      * for an IntentFilter to match an Intent, three conditions must hold:
//      * the <strong>action</strong> and <strong>category</strong> must match, and
//      * the data (both the <strong>data type</strong> and
//      * <strong>data scheme+authority+path</strong> if specified) must match.
//      *
//      * <p><strong>Action</strong> matches if any of the given values match the
//      * Intent action, <em>or</em> if no actions were specified in the filter.
//      *
//      * <p><strong>Data Type</strong> matches if any of the given values match the
//      * Intent type.  The Intent
//      * type is determined by calling {@link Intent#resolveType}.  A wildcard can be
//      * used for the MIME sub-type, in both the Intent and IntentFilter, so that the
//      * type "audio/*" will match "audio/mpeg", "audio/aiff", "audio/*", etc.
//      * <em>Note that MIME type matching here is <b>case sensitive</b>, unlike
//      * formal RFC MIME types!</em>  You should thus always use lower case letters
//      * for your MIME types.
//      *
//      * <p><strong>Data Scheme</strong> matches if any of the given values match the
//      * Intent data's scheme.
//      * The Intent scheme is determined by calling {@link Intent#getData}
//      * and {@link android.net.Uri#getScheme} on that URI.
//      * <em>Note that scheme matching here is <b>case sensitive</b>, unlike
//      * formal RFC schemes!</em>  You should thus always use lower case letters
//      * for your schemes.
//      *
//      * <p><strong>Data Authority</strong> matches if any of the given values match
//      * the Intent's data authority <em>and</em> one of the data scheme's in the filter
//      * has matched the Intent, <em>or</em> no authories were supplied in the filter.
//      * The Intent authority is determined by calling
//      * {@link Intent#getData} and {@link android.net.Uri#getAuthority} on that URI.
//      * <em>Note that authority matching here is <b>case sensitive</b>, unlike
//      * formal RFC host names!</em>  You should thus always use lower case letters
//      * for your authority.
//      *
//      * <p><strong>Data Path</strong> matches if any of the given values match the
//      * Intent's data path <em>and</em> both a scheme and authority in the filter
//      * has matched against the Intent, <em>or</em> no paths were supplied in the
//      * filter.  The Intent authority is determined by calling
//      * {@link Intent#getData} and {@link android.net.Uri#getPath} on that URI.
//      *
//      * <p><strong>Categories</strong> match if <em>all</em> of the categories in
//      * the Intent match categories given in the filter.  Extra categories in the
//      * filter that are not in the Intent will not cause the match to fail.  Note
//      * that unlike the action, an IntentFilter with no categories
//      * will only match an Intent that does not have any categories.
//      */
//     class CIntentFilter {
//         /**
//          * New empty IntentFilter.
//          */
//         constructor();

//         /**
//          * New IntentFilter that matches a single action with no data.  If
//          * no data characteristics are subsequently specified, then the
//          * filter will only match intents that contain no data.
//          *
//          * @param action The action to match, i.e. Intent.ACTION_MAIN.
//          */
//         constructor(
//             [in] String action);

//         /**
//          * New IntentFilter that matches a single action and data type.
//          *
//          * <p><em>Note: MIME type matching in the Android framework is
//          * case-sensitive, unlike formal RFC MIME types.  As a result,
//          * you should always write your MIME types with lower case letters,
//          * and any MIME types you receive from outside of Android should be
//          * converted to lower case before supplying them here.</em></p>
//          *
//          * <p>Throws {@link MalformedMimeTypeException} if the given MIME type is
//          * not syntactically correct.
//          *
//          * @param action The action to match, i.e. Intent.ACTION_VIEW.
//          * @param dataType The type to match, i.e. "vnd.android.cursor.dir/person".
//          *
//          */
//         constructor(
//             [in] String action,
//             [in] String dataType);

//         /**
//          * New IntentFilter containing a copy of an existing filter.
//          *
//          * @param o The original filter to copy.
//          */
//         constructor(
//             [in] IIntentFilter* o);

//         interface IIntentFilter;
//         interface IParcelable;
//     }

//     singleton class CIntentFilterHelper {

//         interface IIntentFilterHelper;
//     }

//     /**
//      * This is an entry for a single authority in the Iterator returned by
//      * {@link #authoritiesIterator()}.
//      */
//     class CIntentFilterAuthorityEntry {
//         constructor();

//         constructor(
//             [in] String host,
//             [in] String port);

//         interface IIntentFilterAuthorityEntry;
//         interface IParcelable;
//     }

//     /**
//      * A description of an Intent and target action to perform with it.
//      * The returned object can be
//      * handed to other applications so that they can perform the action you
//      * described on your behalf at a later time.
//      *
//      * <p>By giving a IntentSender to another application,
//      * you are granting it the right to perform the operation you have specified
//      * as if the other application was yourself (with the same permissions and
//      * identity).  As such, you should be careful about how you build the IntentSender:
//      * often, for example, the base Intent you supply will have the component
//      * name explicitly set to one of your own components, to ensure it is ultimately
//      * sent there and nowhere else.
//      *
//      * <p>A IntentSender itself is simply a reference to a token maintained by
//      * the system describing the original data used to retrieve it.  This means
//      * that, even if its owning application's process is killed, the
//      * IntentSender itself will remain usable from other processes that
//      * have been given it.  If the creating application later re-retrieves the
//      * same kind of IntentSender (same operation, same Intent action, data,
//      * categories, and components, and same flags), it will receive a IntentSender
//      * representing the same token if that is still valid.
//      *
//      * <p>Instances of this class can not be made directly, but rather must be
//      * created from an existing {@link android.app.PendingIntent} with
//      * {@link android.app.PendingIntent#getIntentSender() PendingIntent.getIntentSender()}.
//      */
//     class CIntentSender {
//         constructor();

//         /** @hide */
//         constructor(
//             [in] IIIntentSender* target);

//         interface IIntentSender;
//         interface IParcelable;
//     }

//     singleton class CIntentSenderHelper {
//         interface IIntentSenderHelper;
//     }

//     /**
//      * Value type that contains information about a periodic sync. Is parcelable, making it suitable
//      * for passing in an IPC.
//      */
//     class CPeriodicSync {
//         constructor();

//         /** Creates a new PeriodicSync, copying the Bundle */
//         constructor(
//             [in] IAccount* account,
//             [in] String authority,
//             [in] IBundle* extras,
//             [in] Int64 period);

//         interface IPeriodicSync;
//         interface IParcelable;
//     }

//     /**
//      * Value type that represents a SyncAdapterType. This object overrides {@link #equals} and
//      * {@link #hashCode}, making it suitable for use as the key of a {@link java.util.Map}
//      */
//     class CSyncAdapterType {
//         constructor();

//         constructor(
//             [in] String authority,
//             [in] String accountType,
//             [in] Boolean userVisible,
//             [in] Boolean supportsUploading);

//         /** @hide */
//         constructor(
//             [in] String authority,
//             [in] String accountType,
//             [in] Boolean userVisible,
//             [in] Boolean supportsUploading,
//             [in] Boolean isAlwaysSyncable,
//             [in] Boolean allowParallelSyncs,
//             [in] String settingsActivity);

//         constructor(
//             [in] String authority,
//             [in] String accountType);

//         interface ISyncAdapterType;
//         interface IParcelable;
//     }

//     singleton class CSyncAdapterTypeHelper {

//         interface ISyncAdapterTypeHelper;
//     }

//     class CSyncContext {
//         /**
//          * @hide
//          */
//         constructor(
//             [in] IISyncContext* syncContextInterface);

//         interface ISyncContext;
//     }

//     /**
//      * Information about the sync operation that is currently underway.
//      */
//     class CSyncInfo {
//         constructor();

//         /** @hide */
//         constructor(
//             [in] Int32 authorityId,
//             [in] IAccount* account,
//             [in] String authority,
//             [in] Int64 startTime);

//         interface ISyncInfo;
//         interface IParcelable;
//     }

//     /**
//      * @hide
//      */
//     [local]
//     class CSyncManager {
//         /**
//          * Should only be created after {@link ContentService#systemReady()} so that
//          * {@link PackageManager} is ready to query.
//          */
//         constructor(
//             [in] IContext* ctx,
//             [in] Boolean factoryTest);

//         interface ISyncManager;
//     }

//     /**
//      * Value type that represents a sync operation.
//      * @hide
//      */
//     class CSyncOperation {
//         constructor(
//             [in] ISyncOperation* other);

//         constructor(
//             [in] IAccount* account,
//             [in] Int32 userId,
//             [in] Int32 source,
//             [in] String authority,
//             [in] IBundle* extras,
//             [in] Int64 delayInMs,
//             [in] Int64 backoff,
//             [in] Int64 delayUntil,
//             [in] Boolean allowParallelSyncs);

//         interface ISyncOperation;
//     }

//     /**
//      * This class is used to communicate the results of a sync operation to the SyncManager.
//      * Based on the values here the SyncManager will determine the disposition of the
//      * sync and whether or not a new sync operation needs to be scheduled in the future.
//      *
//      */
//     class CSyncResult {
//         /**
//          * Create a "clean" SyncResult. If this is returned without any changes then the
//          * SyncManager will consider the sync to have completed successfully. The various fields
//          * can be set by the SyncAdapter in order to give the SyncManager more information as to
//          * the disposition of the sync.
//          * <p>
//          * The errors are classified into two broad categories: hard errors and soft errors.
//          * Soft errors are retried with exponential backoff. Hard errors are not retried (except
//          * when the hard error is for a {@link ContentResolver#SYNC_EXTRAS_UPLOAD} request,
//          * in which the request is retryed without the {@link ContentResolver#SYNC_EXTRAS_UPLOAD}
//          * extra set). The SyncManager checks the type of error by calling
//          * {@link SyncResult#hasHardError()} and  {@link SyncResult#hasSoftError()}. If both are
//          * true then the SyncManager treats it as a hard error, not a soft error.
//          */
//         constructor();

//         /**
//          * Internal helper for creating a clean SyncResult or one that indicated that
//          * a sync is already in progress.
//          * @param syncAlreadyInProgress if true then set the {@link #syncAlreadyInProgress} flag
//          */
//         constructor(
//             [in] Boolean syncAlreadyInProgress);

//         interface ISyncResult;
//         interface IParcelable;
//     }

//     singleton class CSyncResultHelper {

//         interface ISyncResultHelper;
//     }

//     /**
//      * Used to record various statistics about the result of a sync operation. The SyncManager
//      * gets access to these via a {@link SyncResult} and uses some of them to determine the
//      * disposition of the sync. See {@link SyncResult} for further dicussion on how the
//      * SyncManager uses these values.
//      */
//     class CSyncStats {
//         constructor();

//         interface ISyncStats;
//         interface IParcelable;
//     }

//     /** @hide */
//     class CSyncStatusInfo {
//         constructor();

//         constructor(
//             [in] Int32 authorityId);

//         interface ISyncStatusInfo;
//         interface IParcelable;
//     }

//     /**
//      * Singleton that tracks the sync data and overall sync
//      * history on the device.
//      *
//      * @hide
//      */
//     [local]
//     class CSyncStorageEngine {
//         constructor(
//             [in] IContext* ctx,
//             [in] IFile* dataDir);

//         interface ISyncStorageEngine;
//     }

//     class CSyncStorageEnginePendingOperation {
//         constructor(
//             [in] IAccount* account,
//             [in] Int32 userId,
//             [in] Int32 source,
//             [in] String authority,
//             [in] IBundle* extras,
//             [in] Boolean expedited);

//         constructor(
//             [in] ISyncStorageEnginePendingOperation* other);

//         interface ISyncStorageEnginePendingOperation;
//     }

//     class CSyncStorageEngineAuthorityInfo {
//         /**
//          * Copy constructor for making deep-ish copies. Only the bundles stored
//          * in periodic syncs can make unexpected changes.
//          *
//          * @param toCopy AuthorityInfo to be copied.
//          */
//         constructor(
//             [in] ISyncStorageEngineAuthorityInfo* toCopy);

//         constructor(
//             [in] IAccount* account,
//             [in] Int32 userId,
//             [in] String authority,
//             [in] Int32 ident);

//         interface ISyncStorageEngineAuthorityInfo;
//     }

//     class CSyncStorageEngineSyncHistoryItem {

//         interface ISyncStorageEngineSyncHistoryItem;
//     }

//     class CSyncStorageEngineDayStats {
//         constructor(
//             [in] Int32 day);

//         interface ISyncStorageEngineDayStats;
//     }

//     singleton class CSyncStorageEngineHelper {

//         interface ISyncStorageEngineHelper;
//     }

//     /***
//      * Utility class to aid in matching URIs in content providers.
//      *
//      * <p>To use this class, build up a tree of <code>UriMatcher</code> objects.
//      * For example:
//      * <pre>
//      *     private static final int PEOPLE = 1;
//      *     private static final int PEOPLE_ID = 2;
//      *     private static final int PEOPLE_PHONES = 3;
//      *     private static final int PEOPLE_PHONES_ID = 4;
//      *     private static final int PEOPLE_CONTACTMETHODS = 7;
//      *     private static final int PEOPLE_CONTACTMETHODS_ID = 8;
//      *
//      *     private static final int DELETED_PEOPLE = 20;
//      *
//      *     private static final int PHONES = 9;
//      *     private static final int PHONES_ID = 10;
//      *     private static final int PHONES_FILTER = 14;
//      *
//      *     private static final int CONTACTMETHODS = 18;
//      *     private static final int CONTACTMETHODS_ID = 19;
//      *
//      *     private static final int CALLS = 11;
//      *     private static final int CALLS_ID = 12;
//      *     private static final int CALLS_FILTER = 15;
//      *
//      *     private static final UriMatcher sURIMatcher = new UriMatcher(UriMatcher.NO_MATCH);
//      *
//      *     static
//      *     {
//      *         sURIMatcher.addURI("contacts", "people", PEOPLE);
//      *         sURIMatcher.addURI("contacts", "people/#", PEOPLE_ID);
//      *         sURIMatcher.addURI("contacts", "people/#/phones", PEOPLE_PHONES);
//      *         sURIMatcher.addURI("contacts", "people/#/phones/#", PEOPLE_PHONES_ID);
//      *         sURIMatcher.addURI("contacts", "people/#/contact_methods", PEOPLE_CONTACTMETHODS);
//      *         sURIMatcher.addURI("contacts", "people/#/contact_methods/#", PEOPLE_CONTACTMETHODS_ID);
//      *         sURIMatcher.addURI("contacts", "deleted_people", DELETED_PEOPLE);
//      *         sURIMatcher.addURI("contacts", "phones", PHONES);
//      *         sURIMatcher.addURI("contacts", "phones/filter/*", PHONES_FILTER);
//      *         sURIMatcher.addURI("contacts", "phones/#", PHONES_ID);
//      *         sURIMatcher.addURI("contacts", "contact_methods", CONTACTMETHODS);
//      *         sURIMatcher.addURI("contacts", "contact_methods/#", CONTACTMETHODS_ID);
//      *         sURIMatcher.addURI("call_log", "calls", CALLS);
//      *         sURIMatcher.addURI("call_log", "calls/filter/*", CALLS_FILTER);
//      *         sURIMatcher.addURI("call_log", "calls/#", CALLS_ID);
//      *     }
//      * </pre>
//      * <p>Then when you need to match against a URI, call {@link #match}, providing
//      * the URL that you have been given.  You can use the result to build a query,
//      * return a type, insert or delete a row, or whatever you need, without duplicating
//      * all of the if-else logic that you would otherwise need.  For example:
//      * <pre>
//      *     public String getType(Uri url)
//      *     {
//      *         int match = sURIMatcher.match(url);
//      *         switch (match)
//      *         {
//      *             case PEOPLE:
//      *                 return "vnd.android.cursor.dir/person";
//      *             case PEOPLE_ID:
//      *                 return "vnd.android.cursor.item/person";
//      * ... snip ...
//      *                 return "vnd.android.cursor.dir/snail-mail";
//      *             case PEOPLE_ADDRESS_ID:
//      *                 return "vnd.android.cursor.item/snail-mail";
//      *             default:
//      *                 return null;
//      *         }
//      *     }
//      * </pre>
//      * instead of:
//      * <pre>
//      *     public String getType(Uri url)
//      *     {
//      *         List<String> pathSegments = url.getPathSegments();
//      *         if (pathSegments.size() >= 2) {
//      *             if ("people".equals(pathSegments.get(1))) {
//      *                 if (pathSegments.size() == 2) {
//      *                     return "vnd.android.cursor.dir/person";
//      *                 } else if (pathSegments.size() == 3) {
//      *                     return "vnd.android.cursor.item/person";
//      * ... snip ...
//      *                     return "vnd.android.cursor.dir/snail-mail";
//      *                 } else if (pathSegments.size() == 3) {
//      *                     return "vnd.android.cursor.item/snail-mail";
//      *                 }
//      *             }
//      *         }
//      *         return null;
//      *     }
//      * </pre>
//      */
//     class CUriMatcher {
//         /**
//          * Creates the root node of the URI tree.
//          *
//          * @param code the code to match for the root URI
//          */
//         constructor(
//             [in] Int32 code);

//         interface IUriMatcher;
//     }


//     /**
//      * Special version of {@link ContextWrapper} that allows the base context to
//      * be modified after it is initially set.
//      */
//     [local]
//     class CMutableContextWrapper {
//         constructor(
//             [in] IContext* base);

//         interface IMutableContextWrapper;
//     }

//     /**
//      * This superclass can be used to create a simple search suggestions provider for your application.
//      * It creates suggestions (as the user types) based on recent queries and/or recent views.
//      *
//      * <p>In order to use this class, you must do the following.
//      *
//      * <ul>
//      * <li>Implement and test query search, as described in {@link android.app.SearchManager}.  (This
//      * provider will send any suggested queries via the standard
//      * {@link android.content.Intent#ACTION_SEARCH ACTION_SEARCH} Intent, which you'll already
//      * support once you have implemented and tested basic searchability.)</li>
//      * <li>Create a Content Provider within your application by extending
//      * {@link android.content.SearchRecentSuggestionsProvider}.  The class you create will be
//      * very simple - typically, it will have only a constructor.  But the constructor has a very
//      * important responsibility:  When it calls {@link #setupSuggestions(String, int)}, it
//      * <i>configures</i> the provider to match the requirements of your searchable activity.</li>
//      * <li>Create a manifest entry describing your provider.  Typically this would be as simple
//      * as adding the following lines:
//      * <pre class="prettyprint">
//      *     &lt;!-- Content provider for search suggestions --&gt;
//      *     &lt;provider android:name="YourSuggestionProviderClass"
//      *               android:authorities="your.suggestion.authority" /&gt;</pre>
//      * </li>
//      * <li>Please note that you <i>do not</i> instantiate this content provider directly from within
//      * your code.  This is done automatically by the system Content Resolver, when the search dialog
//      * looks for suggestions.</li>
//      * <li>In order for the Content Resolver to do this, you must update your searchable activity's
//      * XML configuration file with information about your content provider.  The following additions
//      * are usually sufficient:
//      * <pre class="prettyprint">
//      *     android:searchSuggestAuthority="your.suggestion.authority"
//      *     android:searchSuggestSelection=" ? "</pre>
//      * </li>
//      * <li>In your searchable activities, capture any user-generated queries and record them
//      * for future searches by calling {@link android.provider.SearchRecentSuggestions#saveRecentQuery
//      * SearchRecentSuggestions.saveRecentQuery()}.</li>
//      * </ul>
//      *
//      * <div class="special reference">
//      * <h3>Developer Guides</h3>
//      * <p>For information about using search suggestions in your application, read the
//      * <a href="{@docRoot}guide/topics/search/index.html">Search</a> developer guide.</p>
//      * </div>
//      *
//      * @see android.provider.SearchRecentSuggestions
//      */
//     class CSearchRecentSuggestionsProvider {

//         interface IContentProvider;
//     }


//     } // namespace Content
//     } // namespace Droid
//     } // namespace Elastos

//     namespace Elastos {
//     namespace Droid {
//     namespace Internal {
//     namespace Content {

//     /**
//      * Native libraries helper.
//      *
//      * @hide
//      */
//     singleton class CNativeLibraryHelper {

//         interface INativeLibraryHelper;
//     }

//     /**
//      * Constants used internally between the PackageManager
//      * and media container service transports.
//      * Some utility methods to invoke MountService api.
//      */
//     singleton class CPackageHelper {

//         interface IPackageHelper;
//     }

//     /**
//      * Helper for building selection clauses for {@link SQLiteDatabase}. Each
//      * appended clause is combined using {@code AND}. This class is <em>not</em>
//      * thread safe.
//      *
//      * @hide
//      */
//     class CSelectionBuilder {

//         interface ISelectionBuilder;
//     }

//     } // namespace Content
//     } // namespace Internal
//     } // namespace Droid
//     } // namespace Elastos

}

